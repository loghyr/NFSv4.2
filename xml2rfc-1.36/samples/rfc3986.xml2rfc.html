<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Uniform Resource Identifier (URI): Generic Syntax</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Uniform Resource Identifier (URI): Generic Syntax">
<meta name="keywords" content="uniform resource identifier, URI, URL, URN, WWW, resource">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>

<table border="0" cellpadding="0" cellspacing="2" width="30" align="right">
    <tr>
        <td class="RFCbug">
                <span class="RFC">&nbsp;RFC&nbsp;</span><br /><span class="hotText">&nbsp;3986&nbsp;</span>
        </td>
    </tr>
    <tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a><br /></td></tr>
</table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">T. Berners-Lee</td></tr>
<tr><td class="header">Request for Comments: 3986</td><td class="header">W3C/MIT</td></tr>
<tr><td class="header">STD: 66</td><td class="header">R. Fielding</td></tr>
<tr><td class="header">Obsoletes: <a href='http://tools.ietf.org/html/rfc2732'>2732</a>, <a href='http://tools.ietf.org/html/rfc2396'>2396</a>, <a href='http://tools.ietf.org/html/rfc1808'>1808</a></td><td class="header">Day Software</td></tr>
<tr><td class="header">Updates: <a href='http://tools.ietf.org/html/rfc1738'>1738</a></td><td class="header">L. Masinter</td></tr>
<tr><td class="header">Category: Standards Track</td><td class="header">Adobe Systems</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">January 2005</td></tr>
</table></td></tr></table>
<h1><br />Uniform Resource Identifier (URI): Generic Syntax</h1>

<h3>Status of this Memo</h3>
<p>
This document specifies an Internet standards track protocol for the Internet
community, and requests discussion and suggestions for improvements.
Please refer to the current edition of the &ldquo;Internet Official Protocol
Standards&rdquo; (STD&nbsp;1) for the standardization state and status of this
protocol.
Distribution of this memo is unlimited.</p>

<h3>Copyright Notice</h3>
<p>
Copyright &copy; The Internet Society (2005).</p>

<h3>Abstract</h3>

<p>
A Uniform Resource Identifier (URI) is a compact sequence of characters
that identifies an abstract or physical resource.  This specification
defines the generic URI syntax and a process for resolving URI references
that might be in relative form, along with guidelines and security
considerations for the use of URIs on the Internet.
The URI syntax defines a grammar that is a superset of all valid URIs,
allowing an implementation to parse the common components of a URI
reference without knowing the scheme-specific requirements of every
possible identifier.  This specification does not define a generative
grammar for URIs; that task is performed by the individual
specifications of each URI scheme.

</p><a name="toc"></a><hr />

<table border="0" cellpadding="0" cellspacing="2" width="30" align="right">
    <tr>
        <td class="RFCbug">
                <span class="RFC">&nbsp;RFC&nbsp;</span><br /><span class="hotText">&nbsp;3986&nbsp;</span>
        </td>
    </tr>
    <tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a><br /></td></tr>
</table>
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#overview">1.1.</a>&nbsp;
Overview of URIs<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#generic-syntax">1.1.1.</a>&nbsp;
Generic Syntax<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#examples">1.1.2.</a>&nbsp;
Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#URLvsURN">1.1.3.</a>&nbsp;
URI, URL, and URN<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#design">1.2.</a>&nbsp;
Design Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#transcription">1.2.1.</a>&nbsp;
Transcription<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#identification">1.2.2.</a>&nbsp;
Separating Identification from Interaction<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#hierarchical">1.2.3.</a>&nbsp;
Hierarchical Identifiers<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#notation">1.3.</a>&nbsp;
Syntax Notation<br />
<a href="#characters">2.</a>&nbsp;
Characters<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#percent-encoding">2.1.</a>&nbsp;
Percent-Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#reserved">2.2.</a>&nbsp;
Reserved Characters<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#unreserved">2.3.</a>&nbsp;
Unreserved Characters<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#when-to-percent-encode">2.4.</a>&nbsp;
When to Encode or Decode<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#identifying-data">2.5.</a>&nbsp;
Identifying Data<br />
<a href="#components">3.</a>&nbsp;
Syntax Components<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scheme">3.1.</a>&nbsp;
Scheme<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#authority">3.2.</a>&nbsp;
Authority<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#userinfo">3.2.1.</a>&nbsp;
User Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#host">3.2.2.</a>&nbsp;
Host<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#port">3.2.3.</a>&nbsp;
Port<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path">3.3.</a>&nbsp;
Path<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#query">3.4.</a>&nbsp;
Query<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fragment">3.5.</a>&nbsp;
Fragment<br />
<a href="#usage">4.</a>&nbsp;
Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#uri-reference">4.1.</a>&nbsp;
URI Reference<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#relative-ref">4.2.</a>&nbsp;
Relative Reference<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#absolute-uri">4.3.</a>&nbsp;
Absolute URI<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#same-document">4.4.</a>&nbsp;
Same-Document Reference<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#suffix">4.5.</a>&nbsp;
Suffix Reference<br />
<a href="#reference-resolution">5.</a>&nbsp;
Reference Resolution<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#base-uri">5.1.</a>&nbsp;
Establishing a Base URI<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#base-content">5.1.1.</a>&nbsp;
Base URI Embedded in Content<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#base-encapsulated">5.1.2.</a>&nbsp;
Base URI from the Encapsulating Entity<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#base-retrieval">5.1.3.</a>&nbsp;
Base URI from the Retrieval URI<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#base-default">5.1.4.</a>&nbsp;
Default Base URI<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#absolutize">5.2.</a>&nbsp;
Relative Resolution<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#relative-base">5.2.1.</a>&nbsp;
Pre-parse the Base URI<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#relative-transform">5.2.2.</a>&nbsp;
Transform References<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#relative-merge">5.2.3.</a>&nbsp;
Merge Paths<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#relative-dot-segments">5.2.4.</a>&nbsp;
Remove Dot Segments<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#recomposition">5.3.</a>&nbsp;
Component Recomposition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#reference-examples">5.4.</a>&nbsp;
Reference Resolution Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#relative-normal">5.4.1.</a>&nbsp;
Normal Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#relative-abnormal">5.4.2.</a>&nbsp;
Abnormal Examples<br />
<a href="#comparison">6.</a>&nbsp;
Normalization and Comparison<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#equivalence">6.1.</a>&nbsp;
Equivalence<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#comparison-ladder">6.2.</a>&nbsp;
Comparison Ladder<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#comparison-string">6.2.1.</a>&nbsp;
Simple String Comparison<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#normalize-syntax">6.2.2.</a>&nbsp;
Syntax-Based Normalization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#normalize-scheme">6.2.3.</a>&nbsp;
Scheme-Based Normalization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#normalize-protocol">6.2.4.</a>&nbsp;
Protocol-Based Normalization<br />
<a href="#security">7.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#security-reliability">7.1.</a>&nbsp;
Reliability and Consistency<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#security-malicious">7.2.</a>&nbsp;
Malicious Construction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#security-transcoding">7.3.</a>&nbsp;
Back-End Transcoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#security-ipv4">7.4.</a>&nbsp;
Rare IP Address Formats<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#security-sensitive">7.5.</a>&nbsp;
Sensitive Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#security-semantic">7.6.</a>&nbsp;
Semantic Attacks<br />
<a href="#IANA">8.</a>&nbsp;
IANA Considerations<br />
<a href="#ack">9.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#collected-abnf">Appendix&nbsp;A.</a>&nbsp;
Collected ABNF for URI<br />
<a href="#regexp">Appendix&nbsp;B.</a>&nbsp;
Parsing a URI Reference with a Regular Expression<br />
<a href="#delimiting">Appendix&nbsp;C.</a>&nbsp;
Delimiting a URI in Context<br />
<a href="#changes">Appendix&nbsp;D.</a>&nbsp;
Changes from RFC 2396<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#additions">D.1.</a>&nbsp;
Additions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#modifications">D.2.</a>&nbsp;
Modifications<br />
<a href="#rfc.index">&#167;</a>&nbsp;
Index<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
A Uniform Resource Identifier (URI) provides a simple and extensible
means for identifying a resource.  This specification of URI syntax
and semantics is derived from concepts introduced by the World Wide
Web global information initiative, whose use of these identifiers dates
from 1990 and is described in "Universal Resource Identifiers in WWW"
<a class='info' href='#RFC1630'>[RFC1630]<span> (</span><span class='info'>Berners-Lee, T., &ldquo;Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web,&rdquo; June&nbsp;1994.</span><span>)</span></a>.  The syntax is designed to meet the
recommendations laid out in "Functional Recommendations for Internet
Resource Locators" <a class='info' href='#RFC1736'>[RFC1736]<span> (</span><span class='info'>Kunze, J., &ldquo;Functional Recommendations for Internet Resource Locators,&rdquo; February&nbsp;1995.</span><span>)</span></a> and "Functional Requirements
for Uniform Resource Names" <a class='info' href='#RFC1737'>[RFC1737]<span> (</span><span class='info'>Sollins, K. and L. Masinter, &ldquo;Functional Requirements for Uniform Resource Names,&rdquo; December&nbsp;1994.</span><span>)</span></a>.

</p>
<p>
This document obsoletes <a class='info' href='#RFC2396'>[RFC2396]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifiers (URI): Generic Syntax,&rdquo; August&nbsp;1998.</span><span>)</span></a>, which merged
"Uniform Resource Locators" <a class='info' href='#RFC1738'>[RFC1738]<span> (</span><span class='info'>Berners-Lee, T., Masinter, L., and M. McCahill, &ldquo;Uniform Resource Locators (URL),&rdquo; December&nbsp;1994.</span><span>)</span></a> and
"Relative Uniform Resource Locators" <a class='info' href='#RFC1808'>[RFC1808]<span> (</span><span class='info'>Fielding, R., &ldquo;Relative Uniform Resource Locators,&rdquo; June&nbsp;1995.</span><span>)</span></a> in order
to define a single, generic syntax for all URIs.  It obsoletes
<a class='info' href='#RFC2732'>[RFC2732]<span> (</span><span class='info'>Hinden, R., Carpenter, B., and L. Masinter, &ldquo;Format for Literal IPv6 Addresses in URL's,&rdquo; December&nbsp;1999.</span><span>)</span></a>, which introduced syntax for an IPv6 address.  It
excludes portions of RFC 1738 that defined the specific syntax of individual
URI schemes; those portions will be updated as separate documents.
The process for registration of new URI schemes is defined separately
by <a class='info' href='#BCP35'>[BCP35]<span> (</span><span class='info'>Petke, R. and I. King, &ldquo;Registration Procedures for URL Scheme Names,&rdquo; November&nbsp;1999.</span><span>)</span></a>.
Advice for designers of new URI schemes can be found in
<a class='info' href='#RFC2718'>[RFC2718]<span> (</span><span class='info'>Masinter, L., Alvestrand, H., Zigmond, D., and R. Petke, &ldquo;Guidelines for new URL Schemes,&rdquo; November&nbsp;1999.</span><span>)</span></a>.  All significant changes from RFC 2396 are
noted in <a class='info' href='#changes'>Appendix&nbsp;D<span> (</span><span class='info'>Changes from RFC 2396</span><span>)</span></a>.

</p><a name='anchor3'></a><a name='anchor4'></a><a name='anchor5'></a>
<p>
This specification uses the terms "character" and "coded character set"
in accordance with the definitions provided in <a class='info' href='#BCP19'>[BCP19]<span> (</span><span class='info'>Freed, N. and J. Postel, &ldquo;IANA Charset Registration Procedures,&rdquo; October&nbsp;2000.</span><span>)</span></a>,
and "character encoding" in place of what <a class='info' href='#BCP19'>[BCP19]<span> (</span><span class='info'>Freed, N. and J. Postel, &ldquo;IANA Charset Registration Procedures,&rdquo; October&nbsp;2000.</span><span>)</span></a>
refers to as a "charset".

</p>
<a name="overview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Overview of URIs</h3>

<p>
URIs are characterized as follows:

</p><a name='anchor6'></a>
<p>Uniform
  </p>
<blockquote class="text">
<p>
Uniformity provides several benefits.  It allows different types
of resource identifiers to be used in the same context, even
when the mechanisms used to access those resources may differ.  It
allows uniform semantic interpretation of common syntactic
conventions across different types of resource identifiers.  It
allows introduction of new types of resource identifiers
without interfering with the way that existing identifiers are
used.  It allows the identifiers to be reused in many
different contexts, thus permitting new applications or
protocols to leverage a pre-existing, large, and widely used
set of resource identifiers.
    
</p>
</blockquote><p>

</p><a name='anchor7'></a>
<p>Resource
  </p>
<blockquote class="text">
<p>
This specification does not limit the scope of what might be a resource;
rather, the term "resource" is used in a general sense for whatever
might be identified by a URI.
Familiar examples include an electronic document, an image,
a source of information with a consistent purpose
(e.g., "today's weather report for Los Angeles"),
a service (e.g., an HTTP-to-SMS gateway),
and a collection of other resources.
A resource is not necessarily accessible via the Internet;
e.g., human beings, corporations, and bound books in a library
can also be resources.
Likewise, abstract concepts can be resources, such as
the operators and operands of a mathematical equation,
the types of a relationship (e.g., "parent" or "employee"),
or numeric values (e.g., zero, one, and infinity).
    
</p>
</blockquote><p>

</p><a name='anchor8'></a>
<p>Identifier
  </p>
<blockquote class="text">
<p>
An identifier embodies the information required to distinguish what is
being identified from all other things within its scope of identification.
Our use of the terms "identify" and "identifying" refer to this purpose
of distinguishing one resource from all other resources, regardless of
how that purpose is accomplished (e.g., by name, address, or context).
These terms should not be mistaken as an assumption that an identifier
defines or embodies the identity of what is referenced, though that
may be the case for some identifiers. Nor should it be assumed that a
system using URIs will access the resource identified: in many cases,
URIs are used to denote resources without any intention that they be
accessed.  Likewise, the "one" resource identified might not be singular
in nature (e.g., a resource might be a named set or a mapping that
varies over time).
    
</p>
</blockquote><p>

</p>
<p>
A URI is an identifier consisting of a sequence of characters matching
the syntax rule named &lt;URI&gt; in <a class='info' href='#components'>Section&nbsp;3<span> (</span><span class='info'>Syntax Components</span><span>)</span></a>.  It
enables uniform identification of resources via a separately defined
extensible set of naming schemes (<a class='info' href='#scheme'>Section&nbsp;3.1<span> (</span><span class='info'>Scheme</span><span>)</span></a>).
How that identification is accomplished, assigned, or enabled is delegated
to each scheme specification.

</p>
<p>
This specification does not place any limits on the nature of a resource,
the reasons why an application might seek to refer to a resource, or the
kinds of systems that might use URIs for the sake of identifying resources.
This specification does not require that a URI persists in identifying the
same resource over time, though that is a common goal of all URI schemes.
Nevertheless, nothing in this specification prevents an application from
limiting itself to particular types of resources, or to a subset of URIs
that maintains characteristics desired by that application.

</p>
<p>
URIs have a global scope and are interpreted consistently regardless
of context, though the result of that interpretation may be in relation
to the end-user's context.  For example, "http://localhost/" has the same
interpretation for every user of that reference, even though the network
interface corresponding to "localhost" may be different for each end-user:
interpretation is independent of access.  However, an action made on
the basis of that reference will take place in relation to the end-user's
context, which implies that an action intended to refer to a 
globally unique thing must use a URI that distinguishes that resource
from all other things.  URIs that identify in relation to the end-user's
local context should only be used when the context itself is a defining
aspect of the resource, such as when an on-line help manual refers to a
file on the end-user's file system (e.g., "file:///etc/hosts").

</p>
<a name="generic-syntax"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.1"></a><h3>1.1.1.&nbsp;
Generic Syntax</h3>
<a name='anchor9'></a>
<p>
Each URI begins with a scheme name, as defined in <a class='info' href='#scheme'>Section&nbsp;3.1<span> (</span><span class='info'>Scheme</span><span>)</span></a>,
that refers to a specification for assigning identifiers within that scheme.
As such, the URI syntax is a federated and extensible naming system wherein
each scheme's specification may further restrict the syntax and semantics
of identifiers using that scheme.

</p>
<p>
This specification defines those elements of the URI syntax that are
required of all URI schemes or are common to many URI schemes.  It thus
defines the syntax and semantics needed to implement a
scheme-independent parsing mechanism for URI references, by which the
scheme-dependent handling of a URI can be postponed until the
scheme-dependent semantics are needed.  Likewise, protocols and data
formats that make use of URI references can refer to this specification
as a definition for the range of syntax allowed for all URIs, including those
schemes that have yet to be defined.  This decouples the evolution of
identification schemes from the evolution of protocols, data formats,
and implementations that make use of URIs.

</p>
<p>
A parser of the generic URI syntax can parse any URI
reference into its major components.  Once the scheme is determined,
further scheme-specific parsing can be performed on the components.
In other words, the URI generic syntax is a superset of the syntax
of all URI schemes.

</p>
<a name="examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.2"></a><h3>1.1.2.&nbsp;
Examples</h3>

<p style='text-align: left'>
The following example URIs illustrate several URI schemes and
variations in their common syntax components:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   ftp://ftp.is.co.za/rfc/rfc1808.txt

   http://www.ietf.org/rfc/rfc2396.txt

   ldap://[2001:db8::7]/c=GB?objectClass?one

   mailto:John.Doe@example.com

   news:comp.infosystems.www.servers.unix

   tel:+1-816-555-1212

   telnet://192.0.2.16:80/

   urn:oasis:names:specification:docbook:dtd:xml:4.1.2
</pre></div>
<a name="URLvsURN"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1.3"></a><h3>1.1.3.&nbsp;
URI, URL, and URN</h3>
<a name='anchor10'></a><a name='anchor11'></a><a name='anchor12'></a><a name='anchor13'></a>
<p>
A URI can be further classified as a locator, a name, or both.  The
term "Uniform Resource Locator" (URL) refers to the subset of URIs
that, in addition to identifying a resource, provide a means of
locating the resource by describing its primary access mechanism
(e.g., its network "location").  The term "Uniform Resource Name" (URN)
has been used historically to refer to both URIs under the "urn" scheme
<a class='info' href='#RFC2141'>[RFC2141]<span> (</span><span class='info'>Moats, R., &ldquo;URN Syntax,&rdquo; May&nbsp;1997.</span><span>)</span></a>, which are required to remain globally unique
and persistent even when the resource ceases to exist or becomes
unavailable, and to any other URI with the properties of a name.

</p>
<p>
An individual scheme does not have to be classified as being just one of
"name" or "locator".  Instances of URIs from any given scheme may have
the characteristics of names or locators or both, often depending on the
persistence and care in the assignment of identifiers by the naming
authority, rather than on any quality of the scheme.  Future specifications
and related documentation should use the general term "URI" rather than
the more restrictive terms "URL" and "URN" <a class='info' href='#RFC3305'>[RFC3305]<span> (</span><span class='info'>Mealling, M. and R. Denenberg, &ldquo;Report from the Joint W3C/IETF URI Planning Interest Group: Uniform Resource Identifiers (URIs), URLs, and Uniform Resource Names (URNs): Clarifications and Recommendations,&rdquo; August&nbsp;2002.</span><span>)</span></a>.

</p>
<a name="design"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Design Considerations</h3>

<a name="transcription"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.1"></a><h3>1.2.1.&nbsp;
Transcription</h3>
<a name='anchor14'></a>
<p>
The URI syntax has been designed with global transcription as one of
its main considerations.  A URI is a sequence of characters from a very
limited set: the letters of the basic Latin alphabet, digits,
and a few special characters.  A URI may be represented in a variety
of ways; e.g., ink on paper, pixels on a screen, or a sequence of
character encoding octets.  The interpretation of a URI depends only
on the characters used and not on how those characters are represented
in a network protocol.

</p>
<p>
The goal of transcription can be described by a simple scenario.
Imagine two colleagues, Sam and Kim, sitting in a pub at an
international conference and exchanging research ideas.  Sam asks Kim
for a location to get more information, so Kim writes the URI for the
research site on a napkin.  Upon returning home, Sam takes out the
napkin and types the URI into a computer, which then retrieves the
information to which Kim referred.

</p>
<p>
There are several design considerations revealed by the scenario:
  </p>
<ul class="text">
<li>
A URI is a sequence of characters that is not always
represented as a sequence of octets.
    
</li>
<li>
A URI might be transcribed from a non-network source and thus
should consist of characters that are most likely able to
be entered into a computer, within the constraints imposed by
keyboards (and related input devices) across languages and locales.
    
</li>
<li>
A URI often has to be remembered by people, and it is easier
for people to remember a URI when it consists of meaningful or
familiar components.
    
</li>
</ul><p>

</p>
<p>
These design considerations are not always in alignment.  For example, it
is often the case that the most meaningful name for a URI component
would require characters that cannot be typed into some systems.  The
ability to transcribe a resource identifier from one medium to
another has been considered more important than having a URI consist of
the most meaningful of components.

</p>
<p>
In local or regional contexts and with improving technology, users might
benefit from being able to use a wider range of characters; such use
is not defined by this specification.  Percent-encoded octets
(<a class='info' href='#percent-encoding'>Section&nbsp;2.1<span> (</span><span class='info'>Percent-Encoding</span><span>)</span></a>) may be used within a URI to represent
characters outside the range of the US-ASCII coded character set if this
representation is allowed by the scheme or by the protocol element
in which the URI is referenced.  Such a definition should specify the
character encoding used to map those characters to octets prior
to being percent-encoded for the URI.

</p>
<a name="identification"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.2"></a><h3>1.2.2.&nbsp;
Separating Identification from Interaction</h3>
<a name='anchor15'></a>
<p>
A common misunderstanding of URIs is that they are only used to
refer to accessible resources.  The URI itself only provides
identification; access to the resource is neither guaranteed nor
implied by the presence of a URI.  Instead, any operation
associated with a URI reference is defined by the protocol element,
data format attribute, or natural language text in which it appears.

</p><a name='anchor16'></a><a name='anchor17'></a>
<p>
Given a URI, a system may attempt to perform a variety of operations
on the resource, as might be characterized by words such as
"access", "update", "replace", or "find attributes".  Such operations
are defined by the protocols that make use of URIs, not by this
specification.  However, we do use a few general terms for describing
common operations on URIs.  URI "resolution" is the process of determining
an access mechanism and the appropriate parameters necessary to dereference
a URI; this resolution may require several iterations.  To use that access
mechanism to perform an action on the URI's resource is to "dereference"
the URI.

</p><a name='anchor18'></a><a name='anchor19'></a>
<p>
When URIs are used within information retrieval systems to identify sources
of information, the most common form of URI dereference is "retrieval":
making use of a URI in order to retrieve a representation of its associated
resource.  A "representation" is a sequence of octets, along with
representation metadata describing those octets, that constitutes a
record of the state of the resource at the time when the representation
is generated.  Retrieval is achieved by a process that might include
using the URI as a cache key to check for a locally cached representation,
resolution of the URI to determine an appropriate access mechanism (if any),
and dereference of the URI for the sake of applying a retrieval operation.
Depending on the protocols used to perform the retrieval, additional
information might be supplied about the resource (resource metadata)
and its relation to other resources.

</p><a name='anchor20'></a>
<p>
URI references in information retrieval systems are designed to be late-binding:
the result of an access is generally determined when it is accessed
and may vary over time or due to other aspects of the interaction.
These references are created in order to be used in the future:
what is being identified is not some specific result that was obtained
in the past, but rather some characteristic that is expected to be true
for future results.  In such cases, the resource referred to by the URI
is actually a sameness of characteristics as observed over time, perhaps
elucidated by additional comments or assertions made by the resource provider.

</p>
<p>
Although many URI schemes are named after protocols, this does not
imply that use of these URIs will result in access to the resource
via the named protocol.  URIs are often used simply for the sake of
identification.  Even when a URI is used to retrieve a representation
of a resource, that access might be through gateways, proxies, caches,
and name resolution services that are independent of the protocol
associated with the scheme name.  The resolution of some URIs may
require the use of more than one protocol (e.g., both DNS and HTTP
are typically used to access an "http" URI's origin server when
a representation isn't found in a local cache).

</p>
<a name="hierarchical"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2.3"></a><h3>1.2.3.&nbsp;
Hierarchical Identifiers</h3>
<a name='anchor21'></a>
<p>
The URI syntax is organized hierarchically, with components listed
in order of decreasing significance from left to right.  For some URI schemes,
the visible hierarchy is limited to the scheme itself: everything after
the scheme component delimiter (":") is considered opaque to URI processing.
Other URI schemes make the hierarchy explicit and visible to
generic parsing algorithms.

</p>
<p>
The generic syntax uses the slash ("/"), question mark ("?"), and
number sign ("#") characters to delimit components
that are significant to the generic parser's hierarchical interpretation
of an identifier.  In addition to aiding the readability of such
identifiers through the consistent use of familiar syntax, this
uniform representation of hierarchy across naming schemes allows
scheme-independent references to be made relative to that hierarchy.

</p><a name='anchor22'></a>
<p>
It is often the case that a group or "tree" of documents has been
constructed to serve a common purpose, wherein the vast majority of URI
references in these documents point to resources within the tree rather than
outside it.  Similarly, documents located at a particular site are
much more likely to refer to other resources at that site than to
resources at remote sites.
Relative referencing of URIs allows document trees to be partially
independent of their location and access scheme.  For instance, it is
possible for a single set of hypertext documents to be simultaneously
accessible and traversable via each of the "file", "http", and "ftp"
schemes if the documents refer to each other with relative references.
Furthermore, such document trees can be moved, as a whole, without
changing any of the relative references.

</p>
<p>
A relative reference (<a class='info' href='#relative-ref'>Section&nbsp;4.2<span> (</span><span class='info'>Relative Reference</span><span>)</span></a>) refers to a
resource by describing the difference within a hierarchical name space
between the reference context and the target URI.  The reference resolution
algorithm, presented in <a class='info' href='#reference-resolution'>Section&nbsp;5<span> (</span><span class='info'>Reference Resolution</span><span>)</span></a>, defines
how such a reference is transformed to the target URI.
As relative references can only be used within the context of a
hierarchical URI, designers of new URI schemes should use a syntax
consistent with the generic syntax's hierarchical components unless there
are compelling reasons to forbid relative referencing within that scheme.
</p>
<blockquote class="text">
<p>
NOTE: Previous specifications used the terms "partial URI" and "relative URI"
to denote a relative reference to a URI.  As some readers misunderstood
those terms to mean that relative URIs are a subset of URIs rather than a
method of referencing URIs, this specification simply refers to them as
relative references.

</p>
</blockquote><p>

</p>
<p>
All URI references are parsed by generic syntax parsers when used.
However, because hierarchical processing has no effect on an absolute URI
used in a reference unless it contains one or more dot-segments (complete
path segments of "." or "..", as described in <a class='info' href='#path'>Section&nbsp;3.3<span> (</span><span class='info'>Path</span><span>)</span></a>),
URI scheme specifications can define opaque identifiers by disallowing
use of slash characters, question mark characters, and the URIs
"scheme:." and "scheme:..".

</p>
<a name="notation"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Syntax Notation</h3>
<a name='anchor23'></a><a name='anchor24'></a><a name='anchor25'></a><a name='anchor26'></a><a name='anchor27'></a><a name='anchor28'></a><a name='anchor29'></a><a name='anchor30'></a><a name='anchor31'></a>
<p>
This specification uses the Augmented Backus-Naur Form (ABNF) notation of
<a class='info' href='#RFC2234'>[RFC2234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; November&nbsp;1997.</span><span>)</span></a>, including the following core ABNF syntax rules
defined by that specification:
ALPHA (letters), CR (carriage return),
DIGIT (decimal digits), DQUOTE (double quote), <a class='info' href='#notation'>HEXDIG<span> (</span><span class='info'>Syntax Notation</span><span>)</span></a> (hexadecimal digits),
LF (line feed), and SP (space).
The complete URI syntax is collected in <a class='info' href='#collected-abnf'>Appendix&nbsp;A<span> (</span><span class='info'>Collected ABNF for URI</span><span>)</span></a>.

</p>
<a name="characters"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Characters</h3>
<a name='anchor32'></a>
<p>
The URI syntax provides a method of encoding data, presumably for the
sake of identifying a resource, as a sequence of characters.  The URI
characters are, in turn, frequently encoded as octets for transport or
presentation.  This specification does not mandate any particular character
encoding for mapping between URI characters and the octets used
to store or transmit those characters.  When a URI appears in a protocol
element, the character encoding is defined by that protocol; without such
a definition, a URI is assumed to be in the same character encoding as
the surrounding text.

</p>
<p>
The ABNF notation defines its terminal values to be non-negative
integers (codepoints) based on the US-ASCII coded character set
<a class='info' href='#ASCII'>[ASCII]<span> (</span><span class='info'>American National Standards Institute, &ldquo;Coded Character Set -- 7-bit American Standard Code for Information Interchange,&rdquo; 1986.</span><span>)</span></a>.  Because a URI is a sequence of characters,
we must invert that relation in order to understand the URI syntax.
Therefore, the integer values used by the ABNF must be mapped back
to their corresponding characters via US-ASCII in order to complete
the syntax rules.

</p>
<p>
A URI is composed from a limited set of characters consisting of
digits, letters, and a few graphic symbols.  A reserved subset of those
characters may be used to delimit syntax components within a URI while
the remaining characters, including both the unreserved set and those
reserved characters not acting as delimiters, define each component's
identifying data.

</p>
<a name="percent-encoding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Percent-Encoding</h3>

<p style='text-align: left'>
<a name='anchor33'></a>
<a name='anchor34'></a>
A percent-encoding mechanism is used to represent a data octet in a
component when that octet's corresponding character is outside
the allowed set or is being used as a delimiter of, or within, the component.
A percent-encoded octet is encoded as a character triplet, consisting of the
percent character "%" followed by the two hexadecimal digits representing
that octet's numeric value.  For example, "%20" is the percent-encoding
for the binary octet "00100000" (ABNF: %x20), which in US-ASCII corresponds
to the space character (SP). <a class='info' href='#when-to-percent-encode'>Section&nbsp;2.4<span> (</span><span class='info'>When to Encode or Decode</span><span>)</span></a>
describes when percent-encoding and decoding is applied.
<a name='anchor35'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>pct-encoded</dfn> = "<span class='str'>%</span>" <cite class='key'>HEXDIG</cite> <cite class='key'>HEXDIG</cite>
</pre></div>
<p style='text-align: left'>
The uppercase hexadecimal digits 'A' through 'F' are equivalent to the
lowercase digits 'a' through 'f', respectively.  If two URIs differ
only in the case of hexadecimal digits used in percent-encoded octets, they are
equivalent.  For consistency, URI producers and normalizers should
use uppercase hexadecimal digits for all percent-encodings.

</p>
<a name="reserved"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Reserved Characters</h3>

<p style='text-align: left'>
<a name='anchor36'></a>
URIs include components and subcomponents that are delimited by
characters in the "reserved" set.  These characters are called "reserved"
because they may (or may not) be defined as delimiters by the generic
syntax, by each scheme-specific syntax, or by the implementation-specific
syntax of a URI's dereferencing algorithm.  If data for a URI component
would conflict with a reserved character's purpose as a delimiter,
then the conflicting data must be percent-encoded before the URI is formed.
<a name='anchor37'></a>
<a name='anchor38'></a>
<a name='anchor39'></a>
<a name='anchor40'></a>
<a name='anchor41'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>reserved</dfn>    = <cite class='id'>gen-delims</cite> / <cite class='id'>sub-delims</cite>

   <dfn>gen-delims</dfn>  = "<span class='str'>:</span>" / "<span class='str'>/</span>" / "<span class='str'>?</span>" / "<span class='str'>#</span>" / "<span class='str'>[</span>" / "<span class='str'>]</span>" / "<span class='str'>@</span>"

   <dfn>sub-delims</dfn>  = "<span class='str'>!</span>" / "<span class='str'>$</span>" / "<span class='str'>&amp;</span>" / "<span class='str'>'</span>" / "<span class='str'>(</span>" / "<span class='str'>)</span>"
               / "<span class='str'>*</span>" / "<span class='str'>+</span>" / "<span class='str'>,</span>" / "<span class='str'>;</span>" / "<span class='str'>=</span>"
</pre></div>
<p>
The purpose of reserved characters is to provide a set of delimiting
characters that are distinguishable from other data within a URI.
URIs that differ in the replacement of a reserved character with its
corresponding percent-encoded octet are not
equivalent.  Percent-encoding a reserved character, or decoding a percent-encoded octet that
corresponds to a reserved character, will change how the URI is
interpreted by most applications.  Thus, characters in the reserved set
are protected from normalization and are therefore safe to be used
by scheme-specific and producer-specific algorithms for delimiting
data subcomponents within a URI.

</p>
<p>
A subset of the reserved characters (gen-delims) is used as delimiters
of the generic URI components described in <a class='info' href='#components'>Section&nbsp;3<span> (</span><span class='info'>Syntax Components</span><span>)</span></a>.
A component's ABNF syntax rule will not use the reserved or gen-delims rule
names directly; instead, each syntax rule lists the characters allowed
within that component (i.e., not delimiting it), and any of those characters
that are also in the reserved set are "reserved" for use as subcomponent
delimiters within the component.  Only the most common subcomponents are
defined by this specification; other subcomponents may be defined by a
URI scheme's specification, or by the implementation-specific syntax of
a URI's dereferencing algorithm, provided that such subcomponents are
delimited by characters in the reserved set allowed within that component.

</p>
<p>
URI producing applications should percent-encode data octets that
correspond to characters in the reserved set unless these characters are
specifically allowed by the URI scheme to represent data in that
component.  If a
reserved character is found in a URI component and no delimiting role
is known for that character, then it must be interpreted as representing
the data octet corresponding to that character's encoding in US-ASCII.

</p>
<a name="unreserved"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Unreserved Characters</h3>

<p style='text-align: left'>
<a name='anchor42'></a>
Characters that are allowed in a URI but do not have a reserved
purpose are called unreserved.  These include uppercase and lowercase
letters, decimal digits, hyphen, period, underscore, and tilde.
<a name='anchor43'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>unreserved</dfn>  = <cite class='key'>ALPHA</cite> / <cite class='key'>DIGIT</cite> / "<span class='str'>-</span>" / "<span class='str'>.</span>" / "<span class='str'>_</span>" / "<span class='str'>~</span>"
</pre></div>
<p>
URIs that differ in the replacement of an unreserved character with
its corresponding percent-encoded US-ASCII octet are equivalent:
they identify the same resource.  However, URI comparison implementations
do not always perform normalization prior to comparison (see
<a class='info' href='#comparison'>Section&nbsp;6<span> (</span><span class='info'>Normalization and Comparison</span><span>)</span></a>).
For consistency, percent-encoded octets in the ranges of
ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E),
underscore (%5F), or tilde (%7E) should not be created by URI producers
and, when found in a URI, should be decoded to their corresponding
unreserved characters by URI normalizers.

</p>
<a name="when-to-percent-encode"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
When to Encode or Decode</h3>

<p>
Under normal circumstances, the only time when octets within a
URI are percent-encoded is during the process of producing
the URI from its component parts.  This is when an
implementation determines which of the reserved characters are to be
used as subcomponent delimiters and which can be safely used as data.
Once produced, a URI is always in its percent-encoded form.

</p>
<p>
When a URI is dereferenced, the components and subcomponents significant
to the scheme-specific dereferencing process (if any) must be parsed and
separated before the percent-encoded octets within those components
can be safely decoded, as otherwise the data may be mistaken for
component delimiters.  The only exception is for percent-encoded octets
corresponding to characters in the unreserved set, which can be decoded
at any time.  For example, the octet corresponding to the tilde ("~")
character is often encoded as "%7E" by older URI processing implementations;
the "%7E" can be replaced by "~" without changing its interpretation.

</p>
<p>
Because the percent ("%") character serves as the indicator for
percent-encoded octets, it must be percent-encoded as "%25" 
for that octet to be used as data within a URI.  Implementations must not
percent-encode or decode the same string more than once, as decoding
an already decoded string might lead to misinterpreting a percent data
octet as the beginning of a percent-encoding, or vice versa in the case
of percent-encoding an already percent-encoded string.

</p>
<a name="identifying-data"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Identifying Data</h3>

<p>
URI characters provide identifying data for each of the URI components,
serving as an external interface for identification between systems.
Although the presence and nature of the URI production interface is
hidden from clients that use its URIs (and is thus beyond the scope of the
interoperability requirements defined by this specification), it is a
frequent source of confusion and errors in the interpretation of URI
character issues.  Implementers have to be aware that there are multiple
character encodings involved in the production and transmission of URIs:
local name and data encoding, public interface encoding, URI character
encoding, data format encoding, and protocol encoding.

</p>
<p>
Local names, such as file system names, are stored with a local
character encoding.  URI producing applications (e.g., origin
servers) will typically use the local encoding as the basis for
producing meaningful names.  The URI producer will transform the
local encoding to one that is suitable for a public interface and
then transform the public interface encoding into the restricted
set of URI characters (reserved, unreserved, and percent-encodings).
Those characters are, in turn, encoded as octets to be used as a
reference within a data format (e.g., a document charset), and such
data formats are often subsequently encoded for transmission over
Internet protocols.

</p>
<p>
For most systems, an unreserved character appearing within a URI
component is interpreted as representing the data octet corresponding
to that character's encoding in US-ASCII.  Consumers of URIs assume that
the letter "X" corresponds to the octet "01011000", and even when that
assumption is incorrect, there is no harm in making it.  A system that
internally provides identifiers in the form of a different character
encoding, such as EBCDIC, will generally perform character translation
of textual identifiers to UTF-8 <a class='info' href='#STD63'>[STD63]<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a> (or some other
superset of the US-ASCII character encoding) at an internal interface,
thereby providing more meaningful identifiers than those resulting from
simply percent-encoding the original octets.

</p>
<p>
For example, consider an information service that provides data,
stored locally using an EBCDIC-based file system, to clients on the
Internet through an HTTP server.  When an author creates a file with the name
"Laguna Beach" on that file system, the "http" URI corresponding to that
resource is expected to contain the
meaningful string "Laguna%20Beach".  If, however, that server produces
URIs by using an overly simplistic raw octet mapping, then the result would
be a URI containing "%D3%81%87%A4%95%81@%C2%85%81%83%88".  An internal
transcoding interface fixes this problem by transcoding the local name
to a superset of US-ASCII prior to producing the URI.  Naturally,
proper interpretation of an incoming URI on such an interface requires
that percent-encoded octets be decoded (e.g., "%20" to SP) before the
reverse transcoding is applied to obtain the local name.

</p>
<p>
In some cases, the internal interface between a URI component and the
identifying data that it has been crafted to represent is much less direct
than a character encoding translation.  For example, portions of a URI
might reflect a query on non-ASCII data, or numeric coordinates on a map.
Likewise, a URI scheme may define components with additional encoding
requirements that are applied prior to forming the component and
producing the URI.

</p>
<p>
When a new URI scheme defines a component that represents textual data
consisting of characters from the Universal Character Set <a class='info' href='#UCS'>[UCS]<span> (</span><span class='info'>International Organization for Standardization, &ldquo;Information Technology - Universal Multiple-Octet Coded Character Set (UCS),&rdquo; December&nbsp;2003.</span><span>)</span></a>,
the data should first be encoded as octets according to the
UTF-8 character encoding <a class='info' href='#STD63'>[STD63]<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a>; then only those
octets that do not correspond to characters in the unreserved set
should be percent-encoded.  For example, the character A would be
represented as "A", the character LATIN CAPITAL LETTER A WITH GRAVE
would be represented as "%C3%80", and the character KATAKANA LETTER A
would be represented as "%E3%82%A2".

</p>
<a name="components"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Syntax Components</h3>
<a name='anchor44'></a><a name='anchor45'></a><a name='anchor46'></a><a name='anchor47'></a><a name='anchor48'></a><a name='anchor49'></a><a name='anchor50'></a><a name='anchor51'></a><a name='anchor52'></a><a name='anchor53'></a><a name='anchor54'></a>
<p style='text-align: left'>
The generic URI syntax consists of a hierarchical sequence of components
referred to as the scheme, authority, path, query, and fragment.
<a name='anchor55'></a>
<a name='anchor56'></a>
<a name='anchor57'></a>
<a name='anchor58'></a>
<a name='anchor59'></a>
<a name='anchor60'></a>
<a name='anchor61'></a>
<a name='anchor62'></a>
<a name='anchor63'></a>
<a name='anchor64'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>URI</dfn>         = <cite class='id'>scheme</cite> "<span class='str'>:</span>" <cite class='id'>hier-part</cite> [ "<span class='str'>?</span>" <cite class='id'>query</cite> ] [ "<span class='str'>#</span>" <cite class='id'>fragment</cite> ]

   <dfn>hier-part</dfn>   = "<span class='str'>//</span>" <cite class='id'>authority</cite> <cite class='id'>path-abempty</cite>
               / <cite class='id'>path-absolute</cite>
               / <cite class='id'>path-rootless</cite>
               / <cite class='id'>path-empty</cite>
</pre></div>
<p style='text-align: left'>
The scheme and path components are required, though the path may be empty
(no characters).  When authority is present, the path must either be
empty or begin with a slash ("/") character. When authority is not present,
the path cannot begin with two slash characters ("//"). These restrictions
result in five different ABNF rules for a path (<a class='info' href='#path'>Section&nbsp;3.3<span> (</span><span class='info'>Path</span><span>)</span></a>),
only one of which will match any given URI reference.

</p>
<p style='text-align: left'>
The following are two example URIs and their component parts:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      foo://example.com:8042/over/there?name=ferret#nose
      \_/   \______________/\_________/ \_________/ \__/
       |           |            |            |        |
    scheme     authority       path        query   fragment
       |   _____________________|__
      / \ /                        \
      urn:example:animal:ferret:nose
</pre></div>
<a name="scheme"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Scheme</h3>
<a name='anchor65'></a>
<p>
Each URI begins with a scheme name that refers to a specification for
assigning identifiers within that scheme. As such, the URI syntax is a
federated and extensible naming system wherein each scheme's specification
may further restrict the syntax and semantics of identifiers using that
scheme.

</p>
<p style='text-align: left'>
Scheme names consist of a sequence of characters beginning with a
letter and followed by any combination of letters, digits, plus ("+"),
period ("."), or hyphen ("-").  Although schemes are case-insensitive,
the canonical form is lowercase and documents that specify schemes
must do so with lowercase letters.  An implementation should accept
uppercase letters as equivalent to lowercase in scheme names
(e.g., allow "HTTP" as well as "http") for the sake of robustness
but should only produce lowercase scheme names for consistency.
<a name='anchor66'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>scheme</dfn>      = <cite class='key'>ALPHA</cite> <span class='rep'>*</span>( <cite class='key'>ALPHA</cite> / <cite class='key'>DIGIT</cite> / "<span class='str'>+</span>" / "<span class='str'>-</span>" / "<span class='str'>.</span>" )
</pre></div>
<p style='text-align: left'>
Individual schemes are not specified by this document.
The process for registration of new URI schemes is defined separately
by <a class='info' href='#BCP35'>[BCP35]<span> (</span><span class='info'>Petke, R. and I. King, &ldquo;Registration Procedures for URL Scheme Names,&rdquo; November&nbsp;1999.</span><span>)</span></a>.  The scheme registry maintains
the mapping between scheme names and their specifications.
Advice for designers of new URI schemes can be found in
<a class='info' href='#RFC2718'>[RFC2718]<span> (</span><span class='info'>Masinter, L., Alvestrand, H., Zigmond, D., and R. Petke, &ldquo;Guidelines for new URL Schemes,&rdquo; November&nbsp;1999.</span><span>)</span></a>.
URI scheme specifications must define their own syntax so that all
strings matching their scheme-specific syntax will also match the
&lt;absolute-URI&gt; grammar, as described in <a class='info' href='#absolute-uri'>Section&nbsp;4.3<span> (</span><span class='info'>Absolute URI</span><span>)</span></a>.

</p>
<p>
When presented with a URI that violates one or more scheme-specific
restrictions, the scheme-specific resolution process should flag
the reference as an error rather than ignore the unused parts; doing so
reduces the number of equivalent URIs and helps detect abuses of the
generic syntax, which might indicate that the URI has been constructed to
mislead the user (<a class='info' href='#security-semantic'>Section&nbsp;7.6<span> (</span><span class='info'>Semantic Attacks</span><span>)</span></a>).

</p>
<a name="authority"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Authority</h3>
<a name='anchor67'></a>
<p>
Many URI schemes include a hierarchical element for a naming
authority so that governance of the name space defined by the
remainder of the URI is delegated to that authority (which may,
in turn, delegate it further).  The generic syntax provides a common
means for distinguishing an authority based on a registered name
or server address, along with optional port and user information.

</p>
<p style='text-align: left'>
The authority component is preceded by a double slash ("//") and is
terminated by the next slash ("/"), question mark ("?"), or
number sign ("#") character, or by the end of the URI.
<a name='anchor68'></a>
<a name='anchor69'></a>
<a name='anchor70'></a>
<a name='anchor71'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>authority</dfn>   = [ <cite class='id'>userinfo</cite> "<span class='str'>@</span>" ] <cite class='id'>host</cite> [ "<span class='str'>:</span>" <cite class='id'>port</cite> ]
</pre></div>
<p style='text-align: left'>
URI producers and normalizers should omit the ":" delimiter that
separates host from port if the port component is empty.
Some schemes do not allow the userinfo and/or port subcomponents.

</p>
<p>
If a URI contains an authority component, then the path component must
either be empty or begin with a slash ("/") character.  Non-validating
parsers (those that merely separate a URI reference into its major
components) will often ignore the subcomponent structure of authority,
treating it as an opaque string from the double-slash to the first
terminating delimiter, until such time as the URI is dereferenced.

</p>
<a name="userinfo"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
User Information</h3>
<a name='anchor72'></a>
<p style='text-align: left'>
The userinfo subcomponent may consist of a user name and, optionally,
scheme-specific information about how to gain authorization to access
the resource.  The user information, if present, is followed by a
commercial at-sign ("@") that delimits it from the host.
<a name='anchor73'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>userinfo</dfn>    = <span class='rep'>*</span>( <cite class='id'>unreserved</cite> / <cite class='id'>pct-encoded</cite> / <cite class='id'>sub-delims</cite> / "<span class='str'>:</span>" )
</pre></div>
<p style='text-align: left'>

</p>
<p>
Use of the format "user:password" in the userinfo field is deprecated.
Applications should not render as clear text any data after the first
colon (":") character found within a userinfo subcomponent unless the
data after the colon is the empty string (indicating no password).
Applications may choose to ignore or reject such data when it is received
as part of a reference and should reject the storage of such data
in unencrypted form.  The passing of authentication information in
clear text has proven to be a security risk in almost every case
where it has been used.

</p>
<p>
Applications that render a URI for the sake of user feedback, such
as in graphical hypertext browsing, should render userinfo in a way
that is distinguished from the rest of a URI, when feasible.  Such
rendering will assist the user in cases where the userinfo has been
misleadingly crafted to look like a trusted domain name
(<a class='info' href='#security-semantic'>Section&nbsp;7.6<span> (</span><span class='info'>Semantic Attacks</span><span>)</span></a>).

</p>
<a name="host"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Host</h3>
<a name='anchor74'></a>
<p style='text-align: left'>
The host subcomponent of authority is identified by an IP literal
encapsulated within square brackets, an IPv4 address in dotted-decimal form,
or a registered name.  The host subcomponent is case-insensitive.
The presence of a host subcomponent within a URI does not imply that
the scheme requires access to the given host on the Internet.
In many cases, the host syntax is used only for the sake of reusing the
existing registration process created and deployed for DNS, thus obtaining
a globally unique name without the cost of deploying another registry.
However, such use comes with its own costs: domain name ownership
may change over time for reasons not anticipated by the URI producer.
In other cases, the data within the host component identifies
a registered name that has nothing to do with an Internet host.
We use the name "host" for the ABNF rule because that is its most
common purpose, not its only purpose.
<a name='anchor75'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>host</dfn>        = <cite class='id'>IP-literal</cite> / <cite class='id'>IPv4address</cite> / <cite class='id'>reg-name</cite>
</pre></div>
<p style='text-align: left'>
The syntax rule for host is ambiguous because it does not completely
distinguish between an IPv4address and a reg-name.  In order to disambiguate
the syntax, we apply the "first-match-wins" algorithm: If host matches
the rule for IPv4address, then it should be considered an IPv4 address literal
and not a reg-name.  Although host is case-insensitive, producers
and normalizers should use lowercase for registered names and hexadecimal
addresses for the sake of uniformity, while only using uppercase letters
for percent-encodings.

</p>
<p style='text-align: left'>
  
  
<a name='anchor76'></a>
<a name='anchor77'></a>
<a name='anchor78'></a>
<a name='anchor79'></a>
<a name='anchor80'></a>
<a name='anchor81'></a>
A host identified by an Internet Protocol literal address, version 6
<a class='info' href='#RFC3513'>[RFC3513]<span> (</span><span class='info'>Hinden, R. and S. Deering, &ldquo;Internet Protocol Version 6 (IPv6) Addressing Architecture,&rdquo; April&nbsp;2003.</span><span>)</span></a> or later, is distinguished by enclosing the IP
literal within square brackets ("[" and "]").  This is the only place
where square bracket characters are allowed in the URI syntax.
In anticipation of future, as-yet-undefined IP literal address formats,
an implementation may use an optional version flag to indicate such a format
explicitly rather than rely on heuristic determination.
<a name='anchor82'></a>
<a name='anchor83'></a>
<a name='anchor84'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>IP-literal</dfn> = "<span class='str'>[</span>" ( <cite class='id'>IPv6address</cite> / <cite class='id'>IPvFuture</cite>  ) "<span class='str'>]</span>"

   <dfn>IPvFuture</dfn>  = "<span class='str'>v</span>" <span class='rep'>1*</span><cite class='key'>HEXDIG</cite> "<span class='str'>.</span>" <span class='rep'>1*</span>( <cite class='id'>unreserved</cite> / <cite class='id'>sub-delims</cite> / "<span class='str'>:</span>" )
</pre></div>
<p style='text-align: left'>
The version flag does not indicate the IP version; rather, it indicates
future versions of the literal format.  As such, implementations must
not provide the version flag for the existing IPv4 and IPv6 literal address forms described below.
If a URI containing an IP-literal that starts with "v" (case-insensitive),
indicating that the version flag is present, is dereferenced by an application
that does not know the meaning of that version flag, then the application
should return an appropriate error for "address mechanism not supported".

</p>
<p>
A host identified by an IPv6 literal address is represented inside
the square brackets without a preceding version flag.  The ABNF provided
here is a translation of the text definition of an IPv6 literal address
provided in <a class='info' href='#RFC3513'>[RFC3513]<span> (</span><span class='info'>Hinden, R. and S. Deering, &ldquo;Internet Protocol Version 6 (IPv6) Addressing Architecture,&rdquo; April&nbsp;2003.</span><span>)</span></a>.  This syntax does not support
IPv6 scoped addressing zone identifiers.

</p>
<p style='text-align: left'>
  
  
  
A 128-bit IPv6 address is divided into eight 16-bit pieces.
Each piece is represented numerically in case-insensitive hexadecimal,
using one to four hexadecimal digits (leading zeroes are permitted).
The eight encoded pieces are given most-significant first, separated
by colon characters.  Optionally, the least-significant two pieces
may instead be represented in IPv4 address textual format.
A sequence of one or more consecutive zero-valued 16-bit pieces within
the address may be elided, omitting all their digits and leaving exactly
two consecutive colons in their place to mark the elision.
<a name='anchor85'></a>
<a name='anchor86'></a>
<a name='anchor87'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>IPv6address</dfn> =                            <span class='rep'>6</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               /                       "<span class='str'>::</span>" <span class='rep'>5</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               / [               <cite class='id'>h16</cite> ] "<span class='str'>::</span>" <span class='rep'>4</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               / [ <span class='rep'>*1</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>" <span class='rep'>3</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               / [ <span class='rep'>*2</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>" <span class='rep'>2</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               / [ <span class='rep'>*3</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>"    <cite class='id'>h16</cite> "<span class='str'>:</span>"   <cite class='id'>ls32</cite>
               / [ <span class='rep'>*4</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>"              <cite class='id'>ls32</cite>
               / [ <span class='rep'>*5</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>"              <cite class='id'>h16</cite>
               / [ <span class='rep'>*6</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>"

   <dfn>ls32</dfn>        = ( <cite class='id'>h16</cite> "<span class='str'>:</span>" <cite class='id'>h16</cite> ) / <cite class='id'>IPv4address</cite>
               <em>; least-significant 32 bits of address</em>

   <dfn>h16</dfn>         = <span class='rep'>1*4</span><cite class='key'>HEXDIG</cite>
               <em>; 16 bits of address represented in hexadecimal</em>
</pre></div>
<p style='text-align: left'>
  
  
<a name='anchor88'></a>
<a name='anchor89'></a>
<a name='anchor90'></a>
A host identified by an IPv4 literal address is represented in
dotted-decimal notation (a sequence of four decimal numbers in the
range 0 to 255, separated by "."), as described in <a class='info' href='#RFC1123'>[RFC1123]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Application and Support,&rdquo; October&nbsp;1989.</span><span>)</span></a>
by reference to <a class='info' href='#RFC0952'>[RFC0952]<span> (</span><span class='info'>Harrenstien, K., Stahl, M., and E. Feinler, &ldquo;DoD Internet host table specification,&rdquo; October&nbsp;1985.</span><span>)</span></a>.  Note that other forms of
dotted notation may be interpreted on some platforms, as described in
<a class='info' href='#security-ipv4'>Section&nbsp;7.4<span> (</span><span class='info'>Rare IP Address Formats</span><span>)</span></a>, but only the dotted-decimal form of
four octets is allowed by this grammar.
<a name='anchor91'></a>
<a name='anchor92'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>IPv4address</dfn> = <cite class='id'>dec-octet</cite> "<span class='str'>.</span>" <cite class='id'>dec-octet</cite> "<span class='str'>.</span>" <cite class='id'>dec-octet</cite> "<span class='str'>.</span>" <cite class='id'>dec-octet</cite>

   <dfn>dec-octet</dfn>   = <cite class='key'>DIGIT</cite>                 <em>; 0-9</em>
               / <span class='val'>%x31-39</span> <cite class='key'>DIGIT</cite>         <em>; 10-99</em>
               / "<span class='str'>1</span>" <span class='rep'>2</span><cite class='key'>DIGIT</cite>            <em>; 100-199</em>
               / "<span class='str'>2</span>" <span class='val'>%x30-34</span> <cite class='key'>DIGIT</cite>     <em>; 200-249</em>
               / "<span class='str'>25</span>" <span class='val'>%x30-35</span>          <em>; 250-255</em>
</pre></div>
<p style='text-align: left'>
  
<a name='anchor93'></a>
<a name='anchor94'></a>
A host identified by a registered name is a sequence of characters
usually intended for lookup within a locally defined host or service name
registry, though the URI's scheme-specific semantics may require that a
specific registry (or fixed name table) be used instead.
The most common name registry mechanism is the Domain Name System (DNS).
A registered name intended for lookup in the DNS uses the syntax defined in
Section 3.5 of <a class='info' href='#RFC1034'>[RFC1034]<span> (</span><span class='info'>Mockapetris, P., &ldquo;Domain names - concepts and facilities,&rdquo; November&nbsp;1987.</span><span>)</span></a> and
Section 2.1 of <a class='info' href='#RFC1123'>[RFC1123]<span> (</span><span class='info'>Braden, R., &ldquo;Requirements for Internet Hosts - Application and Support,&rdquo; October&nbsp;1989.</span><span>)</span></a>.    Such a name consists of a
sequence of domain labels separated by ".", each domain label starting and
ending with an alphanumeric character and possibly also containing "-"
characters.  The rightmost domain label of a fully qualified domain name
in DNS may be followed by a single "." and should be 
if it is necessary to distinguish between the complete domain name and
some local domain.
<a name='anchor95'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>reg-name</dfn>    = <span class='rep'>*</span>( <cite class='id'>unreserved</cite> / <cite class='id'>pct-encoded</cite> / <cite class='id'>sub-delims</cite> )
</pre></div>
<p style='text-align: left'>
If the URI scheme defines a default for host, then that default applies
when the host subcomponent is undefined or when the registered name is
empty (zero length).  For example, the "file" URI scheme is defined so
that no authority, an empty host, and "localhost" all mean the end-user's
machine, whereas the "http" scheme considers a missing authority or
empty host invalid.

</p>
<p>
This specification does not mandate a particular registered name lookup
technology and therefore does not restrict the syntax of reg-name beyond
what is necessary for interoperability.  Instead, it delegates the issue of
registered name syntax conformance to the operating system of each application
performing URI resolution, and that operating system decides what it will
allow for the purpose of host identification.
A URI resolution implementation might use DNS, host tables, yellow pages,
NetInfo, WINS, or any other system for lookup of registered names.
However, a globally scoped naming system, such as
DNS fully qualified domain names, is necessary for URIs intended
to have global scope. URI producers should use names that conform to
the DNS syntax, even when use of DNS is not immediately apparent, and
should limit these names to no more than 255 characters in length.

</p>
<p>
The reg-name syntax allows percent-encoded octets in order to represent
non-ASCII registered names in a uniform way that is independent of
the underlying name resolution technology.  Non-ASCII characters must
first be encoded according to UTF-8 <a class='info' href='#STD63'>[STD63]<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a>, and then
each octet of the corresponding UTF-8 sequence must be percent-encoded
to be represented as URI characters.  URI producing applications must not
use percent-encoding in host unless it is used to represent a UTF-8
character sequence.  When a non-ASCII registered name represents an
internationalized domain name intended for resolution via the DNS,
the name must be transformed to the IDNA encoding <a class='info' href='#RFC3490'>[RFC3490]<span> (</span><span class='info'>Faltstrom, P., Hoffman, P., and A. Costello, &ldquo;Internationalizing Domain Names in Applications (IDNA),&rdquo; March&nbsp;2003.</span><span>)</span></a>
prior to name lookup.  URI producers should provide these registered names in
the IDNA encoding, rather than a percent-encoding, if they wish to maximize
interoperability with legacy URI resolvers.

</p>
<a name="port"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.3"></a><h3>3.2.3.&nbsp;
Port</h3>
<a name='anchor96'></a>
<p style='text-align: left'>
The port subcomponent of authority is designated by an optional
port number in decimal following the host and delimited from it by
a single colon (":") character.
<a name='anchor97'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>port</dfn>        = <span class='rep'>*</span><cite class='key'>DIGIT</cite>
</pre></div>
<p style='text-align: left'>
A scheme may define a default port.  For example, the "http" scheme defines
a default port of "80", corresponding to its reserved TCP port number.
The type of port designated by the port number (e.g., TCP, UDP, SCTP)
is defined by the URI scheme.  URI producers and normalizers should omit
the port component and its ":" delimiter if port is empty or if its value
would be the same as that of the scheme's default.

</p>
<a name="path"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Path</h3>
<a name='anchor98'></a><a name='anchor99'></a><a name='anchor100'></a><a name='anchor101'></a><a name='anchor102'></a><a name='anchor103'></a><a name='anchor104'></a><a name='anchor105'></a><a name='anchor106'></a><a name='anchor107'></a>
<p>
The path component contains data, usually organized in hierarchical form,
that, along with data in the non-hierarchical
<a class='info' href='#query'>query component<span> (</span><span class='info'>Query</span><span>)</span></a>,
serves to identify a resource within the scope of the URI's
scheme and naming authority (if any).
The path is terminated by the first question mark ("?") or
number sign ("#") character, or by the end of the URI.

</p>
<p style='text-align: left'>
If a URI contains an authority component, then the path component must
either be empty or begin with a slash ("/") character.
If a URI does not contain an authority component, then
the path cannot begin with two slash characters ("//").
In addition, a URI reference (<a class='info' href='#uri-reference'>Section&nbsp;4.1<span> (</span><span class='info'>URI Reference</span><span>)</span></a>) may be
a relative-path reference, in which case the first path segment cannot
contain a colon (":") character.  The ABNF requires five separate rules
to disambiguate these cases, only one of which will match the path
substring within a given URI reference.  We use the generic term
"path component" to describe the URI substring matched by the
parser to one of these rules.
<a name='anchor108'></a>
<a name='anchor109'></a>
<a name='anchor110'></a>
<a name='anchor111'></a>
<a name='anchor112'></a>
<a name='anchor113'></a>
<a name='anchor114'></a>
<a name='anchor115'></a>
<a name='anchor116'></a>
<a name='anchor117'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>path</dfn>          = <cite class='id'>path-abempty</cite>    <em>; begins with "/" or is empty</em>
                 / <cite class='id'>path-absolute</cite>   <em>; begins with "/" but not "//"</em>
                 / <cite class='id'>path-noscheme</cite>   <em>; begins with a non-colon segment</em>
                 / <cite class='id'>path-rootless</cite>   <em>; begins with a segment</em>
                 / <cite class='id'>path-empty</cite>      <em>; zero characters</em>

   <dfn>path-abempty</dfn>  = <span class='rep'>*</span>( "<span class='str'>/</span>" <cite class='id'>segment</cite> )
   <dfn>path-absolute</dfn> = "<span class='str'>/</span>" [ <cite class='id'>segment-nz</cite> <span class='rep'>*</span>( "<span class='str'>/</span>" <cite class='id'>segment</cite> ) ]
   <dfn>path-noscheme</dfn> = <cite class='id'>segment-nz-nc</cite> <span class='rep'>*</span>( "<span class='str'>/</span>" <cite class='id'>segment</cite> )
   <dfn>path-rootless</dfn> = <cite class='id'>segment-nz</cite> <span class='rep'>*</span>( "<span class='str'>/</span>" <cite class='id'>segment</cite> )
   <dfn>path-empty</dfn>    = <span class='rep'>0</span>&lt;<span class='str'>pchar</span>&gt;

   <dfn>segment</dfn>       = <span class='rep'>*</span><cite class='id'>pchar</cite>
   <dfn>segment-nz</dfn>    = <span class='rep'>1*</span><cite class='id'>pchar</cite>
   <dfn>segment-nz-nc</dfn> = <span class='rep'>1*</span>( <cite class='id'>unreserved</cite> / <cite class='id'>pct-encoded</cite> / <cite class='id'>sub-delims</cite> / "<span class='str'>@</span>" )
                 <em>; non-zero-length segment without any colon ":"</em>

   <dfn>pchar</dfn>         = <cite class='id'>unreserved</cite> / <cite class='id'>pct-encoded</cite> / <cite class='id'>sub-delims</cite> / "<span class='str'>:</span>" / "<span class='str'>@</span>"
</pre></div>
<p>
A path consists of a sequence of path segments separated by a
slash ("/") character.  A path is always defined for a URI, though
the defined path may be empty (zero length).  Use of the slash character
to indicate hierarchy is only required when a URI will be used as the
context for relative references.  For example, the URI
&lt;mailto:fred@example.com&gt; has a path of "fred@example.com", whereas
the URI &lt;foo://info.example.com?fred&gt; has an empty path.

</p><a name='anchor118'></a>
<p>
The path segments "." and "..", also known as dot-segments, are defined for
relative reference within the path name hierarchy.
They are intended for use at the beginning of a relative-path reference
(<a class='info' href='#relative-ref'>Section&nbsp;4.2<span> (</span><span class='info'>Relative Reference</span><span>)</span></a>) to indicate
relative position within the hierarchical tree of names.  This is similar
to their role within some operating systems' file directory structures to
indicate the current directory and parent directory, respectively.
However, unlike in a file system, these dot-segments are only interpreted
within the URI path hierarchy and are removed as part of the
resolution process (<a class='info' href='#absolutize'>Section&nbsp;5.2<span> (</span><span class='info'>Relative Resolution</span><span>)</span></a>).

</p>
<p>
Aside from dot-segments in hierarchical paths, a path segment is
considered opaque by the generic syntax.  URI producing applications
often use the reserved characters allowed in a segment to delimit
scheme-specific or dereference-handler-specific subcomponents.
For example, the semicolon (";") and equals ("=") reserved characters
are often used to delimit parameters and parameter values
applicable to that segment.  The comma (",") reserved character is often
used for similar purposes.  For example, one URI producer might use
a segment such as "name;v=1.1" to indicate a reference to version 1.1 of "name",
whereas another might use a segment such as "name,1.1" to indicate the same.
Parameter types may be defined by scheme-specific semantics, but in most
cases the syntax of a parameter is specific to the implementation
of the URI's dereferencing algorithm.

</p>
<a name="query"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Query</h3>

<p style='text-align: left'>
<a name='anchor119'></a>
The query component contains non-hierarchical data that, along with data
in the <a class='info' href='#path'>path component<span> (</span><span class='info'>Path</span><span>)</span></a>, serves to identify a
resource within the scope of the URI's scheme and naming authority (if any).
The query component is indicated by the first question mark ("?") character
and terminated by a number sign ("#") character or by the end of the URI.
<a name='anchor120'></a>
<a name='anchor121'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>query</dfn>       = <span class='rep'>*</span>( <cite class='id'>pchar</cite> / "<span class='str'>/</span>" / "<span class='str'>?</span>" )
</pre></div>
<p>
The characters slash ("/") and question mark ("?") may represent data
within the query component.  Beware that some older, erroneous
implementations may not handle such data correctly when it is
used as the base URI for relative references (<a class='info' href='#base-uri'>Section&nbsp;5.1<span> (</span><span class='info'>Establishing a Base URI</span><span>)</span></a>),
apparently because they fail to distinguish query data from path data
when looking for hierarchical separators.
However, as query components are often used to carry identifying information
in the form of "key=value" pairs and one frequently used value is a
reference to another URI, it is sometimes better for usability to
avoid percent-encoding those characters.

</p>
<a name="fragment"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.5"></a><h3>3.5.&nbsp;
Fragment</h3>

<p style='text-align: left'>
<a name='anchor122'></a>
The fragment identifier component of a URI allows indirect identification
of a secondary resource by reference to a primary resource and additional
identifying information.  The identified secondary resource may be some
portion or subset of the primary resource, some view on representations
of the primary resource, or some other resource defined or described by
those representations.  A fragment identifier component is indicated by
the presence of a number sign ("#") character and terminated by the end
of the URI.
<a name='anchor123'></a>
<a name='anchor124'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>fragment</dfn>    = <span class='rep'>*</span>( <cite class='id'>pchar</cite> / "<span class='str'>/</span>" / "<span class='str'>?</span>" )
</pre></div>
<p>
The semantics of a fragment identifier are defined by the set of
representations that might result from a retrieval action on the primary
resource. The fragment's format and resolution is therefore dependent on
the media type <a class='info' href='#RFC2046'>[RFC2046]<span> (</span><span class='info'>Freed, N. and N. Borenstein, &ldquo;Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types,&rdquo; November&nbsp;1996.</span><span>)</span></a> of a potentially retrieved
representation, even though such a retrieval is only performed if the URI
is dereferenced.  If no such representation exists, then the semantics of
the fragment are considered unknown and are effectively unconstrained.
Fragment identifier semantics are independent of the URI scheme and
thus cannot be redefined by scheme specifications.

</p>
<p>
Individual media types may define their own restrictions on or structures
within the fragment identifier syntax for specifying different types of
subsets, views, or external references that are identifiable as secondary
resources by that media type.  If the primary resource has multiple
representations, as is often the case for resources whose representation
is selected based on attributes of the retrieval request (a.k.a., content
negotiation), then whatever is identified by the fragment should be
consistent across all of those representations.  Each representation should
either define the fragment so that it corresponds to the same secondary
resource, regardless of how it is represented, or should leave the fragment
undefined (i.e., not found).

</p>
<p>
As with any URI, use of a fragment identifier component does not imply
that a retrieval action will take place.  A URI with a fragment identifier
may be used to refer to the secondary resource without any implication
that the primary resource is accessible or will ever be accessed.

</p>
<p>
Fragment identifiers have a special role in information retrieval systems as
the primary form of client-side indirect referencing, allowing
an author to specifically identify aspects of an existing
resource that are only indirectly provided by the resource owner.
As such, the fragment identifier is not used in the scheme-specific
processing of a URI; instead, the fragment identifier is separated
from the rest of the URI prior to a dereference, and thus the identifying
information within the fragment itself is dereferenced solely by the
user agent, regardless of the URI scheme.
Although this separate handling is often perceived to be a loss of
information, particularly for accurate redirection of references
as resources move over time, it also serves to prevent information
providers from denying reference authors the right to 
refer to information within a resource selectively.  Indirect referencing also
provides additional flexibility and extensibility to systems that use
URIs, as new media types are easier to define and deploy than
new schemes of identification.

</p>
<p>
The characters slash ("/") and question mark ("?") are allowed to
represent data within the fragment identifier.  Beware that some older,
erroneous implementations may not handle this data correctly when it is
used as the base URI for relative references (<a class='info' href='#base-uri'>Section&nbsp;5.1<span> (</span><span class='info'>Establishing a Base URI</span><span>)</span></a>).

</p>
<a name="usage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Usage</h3>

<p>
When applications make reference to a URI, they do not always use the
full form of reference defined by the "URI" syntax rule.
To save space and take advantage of hierarchical locality,
many Internet protocol elements and media type formats allow an
abbreviation of a URI, whereas others restrict the syntax to a particular
form of URI.  We define the most common forms of reference syntax in
this specification because they impact and depend upon the design of
the generic syntax, requiring a uniform parsing algorithm
in order to be interpreted consistently.

</p>
<a name="uri-reference"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
URI Reference</h3>
<a name='anchor125'></a>
<p style='text-align: left'>
URI-reference is used to denote the most common usage of a
resource identifier.
<a name='anchor126'></a>
<a name='anchor127'></a>
<a name='anchor128'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>URI-reference</dfn> = <cite class='id'>URI</cite> / <cite class='id'>relative-ref</cite>
</pre></div>
<p style='text-align: left'>
A URI-reference is either a URI or a relative reference.
If the URI-reference's prefix does not match the syntax of a scheme followed
by its colon separator, then the URI-reference is a relative reference.

</p>
<p>
A URI-reference is typically parsed first into the five URI components,
in order to determine what components are present and whether the
reference is relative.  Then, each component is parsed for
its subparts and their validation.  The ABNF of URI-reference, along with
the "first-match-wins" disambiguation rule, is sufficient to define a
validating parser for the generic syntax.  Readers familiar with
regular expressions should see <a class='info' href='#regexp'>Appendix&nbsp;B<span> (</span><span class='info'>Parsing a URI Reference with a Regular Expression</span><span>)</span></a> for an example
of a non-validating URI-reference parser that will take any given
string and extract the URI components.

</p>
<a name="relative-ref"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Relative Reference</h3>
<a name='anchor129'></a><a name='anchor130'></a><a name='anchor131'></a><a name='anchor132'></a>
<p style='text-align: left'>
A relative reference takes advantage of the hierarchical syntax
(<a class='info' href='#hierarchical'>Section&nbsp;1.2.3<span> (</span><span class='info'>Hierarchical Identifiers</span><span>)</span></a>) to express a URI reference
relative to the name space of another hierarchical URI.
<a name='anchor133'></a>
<a name='anchor134'></a>
<a name='anchor135'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>relative-ref</dfn>  = <cite class='id'>relative-part</cite> [ "<span class='str'>?</span>" <cite class='id'>query</cite> ] [ "<span class='str'>#</span>" <cite class='id'>fragment</cite> ]

   <dfn>relative-part</dfn> = "<span class='str'>//</span>" <cite class='id'>authority</cite> <cite class='id'>path-abempty</cite>
                 / <cite class='id'>path-absolute</cite>
                 / <cite class='id'>path-noscheme</cite>
                 / <cite class='id'>path-empty</cite>
</pre></div>
<p style='text-align: left'>
The URI referred to by a relative reference, also known as the target URI,
is obtained by applying
the reference resolution algorithm of <a class='info' href='#reference-resolution'>Section&nbsp;5<span> (</span><span class='info'>Reference Resolution</span><span>)</span></a>.

</p>
<p>
A relative reference that begins with two slash characters is termed a
network-path reference; such references are rarely used.
A relative reference that begins with a single slash character is
termed an absolute-path reference.  A relative reference that does not
begin with a slash character is termed a relative-path reference.

</p>
<p>
A path segment that contains a colon character (e.g., "this:that")
cannot be used as the first segment of a relative-path reference, as
it would be mistaken for a scheme name.  Such a segment must be
preceded by a dot-segment (e.g., "./this:that") to make a relative-path
reference.

</p>
<a name="absolute-uri"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Absolute URI</h3>
<a name='anchor136'></a><a name='anchor137'></a>
<p style='text-align: left'>
Some protocol elements allow only the absolute form of a URI without
a fragment identifier.  For example, defining a base URI for later
use by relative references calls for an absolute-URI syntax rule that
does not allow a fragment.
<a name='anchor138'></a>
<a name='anchor139'></a>
<a name='anchor140'></a>

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   <dfn>absolute-URI</dfn>  = <cite class='id'>scheme</cite> "<span class='str'>:</span>" <cite class='id'>hier-part</cite> [ "<span class='str'>?</span>" <cite class='id'>query</cite> ]
</pre></div>
<p style='text-align: left'>
URI scheme specifications must define their own syntax so that all
strings matching their scheme-specific syntax will also match the
&lt;absolute-URI&gt; grammar.  Scheme specifications will not define
fragment identifier syntax or usage, regardless of its
applicability to resources identifiable via that scheme, as fragment
identification is orthogonal to scheme definition.  However, scheme
specifications are encouraged to include a wide range of examples,
including examples that show use of the scheme's URIs with fragment
identifiers when such usage is appropriate.

</p>
<a name="same-document"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Same-Document Reference</h3>
<a name='anchor141'></a>
<p>
When a URI reference refers to a URI that is, aside from its fragment
component (if any), identical to the base URI (<a class='info' href='#base-uri'>Section&nbsp;5.1<span> (</span><span class='info'>Establishing a Base URI</span><span>)</span></a>),
that reference is called a "same-document" reference.  The most frequent
examples of same-document references are relative references that are empty
or include only the number sign ("#") separator followed by a fragment
identifier.

</p>
<p>
When a same-document reference is dereferenced for a
retrieval action, the target of that reference is defined to be within
the same entity (representation, document, or message) as the reference;
therefore, a dereference should not result in a new retrieval action.

</p>
<p>
Normalization of the base and target URIs prior to their comparison,
as described in Sections <a class='info' href='#normalize-syntax'>6.2.2<span> (</span><span class='info'>Syntax-Based Normalization</span><span>)</span></a> and
<a class='info' href='#normalize-scheme'>6.2.3<span> (</span><span class='info'>Scheme-Based Normalization</span><span>)</span></a>, is allowed but rarely performed
in practice.  Normalization may increase the set of same-document
references, which may be of benefit to some caching applications.
As such, reference authors should not assume that a slightly different,
though equivalent, reference URI will (or will not) be interpreted as a
same-document reference by any given application.

</p>
<a name="suffix"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Suffix Reference</h3>
<a name='anchor142'></a>
<p>
The URI syntax is designed for unambiguous reference to resources and
extensibility via the URI scheme.  However, as URI identification and
usage have become commonplace, traditional media (television, radio,
newspapers, billboards, etc.) have increasingly used a suffix of
the URI as a reference, consisting of only the authority and path
portions of the URI, such as

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   www.w3.org/Addressing/
</pre></div>
<p>
or simply a DNS registered name on its own.  Such references are primarily
intended for human interpretation rather than for machines, with the
assumption that context-based heuristics are sufficient to complete
the URI (e.g., most registered names beginning with "www" are likely to have
a URI prefix of "http://").  Although there is no standard set of
heuristics for disambiguating a URI suffix, many client implementations
allow them to be entered by the user and heuristically resolved.

</p>
<p>
Although this practice of using suffix references is common, it should
be avoided whenever possible and should never be used in situations where long-term
references are expected.  The heuristics noted above will change over time,
particularly when a new URI scheme becomes popular, and are often
incorrect when used out of context.  Furthermore, they can lead to
security issues along the lines of those described in
<a class='info' href='#RFC1535'>[RFC1535]<span> (</span><span class='info'>Gavron, E., &ldquo;A Security Problem and Proposed Correction With Widely Deployed DNS Software,&rdquo; October&nbsp;1993.</span><span>)</span></a>.

</p>
<p>
As a URI suffix has the same syntax as a relative-path reference, a
suffix reference cannot be used in contexts where a relative reference
is expected.  As a result, suffix references are limited to places where
there is no defined base URI, such as dialog boxes and off-line advertisements.

</p>
<a name="reference-resolution"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Reference Resolution</h3>
<a name='anchor143'></a><a name='anchor144'></a>
<p>
This section defines the process of resolving a URI reference within
a context that allows relative references so that the result is a
string matching the &lt;URI&gt; syntax rule of <a class='info' href='#components'>Section&nbsp;3<span> (</span><span class='info'>Syntax Components</span><span>)</span></a>.

</p>
<a name="base-uri"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Establishing a Base URI</h3>
<a name='anchor145'></a>
<p>
The term "relative" implies that a "base URI" exists against
which the relative reference is applied.  Aside from fragment-only
references (<a class='info' href='#same-document'>Section&nbsp;4.4<span> (</span><span class='info'>Same-Document Reference</span><span>)</span></a>), relative references are
only usable when a base URI is known.  A base URI must be established
by the parser prior to parsing URI references that might be relative.
A base URI must conform to the &lt;absolute-URI&gt; syntax rule
(<a class='info' href='#absolute-uri'>Section&nbsp;4.3<span> (</span><span class='info'>Absolute URI</span><span>)</span></a>).  If the base URI is obtained from a
URI reference, then that reference must be converted to absolute form
and stripped of any fragment component prior to its use as a base URI.

</p>
<p>
The base URI of a reference can be established in one of four ways,
discussed below in order of precedence.  The order of precedence can be
thought of in terms of layers, where the innermost defined base URI
has the highest precedence.  This can be visualized graphically as
follows:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   +----------------------------------------------------------+
   |  +----------------------------------------------------+  |
   |  |  +----------------------------------------------+  |  |
   |  |  |  +----------------------------------------+  |  |  |
   |  |  |  |  +----------------------------------+  |  |  |  |
   |  |  |  |  |       &lt;relative-reference&gt;       |  |  |  |  |
   |  |  |  |  +----------------------------------+  |  |  |  |
   |  |  |  | (5.1.1) Base URI embedded in content   |  |  |  |
   |  |  |  +----------------------------------------+  |  |  |
   |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |
   |  |  |         (message, representation, or none)   |  |  |
   |  |  +----------------------------------------------+  |  |
   |  | (5.1.3) URI used to retrieve the entity            |  |
   |  +----------------------------------------------------+  |
   | (5.1.4) Default Base URI (application-dependent)         |
   +----------------------------------------------------------+
</pre></div>
<a name="base-content"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Base URI Embedded in Content</h3>

<p>
Within certain media types, a base URI for relative references can
be embedded within the content itself so that it can be readily
obtained by a parser.  This can be useful for descriptive documents,
such as tables of contents, which may be transmitted to others through
protocols other than their usual retrieval context (e.g., email or
USENET news).

</p>
<p>
It is beyond the scope of this specification to specify how, for each
media type, a base URI can be embedded.  The appropriate syntax, when
available, is described by the data format specification associated
with each media type.

</p>
<a name="base-encapsulated"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.2"></a><h3>5.1.2.&nbsp;
Base URI from the Encapsulating Entity</h3>

<p>
If no base URI is embedded, the base URI is defined by the representation's
retrieval context.  For a document that is enclosed within another entity,
such as a message or archive, the retrieval context is that entity.  Thus,
the default base URI of a representation is the base URI of the entity in
which the representation is encapsulated.

</p>
<p>
A mechanism for embedding a base URI within MIME container types
(e.g., the message and multipart types) is defined by MHTML
<a class='info' href='#RFC2557'>[RFC2557]<span> (</span><span class='info'>Palme, J., Hopmann, A., and N. Shelness, &ldquo;MIME Encapsulation of Aggregate Documents, such as HTML (MHTML),&rdquo; March&nbsp;1999.</span><span>)</span></a>.  Protocols that do not use the MIME message
header syntax, but that do allow some form of tagged metadata to be included
within messages, may define their own syntax for defining a base
URI as part of a message.

</p>
<a name="base-retrieval"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.3"></a><h3>5.1.3.&nbsp;
Base URI from the Retrieval URI</h3>

<p>
If no base URI is embedded and the representation is not encapsulated
within some other entity, then, if a URI was used to retrieve the
representation, that URI shall be considered the base URI.
Note that if the retrieval was the
result of a redirected request, the last URI used (i.e., the URI that
resulted in the actual retrieval of the representation) is the base URI.

</p>
<a name="base-default"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.4"></a><h3>5.1.4.&nbsp;
Default Base URI</h3>

<p>
If none of the conditions described above apply,
then the base URI is defined by the context of the application.
As this definition is necessarily application-dependent, failing
to define a base URI by using one of the other methods may result in
the same content being interpreted differently by different types of
applications.

</p>
<p>
A sender of a representation containing relative references is responsible
for ensuring that a base URI for those references can be established.
Aside from fragment-only references, relative references can only be used
reliably in situations where the base URI is well defined.

</p>
<a name="absolutize"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Relative Resolution</h3>

<p>
This section describes an algorithm for converting a URI reference
that might be relative to a given base URI into the parsed components
of the reference's target.  The components can then be recomposed,
as described in <a class='info' href='#recomposition'>Section&nbsp;5.3<span> (</span><span class='info'>Component Recomposition</span><span>)</span></a>, to form the target URI.
This algorithm provides definitive results that can be used to test
the output of other implementations.  Applications may implement
relative reference resolution by using some other algorithm, provided that
the results match what would be given by this one.

</p>
<a name="relative-base"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Pre-parse the Base URI</h3>

<p>
The base URI (Base) is established according to the procedure of
<a class='info' href='#base-uri'>Section&nbsp;5.1<span> (</span><span class='info'>Establishing a Base URI</span><span>)</span></a> and parsed into the five main components
described in <a class='info' href='#components'>Section&nbsp;3<span> (</span><span class='info'>Syntax Components</span><span>)</span></a>.  Note that only the scheme
component is required to be present in a base URI; the other components
may be empty or undefined.  A component is undefined if its associated
delimiter does not appear in the URI reference; the path component is
never undefined, though it may be empty.

</p>
<p>
Normalization of the base URI, as described in Sections
<a class='info' href='#normalize-syntax'>6.2.2<span> (</span><span class='info'>Syntax-Based Normalization</span><span>)</span></a> and <a class='info' href='#normalize-scheme'>6.2.3<span> (</span><span class='info'>Scheme-Based Normalization</span><span>)</span></a>,
is optional.  A URI reference must be transformed to its target URI before
it can be normalized.

</p>
<a name="relative-transform"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
Transform References</h3>

<p style='text-align: left'>
For each URI reference (R), the following pseudocode describes an
algorithm for transforming R into its target URI (T):

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   -- The URI reference is parsed into the five URI components
   --
   (R.scheme, R.authority, R.path, R.query, R.fragment) = parse(R);

   -- A non-strict parser may ignore a scheme in the reference
   -- if it is identical to the base URI's scheme.
   --
   if ((not strict) and (R.scheme == Base.scheme)) then
      undefine(R.scheme);
   endif;

   if defined(R.scheme) then
      T.scheme    = R.scheme;
      T.authority = R.authority;
      T.path      = remove_dot_segments(R.path);
      T.query     = R.query;
   else
      if defined(R.authority) then
         T.authority = R.authority;
         T.path      = remove_dot_segments(R.path);
         T.query     = R.query;
      else
         if (R.path == "") then
            T.path = Base.path;
            if defined(R.query) then
               T.query = R.query;
            else
               T.query = Base.query;
            endif;
         else
            if (R.path starts-with "/") then
               T.path = remove_dot_segments(R.path);
            else
               T.path = merge(Base.path, R.path);
               T.path = remove_dot_segments(T.path);
            endif;
            T.query = R.query;
         endif;
         T.authority = Base.authority;
      endif;
      T.scheme = Base.scheme;
   endif;

   T.fragment = R.fragment;
</pre></div>
<a name="relative-merge"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
Merge Paths</h3>
<a name='anchor146'></a>
<p>
The pseudocode above refers to a "merge" routine for merging a
relative-path reference with the path of the base URI.  This is
accomplished as follows:
</p>
<ul class="text">
<li>
If the base URI has a defined authority component and an empty path,
then return a string consisting of "/" concatenated with the reference's
path; otherwise,

</li>
<li>
return a string consisting of the reference's path component appended to
all but the last segment of the base URI's path (i.e., excluding any characters
after the right-most "/" in the base URI path, or excluding the entire
base URI path if it does not contain any "/" characters).

</li>
</ul><p>

</p>
<a name="relative-dot-segments"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4"></a><h3>5.2.4.&nbsp;
Remove Dot Segments</h3>
<a name='anchor147'></a>
<p>
The pseudocode also refers to a "remove_dot_segments" routine
for interpreting and removing the special "." and ".." complete
path segments from a referenced path.  This is done after the
path is extracted from a reference, whether or not the path
was relative, in order to remove any invalid or extraneous
dot-segments prior to forming the target URI.  Although there
are many ways to accomplish this removal process, we describe a
simple method using two string buffers.
</p>
<ol class="text">
<li>
The input buffer is initialized with the now-appended path components
and the output buffer is initialized to the empty string.

</li>
<li>
While the input buffer is not empty, loop as follows:

<blockquote class="text"><dl>
<dt>A.</dt>
<dd>
If the input buffer begins with a prefix of "../" or "./", then remove
that prefix from the input buffer; otherwise,

</dd>
<dt>B.</dt>
<dd>
if the input buffer begins with a prefix of "/./" or "/.", where "." is
a complete path segment, then replace that prefix with "/" in the input
buffer; otherwise,

</dd>
<dt>C.</dt>
<dd>
if the input buffer begins with a prefix of "/../" or "/..", where ".." is
a complete path segment, then replace that prefix with "/" in the
input buffer and remove the last segment and its preceding "/" (if any)
from the output buffer; otherwise,

</dd>
<dt>D.</dt>
<dd>
if the input buffer consists only of "." or "..", then remove that from
the input buffer; otherwise,

</dd>
<dt>E.</dt>
<dd>
move the first path segment in the input buffer to the end of the output
buffer, including the initial "/" character (if any) and any subsequent
characters up to, but not including, the next "/" character or the end
of the input buffer.

</dd>
</dl></blockquote>

</li>
<li>
Finally, the output buffer is returned as the result of remove_dot_segments.

</li>
</ol><p>

</p>
<p>
Note that dot-segments are intended for use in URI references to express
an identifier relative to the hierarchy of names in the base URI.  The
remove_dot_segments algorithm respects that hierarchy by removing
extra dot-segments rather than treat them as an error or leaving
them to be misinterpreted by dereference implementations.

</p>
<p style='text-align: left'>
The following illustrates how the above steps are applied for two examples of
merged paths, showing the state of the two buffers after each step.

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   STEP   OUTPUT BUFFER         INPUT BUFFER

    1 :                         /a/b/c/./../../g
    2E:   /a                    /b/c/./../../g
    2E:   /a/b                  /c/./../../g
    2E:   /a/b/c                /./../../g
    2B:   /a/b/c                /../../g
    2C:   /a/b                  /../g
    2C:   /a                    /g
    2E:   /a/g

   STEP   OUTPUT BUFFER         INPUT BUFFER

    1 :                         mid/content=5/../6
    2E:   mid                   /content=5/../6
    2E:   mid/content=5         /../6
    2C:   mid                   /6
    2E:   mid/6
</pre></div>
<p style='text-align: left'>
Some applications may find it more efficient to implement the
remove_dot_segments algorithm by using two segment stacks rather than strings.

</p>
<p>
</p>
<blockquote class="text">
<p>
Note: Beware that some older, erroneous implementations will fail to
separate a reference's query component from its path component
prior to merging the base and reference paths, resulting in an
interoperability failure if the query component contains the
strings "/../" or "/./".

</p>
</blockquote><p>

</p>
<a name="recomposition"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Component Recomposition</h3>

<p style='text-align: left'>
Parsed URI components can be recomposed to obtain the corresponding
URI reference string.  Using pseudocode, this would be:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   result = ""

   if defined(scheme) then
      append scheme to result;
      append ":" to result;
   endif;

   if defined(authority) then
      append "//" to result;
      append authority to result;
   endif;

   append path to result;

   if defined(query) then
      append "?" to result;
      append query to result;
   endif;

   if defined(fragment) then
      append "#" to result;
      append fragment to result;
   endif;

   return result;
</pre></div>
<p style='text-align: left'>
Note that we are careful to preserve the distinction between a
component that is undefined, meaning that its separator was not
present in the reference, and a component that is empty, meaning
that the separator was present and was immediately followed by the
next component separator or the end of the reference.

</p>
<a name="reference-examples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Reference Resolution Examples</h3>

<p>
Within a representation with a well defined base URI of

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   http://a/b/c/d;p?q
</pre></div>
<p>
a relative reference is transformed to its target URI as follows.

</p>
<a name="relative-normal"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
Normal Examples</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   "g:h"           =  "g:h"
   "g"             =  "http://a/b/c/g"
   "./g"           =  "http://a/b/c/g"
   "g/"            =  "http://a/b/c/g/"
   "/g"            =  "http://a/g"
   "//g"           =  "http://g"
   "?y"            =  "http://a/b/c/d;p?y"
   "g?y"           =  "http://a/b/c/g?y"
   "#s"            =  "http://a/b/c/d;p?q#s"
   "g#s"           =  "http://a/b/c/g#s"
   "g?y#s"         =  "http://a/b/c/g?y#s"
   ";x"            =  "http://a/b/c/;x"
   "g;x"           =  "http://a/b/c/g;x"
   "g;x?y#s"       =  "http://a/b/c/g;x?y#s"
   ""              =  "http://a/b/c/d;p?q"
   "."             =  "http://a/b/c/"
   "./"            =  "http://a/b/c/"
   ".."            =  "http://a/b/"
   "../"           =  "http://a/b/"
   "../g"          =  "http://a/b/g"
   "../.."         =  "http://a/"
   "../../"        =  "http://a/"
   "../../g"       =  "http://a/g"
</pre></div>
<a name="relative-abnormal"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
Abnormal Examples</h3>

<p>
Although the following abnormal examples are unlikely to occur in
normal practice, all URI parsers should be capable of resolving them
consistently.  Each example uses the same base as that above.

</p>
<p>
Parsers must be careful in handling cases where there are more
".." segments in a relative-path reference than there are hierarchical
levels in the
base URI's path.  Note that the ".." syntax cannot be used to change
the authority component of a URI.

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   "../../../g"    =  "http://a/g"
   "../../../../g" =  "http://a/g"
</pre></div>
<p>
Similarly, parsers must remove the dot-segments "." and ".." when
they are complete components of a path, but not when they are only
part of a segment.

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   "/./g"          =  "http://a/g"
   "/../g"         =  "http://a/g"
   "g."            =  "http://a/b/c/g."
   ".g"            =  "http://a/b/c/.g"
   "g.."           =  "http://a/b/c/g.."
   "..g"           =  "http://a/b/c/..g"
</pre></div>
<p>
Less likely are cases where the relative reference uses unnecessary or
nonsensical forms of the "." and ".." complete path segments.

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   "./../g"        =  "http://a/b/g"
   "./g/."         =  "http://a/b/c/g/"
   "g/./h"         =  "http://a/b/c/g/h"
   "g/../h"        =  "http://a/b/c/h"
   "g;x=1/./y"     =  "http://a/b/c/g;x=1/y"
   "g;x=1/../y"    =  "http://a/b/c/y"
</pre></div>
<p>
Some applications fail to separate the reference's query and/or
fragment components from the path component before merging it with
the base path and removing dot-segments.  This error is rarely noticed,
as typical usage of a fragment never includes the hierarchy ("/")
character and the query component is not normally used within
relative references.

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   "g?y/./x"       =  "http://a/b/c/g?y/./x"
   "g?y/../x"      =  "http://a/b/c/g?y/../x"
   "g#s/./x"       =  "http://a/b/c/g#s/./x"
   "g#s/../x"      =  "http://a/b/c/g#s/../x"
</pre></div>
<p>
Some parsers allow the scheme name to be present in a relative reference if
it is the same as the base URI scheme.  This is considered to be a
loophole in prior specifications of partial URI <a class='info' href='#RFC1630'>[RFC1630]<span> (</span><span class='info'>Berners-Lee, T., &ldquo;Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web,&rdquo; June&nbsp;1994.</span><span>)</span></a>.
Its use should be avoided but is allowed for backward compatibility.

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   "http:g"        =  "http:g"         ; for strict parsers
                   /  "http://a/b/c/g" ; for backward compatibility
</pre></div>
<a name="comparison"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Normalization and Comparison</h3>

<p>
One of the most common operations on URIs is simple comparison:
determining whether two URIs are equivalent without using the URIs to
access their respective resource(s).  A comparison is performed
every time a response cache is accessed, a browser checks its
history to color a link, or an XML parser processes tags within a namespace.
Extensive normalization prior to comparison of URIs is often used
by spiders and indexing engines to prune a search space or to
reduce duplication of request actions and response storage.

</p>
<p>
URI comparison is performed for some particular purpose.  Protocols or
implementations that compare URIs for different purposes will often be subject to differing
design trade-offs in regards to how much effort should be spent in
reducing aliased identifiers.  This section describes various
methods that may be used to compare URIs, the trade-offs between them,
and the types of applications that might use them.

</p>
<a name="equivalence"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Equivalence</h3>

<p>
Because URIs exist to identify resources, presumably they should be
considered equivalent when they identify the same resource.  However,
this definition of equivalence is not of much practical use, as
there is no way for an implementation to compare two resources unless
it has full knowledge or control of them.  For this reason, determination of
equivalence or difference of URIs is based on string comparison,
perhaps augmented by reference to additional rules provided by URI
scheme definitions.
We use the terms "different" and "equivalent" to describe
the possible outcomes of such comparisons, but there
are many application-dependent versions of equivalence.

</p>
<p>
Even though it is possible to determine that two URIs are equivalent,
URI comparison is not sufficient to determine whether two URIs identify different
resources. For example, an owner of two different domain names could
decide to serve the same resource from both, resulting in two different
URIs.  Therefore, comparison methods are designed to minimize
false negatives while strictly avoiding false positives.

</p>
<p>
In testing for equivalence, applications should not directly compare
relative references; the references should be converted to their
respective target URIs before comparison.  When URIs are compared
to select (or avoid) a network action, such as
retrieval of a representation, fragment components (if any) should
be excluded from the comparison.

</p>
<a name="comparison-ladder"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Comparison Ladder</h3>

<p>
A variety of methods are used in practice to test URI equivalence.
These methods fall into a range, distinguished by the amount of
processing required and the degree to which the probability of false
negatives is reduced.  As noted above, false negatives cannot
be eliminated.  In practice, their probability can be reduced,
but this reduction requires more processing and is not cost-effective
for all applications.

</p>
<p>
If this range of comparison practices is considered as a ladder, the
following discussion will climb the ladder, starting with practices that
are cheap but have a relatively higher chance of producing false negatives,
and proceeding to those that have higher computational cost and lower risk
of false negatives.

</p>
<a name="comparison-string"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
Simple String Comparison</h3>

<p>
If two URIs, when considered as character strings, are identical, then it is
safe to conclude that they are equivalent.  This type of equivalence test
has very low computational cost and is in wide use in a variety of
applications, particularly in the domain of parsing.

</p>
<p>
Testing strings for equivalence requires some basic precautions.
This procedure is often referred to as "bit-for-bit" or "byte-for-byte"
comparison, which is potentially misleading.  Testing strings for
equality is normally based on pair comparison of the characters
that make up the strings, starting from the first and proceeding until
both strings are exhausted and all characters are found to be equal, until a
pair of characters compares unequal, or until one of the strings is exhausted
before the other.

</p>
<p>
This character comparison requires that each pair of characters be put
in comparable form.  For example, should one URI be stored in a byte
array in EBCDIC encoding and the second in a Java String object (UTF-16),
bit-for-bit comparisons applied naively will produce errors.
It is better to speak of equality on a character-for-character basis rather
than on a byte-for-byte or bit-for-bit basis.
In practical terms, character-by-character comparisons should be done
codepoint-by-codepoint after conversion to a common character encoding.

</p>
<p>
False negatives are caused by the production and use of URI aliases.
Unnecessary aliases can be reduced, regardless of the comparison method,
by consistently providing URI references in an already-normalized form
(i.e., a form identical to what would be produced after normalization
is applied, as described below).

</p>
<p>
Protocols and data formats often limit some URI comparisons to simple string comparison, based
on the theory that people and implementations will, in their own best interest,
be consistent in providing URI references, or at least consistent enough
to negate any efficiency that might be obtained from further normalization.

</p>
<a name="normalize-syntax"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
Syntax-Based Normalization</h3>

<p style='text-align: left'>
Implementations may use logic based on the definitions provided by this
specification to reduce the probability of false negatives.  This
processing is moderately higher in cost than character-for-character
string comparison.  For example, an application using this approach
could reasonably consider the following two URIs equivalent:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   example://a/b/c/%7Bfoo%7D
   eXAMPLE://a/./b/../b/%63/%7bfoo%7d
</pre></div>
<p style='text-align: left'>
Web user agents, such as browsers, typically apply this type of URI
normalization when determining whether a cached response is available.
Syntax-based normalization includes such techniques as case normalization,
percent-encoding normalization, and removal of dot-segments.

</p>
<a name="normalize-case"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2.1"></a><h3>6.2.2.1.&nbsp;
Case Normalization</h3>

<p>
For all URIs, the hexadecimal digits within a percent-encoding triplet
(e.g., "%3a" versus "%3A") are case-insensitive and therefore should be
normalized to use uppercase letters for the digits A-F.

</p>
<p>
When a URI uses components of the generic syntax, the component syntax
equivalence rules always apply; namely, that the scheme and host are
case-insensitive and therefore should be normalized to lowercase.
For example, the URI &lt;HTTP://www.EXAMPLE.com/&gt; is
equivalent to &lt;http://www.example.com/&gt;.
The other generic syntax components are assumed to be case-sensitive
unless specifically defined otherwise by the scheme
(see <a class='info' href='#normalize-scheme'>Section&nbsp;6.2.3<span> (</span><span class='info'>Scheme-Based Normalization</span><span>)</span></a>).

</p>
<a name="normalize-encoding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2.2"></a><h3>6.2.2.2.&nbsp;
Percent-Encoding Normalization</h3>

<p>
The percent-encoding mechanism (<a class='info' href='#percent-encoding'>Section&nbsp;2.1<span> (</span><span class='info'>Percent-Encoding</span><span>)</span></a>)
is a frequent source of variance among otherwise identical URIs.
In addition to the case normalization issue noted above, some URI
producers percent-encode octets that do not require percent-encoding,
resulting in URIs that are equivalent to their non-encoded counterparts.
These URIs should be normalized by decoding any percent-encoded octet
that corresponds to an unreserved character, as described in
<a class='info' href='#unreserved'>Section&nbsp;2.3<span> (</span><span class='info'>Unreserved Characters</span><span>)</span></a>.

</p>
<a name="normalize-path"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2.3"></a><h3>6.2.2.3.&nbsp;
Path Segment Normalization</h3>

<p>
The complete path segments "." and ".." are intended only for use
within relative references (<a class='info' href='#uri-reference'>Section&nbsp;4.1<span> (</span><span class='info'>URI Reference</span><span>)</span></a>) and are
removed as part of the reference resolution process
(<a class='info' href='#absolutize'>Section&nbsp;5.2<span> (</span><span class='info'>Relative Resolution</span><span>)</span></a>).
However, some deployed implementations incorrectly assume that reference
resolution is not necessary when the reference is already a URI and thus
fail to remove dot-segments when they occur in non-relative paths.
URI normalizers should remove dot-segments by applying the
remove_dot_segments algorithm to the path, as described in 
<a class='info' href='#relative-dot-segments'>Section&nbsp;5.2.4<span> (</span><span class='info'>Remove Dot Segments</span><span>)</span></a>.

</p>
<a name="normalize-scheme"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.3"></a><h3>6.2.3.&nbsp;
Scheme-Based Normalization</h3>

<p style='text-align: left'>
The syntax and semantics of URIs vary from scheme to scheme, as described
by the defining specification for each scheme.  Implementations may use
scheme-specific rules, at further processing cost, to reduce the
probability of false negatives.  For example, because the "http" scheme
makes use of an authority component, has a default port of "80", and
defines an empty path to be equivalent to "/", the following four URIs
are equivalent:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   http://example.com
   http://example.com/
   http://example.com:/
   http://example.com:80/
</pre></div>
<p style='text-align: left'>
In general, a URI that uses the generic syntax for authority with an
empty path should be normalized to a path of "/".  Likewise, an explicit
":port", for which the port is empty or the default for the scheme, is
equivalent to one where the port and its ":" delimiter are elided and
thus should be removed by scheme-based normalization.  For example, the
second URI above is the normal form for the "http" scheme.

</p>
<p>
Another case where normalization varies by scheme is in the handling
of an empty authority component or empty host subcomponent.  For many
scheme specifications, an empty authority or host is considered an error;
for others, it is considered equivalent to "localhost" or the end-user's host.
When a scheme defines a default for authority and a URI reference to
that default is desired, the reference should be normalized to an empty
authority for the sake of uniformity, brevity, and internationalization.
If, however, either the userinfo or port subcomponents are non-empty,
then the host should be given explicitly even if it matches the default.

</p>
<p>
Normalization should not remove delimiters when their associated
component is empty unless licensed to do so by the scheme specification.
For example, the URI "http://example.com/?" cannot be assumed to be
equivalent to any of the examples above.  Likewise, the presence or
absence of delimiters within a userinfo subcomponent is usually
significant to its interpretation.  The fragment component is not
subject to any scheme-based normalization; thus, two URIs that differ only
by the suffix "#" are considered different regardless of the scheme.

</p>
<p>
Some schemes define additional subcomponents that consist of
case-insensitive data, giving an implicit license to normalizers
to convert this data to a common case (e.g., all lowercase).
For example, URI schemes that define a subcomponent of path to
contain an Internet hostname, such as the "mailto" URI scheme,
cause that subcomponent to be case-insensitive and thus subject
to case normalization (e.g., "mailto:Joe@Example.COM" is equivalent
to "mailto:Joe@example.com", even though the generic syntax considers
the path component to be case-sensitive).

</p>
<p>
Other scheme-specific normalizations are possible.

</p>
<a name="normalize-protocol"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.4"></a><h3>6.2.4.&nbsp;
Protocol-Based Normalization</h3>

<p style='text-align: left'>
Substantial effort to reduce the incidence of false negatives is
often cost-effective for web spiders.  Therefore, they implement even
more aggressive techniques in URI comparison. For example, if they
observe that a URI such as

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   http://example.com/data
</pre></div>
<p style='text-align: left'>
redirects to a URI differing only in the trailing slash

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   http://example.com/data/
</pre></div>
<p style='text-align: left'>
they will likely regard the two as equivalent in the future.
This kind of technique is only appropriate when equivalence is clearly
indicated by both the result of accessing the resources and the common
conventions of their scheme's dereference algorithm (in this case,
use of redirection by HTTP origin servers to avoid problems with
relative references).

</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>
A URI does not in itself pose a security threat.  However, as URIs
are often used to provide a compact set of instructions for access to
network resources, care must be taken to properly interpret the data
within a URI, to prevent that data from causing unintended access, and
to avoid including data that should not be revealed in plain text.

</p>
<a name="security-reliability"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Reliability and Consistency</h3>

<p>
There is no guarantee that once a URI has been used to retrieve
information, the same information will be retrievable by
that URI in the future. Nor is there any guarantee that the information
retrievable via that URI in the future will be observably similar to
that retrieved in the past.  The URI syntax does not constrain how a
given scheme or authority apportions its namespace or maintains it
over time.  Such guarantees can only be obtained from the person(s)
controlling that namespace and the resource in question.  A specific
URI scheme may define additional semantics, such as name persistence,
if those semantics are required of all naming authorities for that scheme.

</p>
<a name="security-malicious"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Malicious Construction</h3>

<p>
It is sometimes possible to construct a URI so that an attempt to
perform a seemingly harmless, idempotent operation, such as the
retrieval of a representation, will in fact cause a possibly damaging
remote operation.  The unsafe URI is typically constructed by
specifying a port number other than that reserved for the network protocol
in question.  The client unwittingly contacts a site running a
different protocol service, and data within the URI contains instructions
that, when interpreted according to this other protocol, cause an
unexpected operation.  A frequent example of such abuse has been the use
of a protocol-based scheme with a port component of "25", thereby fooling
user agent software into sending an unintended or impersonating message
via an SMTP server.

</p>
<p>
Applications should prevent dereference of a URI that specifies a
TCP port number within the "well-known port" range (0 - 1023) unless
the protocol being used to dereference that URI is compatible with the
protocol expected on that well-known port. Although IANA maintains a
registry of well-known ports, applications should make such restrictions
user-configurable to avoid preventing the deployment of new services.

</p>
<p>
When a URI contains percent-encoded octets that match the delimiters for
a given resolution or dereference protocol (for example, CR and LF characters
for the TELNET protocol), these percent-encodings must not be decoded
before transmission across that protocol.  Transfer of the percent-encoding,
which might violate the protocol, is less harmful than allowing decoded
octets to be interpreted as additional operations or parameters, perhaps
triggering an unexpected and possibly harmful remote operation.

</p>
<a name="security-transcoding"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Back-End Transcoding</h3>

<p>
When a URI is dereferenced, the data within it is often parsed by both
the user agent and one or more servers.  In HTTP, for example, a typical
user agent will parse a URI into its five major components, access the
authority's server, and send it the data within the authority, path, and
query components.  A typical server will take that information, parse
the path into segments and the query into key/value pairs, and then
invoke implementation-specific handlers to respond to the request.
As a result, a common security concern for server implementations that
handle a URI, either as a whole or split into separate components,
is proper interpretation of the octet data represented by the characters
and percent-encodings within that URI.

</p>
<p>
Percent-encoded octets must be decoded at some point during the
dereference process.  Applications must split the URI into its
components and subcomponents prior to decoding the octets, as
otherwise the decoded octets might be mistaken for delimiters.  Security
checks of the data within a URI should be applied after decoding the
octets.  Note, however, that the "%00" percent-encoding (NUL) may require
special handling and should be rejected if the application is not expecting
to receive raw data within a component.

</p>
<p>
Special care should be taken when the URI path interpretation process
involves the use of a back-end file system or related system functions.
File systems typically assign an operational meaning to special characters,
such as the "/", "\", ":", "[", and "]" characters, and to
special device names like ".", "..", "...", "aux", "lpt", etc.
In some cases, merely testing for the existence of such a name will
cause the operating system to pause or invoke unrelated system calls,
leading to significant security concerns regarding denial of service
and unintended data transfer.  It would be impossible for this specification
to list all such significant characters and device names.  Implementers
should research the reserved names and characters for the types of
storage device that may be attached to their applications and restrict
the use of data obtained from URI components accordingly.

</p>
<a name="security-ipv4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;
Rare IP Address Formats</h3>

<p>
Although the URI syntax for IPv4address only allows the common
dotted-decimal form of IPv4 address literal, many implementations that
process URIs make use of platform-dependent system routines, such as
gethostbyname() and inet_aton(), to translate the string literal to an
actual IP address.  Unfortunately, such system routines often allow and
process a much larger set of formats than those described in
<a class='info' href='#host'>Section&nbsp;3.2.2<span> (</span><span class='info'>Host</span><span>)</span></a>.

</p>
<p>
For example, many implementations allow dotted forms of three numbers,
wherein the last part is interpreted as a 16-bit quantity and placed in
the right-most two bytes of the network address (e.g., a Class B network).
Likewise, a dotted form of two numbers means that the last part is interpreted
as a 24-bit quantity and placed in the right-most three bytes of the network
address (Class A), and a single number (without dots) is interpreted as
a 32-bit quantity and stored directly in the network address.  Adding
further to the confusion, some implementations allow each dotted part
to be interpreted as decimal, octal, or hexadecimal, as specified in
the C language (i.e., a leading 0x or 0X implies hexadecimal;
a leading 0 implies octal; otherwise, the number is interpreted as decimal).

</p>
<p>
These additional IP address formats are not allowed in the URI syntax
due to differences between platform implementations.  However, they
can become a security concern if an application attempts to filter
access to resources based on the IP address in string literal format.
If this filtering is performed, literals should be converted to numeric
form and filtered based on the numeric value, and not on a prefix or
suffix of the string form.

</p>
<a name="security-sensitive"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5"></a><h3>7.5.&nbsp;
Sensitive Information</h3>

<p>
URI producers should not provide a URI that contains a username or
password that is intended to be secret.  URIs are frequently
displayed by browsers, stored in clear text bookmarks, and logged
by user agent history and intermediary applications (proxies).
A password appearing within the userinfo component is deprecated and
should be considered an error (or simply ignored) except in those
rare cases where the 'password' parameter is intended to be public.

</p>
<a name="security-semantic"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.6"></a><h3>7.6.&nbsp;
Semantic Attacks</h3>

<p style='text-align: left'>
Because the userinfo subcomponent is rarely used and appears before the
host in the authority component, it can be used to construct a URI
intended to mislead a human user by appearing to identify one
(trusted) naming authority while actually identifying a different
authority hidden behind the noise.  For example

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   ftp://cnn.example.com&amp;story=breaking_news@10.0.0.1/top_story.htm
</pre></div>
<p style='text-align: left'>
might lead a human user to assume that the host is 'cnn.example.com',
whereas it is actually '10.0.0.1'.  Note that a misleading userinfo
subcomponent could be much longer than the example above.

</p>
<p>
A misleading URI, such as that above, is an attack on the user's
preconceived notions about the meaning of a URI rather than an attack
on the software itself.  User agents may be able to reduce the impact
of such attacks by distinguishing the various components of
the URI when they are rendered, such as by using a different color or tone to
render userinfo if any is present, though there is no panacea.
More information on URI-based semantic attacks can be found in
<a class='info' href='#Siedzik'>[Siedzik]<span> (</span><span class='info'>Siedzik, R., &ldquo;Semantic Attacks: What's in a URL?,&rdquo; April&nbsp;2001.</span><span>)</span></a>.

</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>
URI scheme names, as defined by &lt;scheme&gt; in <a class='info' href='#scheme'>Section&nbsp;3.1<span> (</span><span class='info'>Scheme</span><span>)</span></a>,
form a registered namespace that is managed by IANA according to the
procedures defined in <a class='info' href='#BCP35'>[BCP35]<span> (</span><span class='info'>Petke, R. and I. King, &ldquo;Registration Procedures for URL Scheme Names,&rdquo; November&nbsp;1999.</span><span>)</span></a>.
No IANA actions are required by this document.

</p>
<a name="ack"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>
This specification is derived from RFC 2396 <a class='info' href='#RFC2396'>[RFC2396]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifiers (URI): Generic Syntax,&rdquo; August&nbsp;1998.</span><span>)</span></a>,
RFC 1808 <a class='info' href='#RFC1808'>[RFC1808]<span> (</span><span class='info'>Fielding, R., &ldquo;Relative Uniform Resource Locators,&rdquo; June&nbsp;1995.</span><span>)</span></a>, and RFC 1738 <a class='info' href='#RFC1738'>[RFC1738]<span> (</span><span class='info'>Berners-Lee, T., Masinter, L., and M. McCahill, &ldquo;Uniform Resource Locators (URL),&rdquo; December&nbsp;1994.</span><span>)</span></a>;
the acknowledgements in those documents still apply.
It also incorporates the update (with corrections) for IPv6 literals
in the host syntax, as defined by Robert M. Hinden, Brian E. Carpenter,
and Larry Masinter in <a class='info' href='#RFC2732'>[RFC2732]<span> (</span><span class='info'>Hinden, R., Carpenter, B., and L. Masinter, &ldquo;Format for Literal IPv6 Addresses in URL's,&rdquo; December&nbsp;1999.</span><span>)</span></a>.
In addition, contributions by Gisle Aas, Reese Anschultz,
Daniel Barclay, Tim Bray, Mike Brown,
Rob Cameron, Jeremy Carroll, Dan Connolly, Adam M. Costello, John Cowan,
Jason Diamond, Martin Duerst, Stefan Eissing, Clive D.W. Feather, Al Gilman,
Tony Hammond, Elliotte Harold, Pat Hayes, Henry Holtzman, Ian B. Jacobs,
Michael Kay, John C. Klensin, Graham Klyne, Dan Kohn, Bruce Lilly,
Andrew Main, Dave McAlpin, Ira McDonald, Michael Mealling, Ray Merkert,
Stephen Pollei, Julian Reschke, Tomas Rokicki, Miles Sabin, Kai Schaetzl,
Mark Thomson, Ronald Tschalaer,
Norm Walsh, Marc Warne, Stuart Williams, and Henry Zongaro
are gratefully acknowledged.

</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="ASCII">[ASCII]</a></td>
<td class="author-text">American National Standards Institute, &ldquo;Coded Character Set -- 7-bit American Standard Code for Information Interchange,&rdquo; ANSI&nbsp;X3.4, 1986.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2234">[RFC2234]</a></td>
<td class="author-text"><a href="mailto:dcrocker@imc.org">Crocker, D.</a> and <a href="mailto:paulo@turnpike.com">P. Overell</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2234">Augmented BNF for Syntax Specifications: ABNF</a>,&rdquo; RFC&nbsp;2234, November&nbsp;1997 (<a href="http://www.ietf.org/rfc/rfc2234.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="STD63">[STD63]</a></td>
<td class="author-text"><a href="mailto:fyergeau@alis.com">Yergeau, F.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003 (<a href="http://www.ietf.org/rfc/rfc3629.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="UCS">[UCS]</a></td>
<td class="author-text">International Organization for Standardization, &ldquo;Information Technology - Universal Multiple-Octet Coded Character Set (UCS),&rdquo; ISO/IEC&nbsp;10646:2003, December&nbsp;2003.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="BCP19">[BCP19]</a></td>
<td class="author-text">Freed, N. and J. Postel, &ldquo;<a href="http://tools.ietf.org/html/rfc2978">IANA Charset Registration Procedures</a>,&rdquo; BCP&nbsp;19, RFC&nbsp;2978, October&nbsp;2000 (<a href="http://www.ietf.org/rfc/rfc2978.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="BCP35">[BCP35]</a></td>
<td class="author-text"><a href="mailto:rpetke@wcom.net">Petke, R.</a> and <a href="mailto:iking@microsoft.com">I. King</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2717">Registration Procedures for URL Scheme Names</a>,&rdquo; BCP&nbsp;35, RFC&nbsp;2717, November&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC0952">[RFC0952]</a></td>
<td class="author-text">Harrenstien, K., Stahl, M., and E. Feinler, &ldquo;<a href="http://tools.ietf.org/html/rfc952">DoD Internet host table specification</a>,&rdquo; RFC&nbsp;952, October&nbsp;1985 (<a href="http://www.ietf.org/rfc/rfc952.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1034">[RFC1034]</a></td>
<td class="author-text">Mockapetris, P., &ldquo;<a href="http://tools.ietf.org/html/rfc1034">Domain names - concepts and facilities</a>,&rdquo; STD&nbsp;13, RFC&nbsp;1034, November&nbsp;1987.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1123">[RFC1123]</a></td>
<td class="author-text"><a href="mailto:Braden@ISI.EDU">Braden, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1123">Requirements for Internet Hosts - Application and Support</a>,&rdquo; STD&nbsp;3, RFC&nbsp;1123, October&nbsp;1989.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1535">[RFC1535]</a></td>
<td class="author-text"><a href="mailto:gavron@aces.com">Gavron, E.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1535">A Security Problem and Proposed Correction With Widely Deployed DNS Software</a>,&rdquo; RFC&nbsp;1535, October&nbsp;1993 (<a href="http://www.ietf.org/rfc/rfc1535.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1630">[RFC1630]</a></td>
<td class="author-text"><a href="mailto:timbl@info.cern.ch">Berners-Lee, T.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1630">Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web</a>,&rdquo; RFC&nbsp;1630, June&nbsp;1994.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1736">[RFC1736]</a></td>
<td class="author-text"><a href="mailto:jak@violet.berkeley.edu">Kunze, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1736">Functional Recommendations for Internet Resource Locators</a>,&rdquo; RFC&nbsp;1736, February&nbsp;1995.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1737">[RFC1737]</a></td>
<td class="author-text"><a href="mailto:sollins@lcs.mit.edu">Sollins, K.</a> and <a href="mailto:masinter@parc.xerox.com">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1737">Functional Requirements for Uniform Resource Names</a>,&rdquo; RFC&nbsp;1737, December&nbsp;1994.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1738">[RFC1738]</a></td>
<td class="author-text"><a href="mailto:timbl@info.cern.ch">Berners-Lee, T.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, and <a href="mailto:mpm@boombox.micro.umn.edu">M. McCahill</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1738">Uniform Resource Locators (URL)</a>,&rdquo; RFC&nbsp;1738, December&nbsp;1994.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1808">[RFC1808]</a></td>
<td class="author-text"><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1808">Relative Uniform Resource Locators</a>,&rdquo; RFC&nbsp;1808, June&nbsp;1995.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2046">[RFC2046]</a></td>
<td class="author-text"><a href="mailto:ned@innosoft.com">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com">N. Borenstein</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>,&rdquo; RFC&nbsp;2046, November&nbsp;1996.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2141">[RFC2141]</a></td>
<td class="author-text"><a href="mailto:jayhawk@ds.internic.net">Moats, R.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2141">URN Syntax</a>,&rdquo; RFC&nbsp;2141, May&nbsp;1997 (<a href="http://www.ietf.org/rfc/rfc2141.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2141.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2141.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2396">[RFC2396]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, and <a href="mailto:masinter@parc.xerox.com">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2396">Uniform Resource Identifiers (URI): Generic Syntax</a>,&rdquo; RFC&nbsp;2396, August&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2518">[RFC2518]</a></td>
<td class="author-text"><a href="mailto:yarong@microsoft.com">Goland, Y.</a>, <a href="mailto:ejw@ics.uci.edu">Whitehead, E.</a>, <a href="mailto:asad@netscape.com">Faizi, A.</a>, <a href="mailto:srcarter@novell.com">Carter, S.</a>, and <a href="mailto:dcjensen@novell.com">D. Jensen</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2518">HTTP Extensions for Distributed Authoring -- WEBDAV</a>,&rdquo; RFC&nbsp;2518, February&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2557">[RFC2557]</a></td>
<td class="author-text"><a href="mailto:jpalme@dsv.su.se">Palme, J.</a>, <a href="mailto:alexhop@microsoft.com">Hopmann, A.</a>, and <a href="mailto:Shelness@lotus.com">N. Shelness</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2557">MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)</a>,&rdquo; RFC&nbsp;2557, March&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2718">[RFC2718]</a></td>
<td class="author-text"><a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:harald.alvestrand@maxware.no">Alvestrand, H.</a>, <a href="mailto:djz@corp.webtv.net">Zigmond, D.</a>, and <a href="mailto:rpetke@wcom.net">R. Petke</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2718">Guidelines for new URL Schemes</a>,&rdquo; RFC&nbsp;2718, November&nbsp;1999 (<a href="http://www.ietf.org/rfc/rfc2718.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2732">[RFC2732]</a></td>
<td class="author-text"><a href="mailto:hinden@iprg.nokia.com">Hinden, R.</a>, <a href="mailto:brian@icair.org">Carpenter, B.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2732">Format for Literal IPv6 Addresses in URL's</a>,&rdquo; RFC&nbsp;2732, December&nbsp;1999 (<a href="http://www.ietf.org/rfc/rfc2732.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3305">[RFC3305]</a></td>
<td class="author-text">Mealling, M. and R. Denenberg, &ldquo;<a href="http://tools.ietf.org/html/rfc3305">Report from the Joint W3C/IETF URI Planning Interest Group: Uniform Resource Identifiers (URIs), URLs, and Uniform Resource Names (URNs): Clarifications and Recommendations</a>,&rdquo; RFC&nbsp;3305, August&nbsp;2002 (<a href="http://www.ietf.org/rfc/rfc3305.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3490">[RFC3490]</a></td>
<td class="author-text">Faltstrom, P., Hoffman, P., and A. Costello, &ldquo;<a href="http://tools.ietf.org/html/rfc3490">Internationalizing Domain Names in Applications (IDNA)</a>,&rdquo; RFC&nbsp;3490, March&nbsp;2003 (<a href="http://www.ietf.org/rfc/rfc3490.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3513">[RFC3513]</a></td>
<td class="author-text"><a href="mailto:hinden@iprg.nokia.com">Hinden, R.</a> and <a href="mailto:deering@cisco.com">S. Deering</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3513">Internet Protocol Version 6 (IPv6) Addressing Architecture</a>,&rdquo; RFC&nbsp;3513, April&nbsp;2003 (<a href="http://www.ietf.org/rfc/rfc3513.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="Siedzik">[Siedzik]</a></td>
<td class="author-text">Siedzik, R., &ldquo;<a href="http://www.giac.org/practical/gsec/Richard_Siedzik_GSEC.pdf">Semantic Attacks: What's in a URL?</a>,&rdquo; April&nbsp;2001 (<a href="http://www.giac.org/practical/gsec/Richard_Siedzik_GSEC.pdf">PDF</a>).</td></tr>
</table>

<a name="collected-abnf"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
Collected ABNF for URI</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 <dfn>URI</dfn>           = <cite class='id'>scheme</cite> "<span class='str'>:</span>" <cite class='id'>hier-part</cite> [ "<span class='str'>?</span>" <cite class='id'>query</cite> ] [ "<span class='str'>#</span>" <cite class='id'>fragment</cite> ]

 <dfn>hier-part</dfn>     = "<span class='str'>//</span>" <cite class='id'>authority</cite> <cite class='id'>path-abempty</cite>
               / <cite class='id'>path-absolute</cite>
               / <cite class='id'>path-rootless</cite>
               / <cite class='id'>path-empty</cite>

 <dfn>URI-reference</dfn> = <cite class='id'>URI</cite> / <cite class='id'>relative-ref</cite>

 <dfn>absolute-URI</dfn>  = <cite class='id'>scheme</cite> "<span class='str'>:</span>" <cite class='id'>hier-part</cite> [ "<span class='str'>?</span>" <cite class='id'>query</cite> ]

 <dfn>relative-ref</dfn>  = <cite class='id'>relative-part</cite> [ "<span class='str'>?</span>" <cite class='id'>query</cite> ] [ "<span class='str'>#</span>" <cite class='id'>fragment</cite> ]

 <dfn>relative-part</dfn> = "<span class='str'>//</span>" <cite class='id'>authority</cite> <cite class='id'>path-abempty</cite>
               / <cite class='id'>path-absolute</cite>
               / <cite class='id'>path-noscheme</cite>
               / <cite class='id'>path-empty</cite>

 <dfn>scheme</dfn>        = <cite class='key'>ALPHA</cite> <span class='rep'>*</span>( <cite class='key'>ALPHA</cite> / <cite class='key'>DIGIT</cite> / "<span class='str'>+</span>" / "<span class='str'>-</span>" / "<span class='str'>.</span>" )

 <dfn>authority</dfn>     = [ <cite class='id'>userinfo</cite> "<span class='str'>@</span>" ] <cite class='id'>host</cite> [ "<span class='str'>:</span>" <cite class='id'>port</cite> ]
 <dfn>userinfo</dfn>      = <span class='rep'>*</span>( <cite class='id'>unreserved</cite> / <cite class='id'>pct-encoded</cite> / <cite class='id'>sub-delims</cite> / "<span class='str'>:</span>" )
 <dfn>host</dfn>          = <cite class='id'>IP-literal</cite> / <cite class='id'>IPv4address</cite> / <cite class='id'>reg-name</cite>
 <dfn>port</dfn>          = <span class='rep'>*</span><cite class='key'>DIGIT</cite>

 <dfn>IP-literal</dfn>    = "<span class='str'>[</span>" ( <cite class='id'>IPv6address</cite> / <cite class='id'>IPvFuture</cite>  ) "<span class='str'>]</span>"

 <dfn>IPvFuture</dfn>     = "<span class='str'>v</span>" <span class='rep'>1*</span><cite class='key'>HEXDIG</cite> "<span class='str'>.</span>" <span class='rep'>1*</span>( <cite class='id'>unreserved</cite> / <cite class='id'>sub-delims</cite> / "<span class='str'>:</span>" )

 <dfn>IPv6address</dfn>   =                            <span class='rep'>6</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               /                       "<span class='str'>::</span>" <span class='rep'>5</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               / [               <cite class='id'>h16</cite> ] "<span class='str'>::</span>" <span class='rep'>4</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               / [ <span class='rep'>*1</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>" <span class='rep'>3</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               / [ <span class='rep'>*2</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>" <span class='rep'>2</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>ls32</cite>
               / [ <span class='rep'>*3</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>"    <cite class='id'>h16</cite> "<span class='str'>:</span>"   <cite class='id'>ls32</cite>
               / [ <span class='rep'>*4</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>"              <cite class='id'>ls32</cite>
               / [ <span class='rep'>*5</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>"              <cite class='id'>h16</cite>
               / [ <span class='rep'>*6</span>( <cite class='id'>h16</cite> "<span class='str'>:</span>" ) <cite class='id'>h16</cite> ] "<span class='str'>::</span>"

 <dfn>h16</dfn>           = <span class='rep'>1*4</span><cite class='key'>HEXDIG</cite>
 <dfn>ls32</dfn>          = ( <cite class='id'>h16</cite> "<span class='str'>:</span>" <cite class='id'>h16</cite> ) / <cite class='id'>IPv4address</cite>

 <dfn>IPv4address</dfn>   = <cite class='id'>dec-octet</cite> "<span class='str'>.</span>" <cite class='id'>dec-octet</cite> "<span class='str'>.</span>" <cite class='id'>dec-octet</cite> "<span class='str'>.</span>" <cite class='id'>dec-octet</cite>

 <dfn>dec-octet</dfn>     = <cite class='key'>DIGIT</cite>                 <em>; 0-9</em>
               / <span class='val'>%x31-39</span> <cite class='key'>DIGIT</cite>         <em>; 10-99</em>
               / "<span class='str'>1</span>" <span class='rep'>2</span><cite class='key'>DIGIT</cite>            <em>; 100-199</em>
               / "<span class='str'>2</span>" <span class='val'>%x30-34</span> <cite class='key'>DIGIT</cite>     <em>; 200-249</em>
               / "<span class='str'>25</span>" <span class='val'>%x30-35</span>          <em>; 250-255</em>

 <dfn>reg-name</dfn>      = <span class='rep'>*</span>( <cite class='id'>unreserved</cite> / <cite class='id'>pct-encoded</cite> / <cite class='id'>sub-delims</cite> )

 <dfn>path</dfn>          = <cite class='id'>path-abempty</cite>    <em>; begins with "/" or is empty</em>
               / <cite class='id'>path-absolute</cite>   <em>; begins with "/" but not "//"</em>
               / <cite class='id'>path-noscheme</cite>   <em>; begins with a non-colon segment</em>
               / <cite class='id'>path-rootless</cite>   <em>; begins with a segment</em>
               / <cite class='id'>path-empty</cite>      <em>; zero characters</em>

 <dfn>path-abempty</dfn>  = <span class='rep'>*</span>( "<span class='str'>/</span>" <cite class='id'>segment</cite> )
 <dfn>path-absolute</dfn> = "<span class='str'>/</span>" [ <cite class='id'>segment-nz</cite> <span class='rep'>*</span>( "<span class='str'>/</span>" <cite class='id'>segment</cite> ) ]
 <dfn>path-noscheme</dfn> = <cite class='id'>segment-nz-nc</cite> <span class='rep'>*</span>( "<span class='str'>/</span>" <cite class='id'>segment</cite> )
 <dfn>path-rootless</dfn> = <cite class='id'>segment-nz</cite> <span class='rep'>*</span>( "<span class='str'>/</span>" <cite class='id'>segment</cite> )
 <dfn>path-empty</dfn>    = <span class='rep'>0</span>&lt;<span class='str'>pchar</span>&gt;

 <dfn>segment</dfn>       = <span class='rep'>*</span><cite class='id'>pchar</cite>
 <dfn>segment-nz</dfn>    = <span class='rep'>1*</span><cite class='id'>pchar</cite>
 <dfn>segment-nz-nc</dfn> = <span class='rep'>1*</span>( <cite class='id'>unreserved</cite> / <cite class='id'>pct-encoded</cite> / <cite class='id'>sub-delims</cite> / "<span class='str'>@</span>" )
               <em>; non-zero-length segment without any colon ":"</em>

 <dfn>pchar</dfn>         = <cite class='id'>unreserved</cite> / <cite class='id'>pct-encoded</cite> / <cite class='id'>sub-delims</cite> / "<span class='str'>:</span>" / "<span class='str'>@</span>"

 <dfn>query</dfn>         = <span class='rep'>*</span>( <cite class='id'>pchar</cite> / "<span class='str'>/</span>" / "<span class='str'>?</span>" )

 <dfn>fragment</dfn>      = <span class='rep'>*</span>( <cite class='id'>pchar</cite> / "<span class='str'>/</span>" / "<span class='str'>?</span>" )

 <dfn>pct-encoded</dfn>   = "<span class='str'>%</span>" <cite class='key'>HEXDIG</cite> <cite class='key'>HEXDIG</cite>

 <dfn>unreserved</dfn>    = <cite class='key'>ALPHA</cite> / <cite class='key'>DIGIT</cite> / "<span class='str'>-</span>" / "<span class='str'>.</span>" / "<span class='str'>_</span>" / "<span class='str'>~</span>"
 <dfn>reserved</dfn>      = <cite class='id'>gen-delims</cite> / <cite class='id'>sub-delims</cite>
 <dfn>gen-delims</dfn>    = "<span class='str'>:</span>" / "<span class='str'>/</span>" / "<span class='str'>?</span>" / "<span class='str'>#</span>" / "<span class='str'>[</span>" / "<span class='str'>]</span>" / "<span class='str'>@</span>"
 <dfn>sub-delims</dfn>    = "<span class='str'>!</span>" / "<span class='str'>$</span>" / "<span class='str'>&amp;</span>" / "<span class='str'>'</span>" / "<span class='str'>(</span>" / "<span class='str'>)</span>"
               / "<span class='str'>*</span>" / "<span class='str'>+</span>" / "<span class='str'>,</span>" / "<span class='str'>;</span>" / "<span class='str'>=</span>"
</pre></div>
<a name="regexp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Parsing a URI Reference with a Regular Expression</h3>

<p>
As the "first-match-wins" algorithm is identical to the "greedy"
disambiguation method used by POSIX regular expressions, it is
natural and commonplace to use a regular expression for parsing the
potential five components of a URI reference.

</p>
<p>
The following line is the regular expression for breaking-down a
well-formed URI reference into its components.

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
    12            3  4          5       6  7        8 9
</pre></div>
<p>
The numbers in the second line above are only to assist readability;
they indicate the reference points for each subexpression (i.e., each
paired parenthesis).  We refer to the value matched for subexpression
&lt;n&gt; as $&lt;n&gt;.  For example, matching the above expression to

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   http://www.ics.uci.edu/pub/ietf/uri/#Related
</pre></div>
<p>
results in the following subexpression matches:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   $1 = http:
   $2 = http
   $3 = //www.ics.uci.edu
   $4 = www.ics.uci.edu
   $5 = /pub/ietf/uri/
   $6 = &lt;undefined&gt;
   $7 = &lt;undefined&gt;
   $8 = #Related
   $9 = Related
</pre></div>
<p>
where &lt;undefined&gt; indicates that the component is not present, as is
the case for the query component in the above example.  Therefore, we
can determine the value of the five components as

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   scheme    = $2
   authority = $4
   path      = $5
   query     = $7
   fragment  = $9
</pre></div>
<p>
Going in the opposite direction, we can recreate a URI reference
from its components by using the algorithm of <a class='info' href='#recomposition'>Section&nbsp;5.3<span> (</span><span class='info'>Component Recomposition</span><span>)</span></a>.

</p>
<a name="delimiting"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Delimiting a URI in Context</h3>

<p>
URIs are often transmitted through formats that do not provide a clear
context for their interpretation.  For example, there are many
occasions when a URI is included in plain text; examples include text
sent in email, USENET news, and on printed paper.  In such cases, it is important to be able to
delimit the URI from the rest of the text, and in particular from
punctuation marks that might be mistaken for part of the URI.

</p>
<p>
In practice, URIs are delimited in a variety of ways, but usually
within double-quotes "http://example.com/", angle brackets
&lt;http://example.com/&gt;, or just by using whitespace:

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   http://example.com/
</pre></div>
<p>
These wrappers do not form part of the URI.

</p>
<p>
In some cases, extra whitespace (spaces, line-breaks, tabs, etc.) may
have to be added to break a long URI across lines. The whitespace
should be ignored when the URI is extracted.

</p>
<p>
No whitespace should be introduced after a hyphen ("-") character.
Because some typesetters and printers may (erroneously) introduce a
hyphen at the end of line when breaking it, the interpreter of a
URI containing a line break immediately after a hyphen should ignore
all whitespace around the line break and should be aware
that the hyphen may or may not actually be part of the URI.

</p>
<p>
Using &lt;&gt; angle brackets around each URI is especially recommended as
a delimiting style for a reference that contains embedded whitespace.

</p>
<p>
The prefix "URL:" (with or without a trailing space) was formerly
recommended as a way to help distinguish a URI from other bracketed
designators, though it is not commonly used in practice and is
no longer recommended.

</p>
<p>
For robustness, software that accepts user-typed URI should attempt
to recognize and strip both delimiters and embedded whitespace.

</p>
<p style='text-align: left'>
For example, the text

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   Yes, Jim, I found it under "http://www.w3.org/Addressing/",
   but you can probably pick it up from &lt;ftp://foo.example.
   com/rfc/&gt;.  Note the warning in &lt;http://www.ics.uci.edu/pub/
   ietf/uri/historical.html#WARNING&gt;.
</pre></div>
<p>
contains the URI references

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   http://www.w3.org/Addressing/
   ftp://foo.example.com/rfc/
   http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING
</pre></div>
<a name="changes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D"></a><h3>Appendix D.&nbsp;
Changes from RFC 2396</h3>

<a name="additions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.1"></a><h3>D.1.&nbsp;
Additions</h3>

<p>
An ABNF rule for URI has been introduced to correspond to one
common usage of the term: an absolute URI with optional fragment.

</p>
<p>
IPv6 (and later) literals have been added to the list of possible identifiers
for the host portion of an authority component, as described by
<a class='info' href='#RFC2732'>[RFC2732]<span> (</span><span class='info'>Hinden, R., Carpenter, B., and L. Masinter, &ldquo;Format for Literal IPv6 Addresses in URL's,&rdquo; December&nbsp;1999.</span><span>)</span></a>, with the addition of "[" and "]" to
the reserved set and a version flag to anticipate future versions of
IP literals.  Square brackets are now specified as reserved within the
authority component and are not allowed outside their use as delimiters for
an IP literal within host.  In order to make this change without changing
the technical definition of the path, query, and fragment components,
those rules were redefined to directly specify the characters allowed.

</p>
<p>
As <a class='info' href='#RFC2732'>[RFC2732]<span> (</span><span class='info'>Hinden, R., Carpenter, B., and L. Masinter, &ldquo;Format for Literal IPv6 Addresses in URL's,&rdquo; December&nbsp;1999.</span><span>)</span></a> defers to <a class='info' href='#RFC3513'>[RFC3513]<span> (</span><span class='info'>Hinden, R. and S. Deering, &ldquo;Internet Protocol Version 6 (IPv6) Addressing Architecture,&rdquo; April&nbsp;2003.</span><span>)</span></a>
for definition of an IPv6 literal address, which, unfortunately, lacks
an ABNF description of IPv6address, we created a new ABNF rule
for IPv6address that matches the text representations defined by
Section 2.2 of <a class='info' href='#RFC3513'>[RFC3513]<span> (</span><span class='info'>Hinden, R. and S. Deering, &ldquo;Internet Protocol Version 6 (IPv6) Addressing Architecture,&rdquo; April&nbsp;2003.</span><span>)</span></a>.  Likewise, the definition
of IPv4address has been improved in order to limit each decimal
octet to the range 0-255.

</p>
<p>
<a class='info' href='#comparison'>Section&nbsp;6<span> (</span><span class='info'>Normalization and Comparison</span><span>)</span></a>, on URI normalization and comparison,
has been completely rewritten and extended by using input from Tim Bray
and discussion within the W3C Technical Architecture Group.

</p>
<a name="modifications"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D.2"></a><h3>D.2.&nbsp;
Modifications</h3>
<br /><hr class="insert" />
<a name="oldbnf"></a>

<p style='text-align: center'>
The ad-hoc BNF syntax of RFC 2396 has been replaced with the ABNF of
<a class='info' href='#RFC2234'>[RFC2234]<span> (</span><span class='info'>Crocker, D. and P. Overell, &ldquo;Augmented BNF for Syntax Specifications: ABNF,&rdquo; November&nbsp;1997.</span><span>)</span></a>.  This change required all rule names that
formerly included underscore characters to be renamed with a dash instead.
In addition, a number of syntax rules have been eliminated or simplified
to make the overall grammar more comprehensible.  Specifications that
refer to the obsolete grammar rules may be understood by replacing those
rules according to the following table:

</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">obsolete rule</th><th align="left">translation</th></tr>
<tr>
<td align="left">absoluteURI</td>
<td align="left"><a class='info' href='#absolute-uri'>absolute-URI<span> (</span><span class='info'>Absolute URI</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">relativeURI</td>
<td align="left"><a class='info' href='#relative-ref'>relative-part<span> (</span><span class='info'>Relative Reference</span><span>)</span></a> [ "?" <a class='info' href='#query'>query<span> (</span><span class='info'>Query</span><span>)</span></a> ]</td>
</tr>
<tr>
<td align="left">hier_part</td>
<td align="left">( "//" <a class='info' href='#authority'>authority<span> (</span><span class='info'>Authority</span><span>)</span></a> <a class='info' href='#path'>path-abempty<span> (</span><span class='info'>Path</span><span>)</span></a> / <a class='info' href='#path'>path-absolute<span> (</span><span class='info'>Path</span><span>)</span></a> ) [ "?" <a class='info' href='#query'>query<span> (</span><span class='info'>Query</span><span>)</span></a> ]</td>
</tr>
<tr>
<td align="left">opaque_part</td>
<td align="left"><a class='info' href='#path'>path-rootless<span> (</span><span class='info'>Path</span><span>)</span></a> [ "?" <a class='info' href='#query'>query<span> (</span><span class='info'>Query</span><span>)</span></a> ]</td>
</tr>
<tr>
<td align="left">net_path</td>
<td align="left">"//" <a class='info' href='#authority'>authority<span> (</span><span class='info'>Authority</span><span>)</span></a> <a class='info' href='#path'>path-abempty<span> (</span><span class='info'>Path</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">abs_path</td>
<td align="left"><a class='info' href='#path'>path-absolute<span> (</span><span class='info'>Path</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">rel_path</td>
<td align="left"><a class='info' href='#path'>path-rootless<span> (</span><span class='info'>Path</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">rel_segment</td>
<td align="left"><a class='info' href='#path'>segment-nz-nc<span> (</span><span class='info'>Path</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">reg_name</td>
<td align="left">reg-name</td>
</tr>
<tr>
<td align="left">server</td>
<td align="left"><a class='info' href='#authority'>authority<span> (</span><span class='info'>Authority</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">hostport</td>
<td align="left"><a class='info' href='#host'>host<span> (</span><span class='info'>Host</span><span>)</span></a> [ ":" <a class='info' href='#port'>port<span> (</span><span class='info'>Port</span><span>)</span></a> ]</td>
</tr>
<tr>
<td align="left">hostname</td>
<td align="left">reg-name</td>
</tr>
<tr>
<td align="left">path_segments</td>
<td align="left"><a class='info' href='#path'>path-abempty<span> (</span><span class='info'>Path</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">param</td>
<td align="left">*&lt;<a class='info' href='#path'>pchar<span> (</span><span class='info'>Path</span><span>)</span></a> excluding ";"&gt;</td>
</tr>
<tr>
<td align="left">uric</td>
<td align="left"><a class='info' href='#unreserved'>unreserved<span> (</span><span class='info'>Unreserved Characters</span><span>)</span></a> / <a class='info' href='#percent-encoding'>pct-encoded<span> (</span><span class='info'>Percent-Encoding</span><span>)</span></a> / ";" / "?" / ":" / "@" / "&amp;" / "=" / "+" / "$" / "," / "/"</td>
</tr>
<tr>
<td align="left">uric_no_slash</td>
<td align="left"><a class='info' href='#unreserved'>unreserved<span> (</span><span class='info'>Unreserved Characters</span><span>)</span></a> / <a class='info' href='#percent-encoding'>pct-encoded<span> (</span><span class='info'>Percent-Encoding</span><span>)</span></a> / ";" / "?" / ":" / "@" / "&amp;" / "=" / "+" / "$" / ","</td>
</tr>
<tr>
<td align="left">mark</td>
<td align="left">"-" / "_" / "." / "!" / "~" / "*" / "'" / "(" / ")"</td>
</tr>
<tr>
<td align="left">escaped</td>
<td align="left"><a class='info' href='#percent-encoding'>pct-encoded<span> (</span><span class='info'>Percent-Encoding</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">hex</td>
<td align="left"><a class='info' href='#notation'>HEXDIG<span> (</span><span class='info'>Syntax Notation</span><span>)</span></a></td>
</tr>
<tr>
<td align="left">alphanum</td>
<td align="left"><a class='info' href='#notation'>ALPHA<span> (</span><span class='info'>Syntax Notation</span><span>)</span></a> / <a class='info' href='#notation'>DIGIT<span> (</span><span class='info'>Syntax Notation</span><span>)</span></a></td>
</tr>
</table>
<br clear="all" />

<p style='text-align: center'>
Use of the above obsolete rules for the definition of scheme-specific
syntax is deprecated.

</p><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
Section 2, on characters, has been rewritten to explain what characters
are reserved, when they are reserved, and why they are reserved, even
when they are not used as delimiters by the generic syntax.
The mark characters that are typically unsafe to decode, including
the exclamation mark ("!"), asterisk ("*"), single-quote ("'"), and
open and close parentheses ("(" and ")"), have been moved to the reserved
set in order to clarify the distinction between reserved and unreserved
and, hopefully, to answer the most common question of scheme designers.
Likewise, the section on percent-encoded characters has been rewritten, and
URI normalizers are now given license to decode any percent-encoded octets
corresponding to unreserved characters.  In general, the terms "escaped"
and "unescaped" have been replaced with "percent-encoded" and "decoded",
respectively, to reduce confusion with other forms of escape mechanisms.

</p>
<p>
The ABNF for URI and URI-reference has been redesigned to make them
more friendly to LALR parsers and to reduce complexity.
As a result, the layout form of syntax description has been removed,
along with the uric, uric_no_slash, opaque_part, net_path,
abs_path, rel_path, path_segments, rel_segment, and mark rules.
All references to "opaque" URIs have been replaced with a better
description of how the path component may be opaque to hierarchy.
The relativeURI rule has been replaced with relative-ref to avoid
unnecessary confusion over whether they are a subset of URI.
The ambiguity regarding the parsing of URI-reference as a URI or a
relative-ref with a colon in the first segment has been eliminated
through the use of five separate path matching rules.

</p>
<p>
The fragment identifier has been moved back into the section on
generic syntax components and within the URI and relative-ref
rules, though it remains excluded from absolute-URI.
The number sign ("#") character has been moved back to the reserved set
as a result of reintegrating the fragment syntax.

</p>
<p>
The ABNF has been corrected to allow the path component to be empty.
This also allows an absolute-URI to consist of nothing after the "scheme:",
as is present in practice with the "dav:" namespace <a class='info' href='#RFC2518'>[RFC2518]<span> (</span><span class='info'>Goland, Y., Whitehead, E., Faizi, A., Carter, S., and D. Jensen, &ldquo;HTTP Extensions for Distributed Authoring -- WEBDAV,&rdquo; February&nbsp;1999.</span><span>)</span></a>
and with the "about:" scheme used internally by many WWW browser implementations.
The ambiguity regarding the boundary between authority and path has been
eliminated through the use of five separate path matching rules.

</p>
<p>
Registry-based naming authorities that use the generic syntax are now
defined within the host rule.
This change allows current implementations, where whatever name provided
is simply fed to the local name resolution mechanism, to be consistent
with the specification.  It also removes the need to re-specify DNS name
formats here.  Furthermore, it allows the host component to contain percent-encoded
octets, which is necessary to enable internationalized domain names to be
provided in URIs, processed in their native character encodings at the
application layers above URI processing, and passed to an IDNA library
as a registered name in the UTF-8 character encoding.
The server, hostport, hostname, domainlabel, toplabel, and alphanum
rules have been removed.

</p>
<p>
The resolving relative references algorithm of <a class='info' href='#RFC2396'>[RFC2396]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifiers (URI): Generic Syntax,&rdquo; August&nbsp;1998.</span><span>)</span></a>
has been rewritten with pseudocode for this revision to improve clarity
and fix the following issues:
</p>
<ul class="text">
<li>
<a class='info' href='#RFC2396'>[RFC2396]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifiers (URI): Generic Syntax,&rdquo; August&nbsp;1998.</span><span>)</span></a> section 5.2, step 6a, failed to account for
a base URI with no path.

</li>
<li>
Restored the behavior of <a class='info' href='#RFC1808'>[RFC1808]<span> (</span><span class='info'>Fielding, R., &ldquo;Relative Uniform Resource Locators,&rdquo; June&nbsp;1995.</span><span>)</span></a> where, if the
reference contains an empty path and a defined query component,
the target URI inherits the base URI's path component.

</li>
<li>
The determination of whether a URI reference is a same-document
reference has been decoupled from the URI parser, simplifying the
URI processing interface within applications in a way consistent with
the internal architecture of deployed URI processing implementations.
The determination is now based on comparison to the base URI after
transforming a reference to absolute form, rather than on the format
of the reference itself.  This change may result in more references
being considered "same-document" under this specification than there would
be under the rules given in RFC 2396, especially when
normalization is used to reduce aliases.  However, it does not change
the status of existing same-document references.

</li>
<li>
Separated the path merge routine into two routines: merge, for
describing combination of the base URI path with a relative-path
reference, and remove_dot_segments, for describing how to remove
the special "." and ".." segments from a composed path.  The
remove_dot_segments algorithm is now applied to all URI reference
paths in order to match common implementations and to improve the
normalization of URIs in practice.  This change only impacts the
parsing of abnormal references and same-scheme references wherein
the base URI has a non-hierarchical path.

</li>
</ul><p>

</p><a name="rfc.index"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Index</h3>
<table>
<tr><td><strong>A</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor23"><b>ABNF</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor136"><b>absolute</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor131"><b>absolute-path</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor137"><b>absolute-URI</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor15"><b>access</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor51">authority</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor67"><b></b></a></td></tr>
<tr><td><strong>B</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor145"><b>base URI</b></a></td></tr>
<tr><td><strong>C</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor3"><b>character</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor5"><b>character encoding</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor32"><b>characters</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor4"><b>coded character set</b></a></td></tr>
<tr><td><strong>D</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor90"><b>dec-octet</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor17"><b>dereference</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor118"><b>dot-segments</b></a></td></tr>
<tr><td><strong>F</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor54">fragment</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor122"><b></b></a></td></tr>
<tr><td><strong>G</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor37"><b>gen-delims</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor9"><b>generic syntax</b></a></td></tr>
<tr><td><strong>H</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor80"><b>h16</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor45"><b>hier-part</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor21"><b>hierarchical</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor74"><b>host</b></a></td></tr>
<tr><td><strong>I</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor8"><b>identifier</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor77"><b>IP-literal</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor88"><b>IPv4</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor89"><b>IPv4address</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor76"><b>IPv6</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor78"><b>IPv6address</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor81"><b>IPvFuture</b></a></td></tr>
<tr><td><strong>L</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor12"><b>locator</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor79"><b>ls32</b></a></td></tr>
<tr><td><strong>M</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor146"><b>merge</b></a></td></tr>
<tr><td><strong>N</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor13"><b>name</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor130"><b>network-path</b></a></td></tr>
<tr><td><strong>P</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor52">path</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor98"><b></b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor99"><b>path-abempty</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor100"><b>path-absolute</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor103"><b>path-empty</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor101"><b>path-noscheme</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor102"><b>path-rootless</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor46">path-abempty</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor47">path-absolute</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor49">path-empty</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor48">path-rootless</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor107"><b>pchar</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor34"><b>pct-encoded</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor33"><b>percent-encoding</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor96"><b>port</b></a></td></tr>
<tr><td><strong>Q</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor53">query</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor119"><b></b></a></td></tr>
<tr><td><strong>R</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor93"><b>reg-name</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor94"><b>registered name</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor143">relative</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor22"><b></b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor132"><b>relative-path</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor129"><b>relative-ref</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor147"><b>remove_dot_segments</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor19"><b>representation</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor36"><b>reserved</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor144">resolution</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor16"><b></b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor7"><b>resource</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor18"><b>retrieval</b></a></td></tr>
<tr><td><strong>S</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor141"><b>same-document</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor20"><b>sameness</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor50">scheme</a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor65"><b></b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor104"><b>segment</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor105"><b>segment-nz</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor106"><b>segment-nz-nc</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor38"><b>sub-delims</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor142"><b>suffix</b></a></td></tr>
<tr><td><strong>T</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor14"><b>transcription</b></a></td></tr>
<tr><td><strong>U</strong></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor6"><b>uniform</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor42"><b>unreserved</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor44"><b>URI</b></a></td></tr>
<tr><td>&nbsp;</td><td>URI grammar</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor138"><b>absolute-URI</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor24"><b>ALPHA</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor57">authority</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor68"><b>authority</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor25"><b>CR</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor92"><b>dec-octet</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor26"><b>DIGIT</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor27"><b>DQUOTE</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;fragment  <a href="#anchor60">1</a>, <a href="#anchor135">2</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor123"><b>fragment</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor40"><b>gen-delims</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor87"><b>h16</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor28"><b>HEXDIG</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor58"><b>hier-part</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor70">host</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor75"><b>host</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor82"><b>IP-literal</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor91"><b>IPv4address</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor83">IPv6address</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor85"><b>IPv6address</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor84"><b>IPvFuture</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor29"><b>LF</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor86"><b>ls32</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor30"><b>OCTET</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor108"><b>path</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor61">path-abempty</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor109"><b>path-abempty</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor62">path-absolute</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor110"><b>path-absolute</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor64">path-empty</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor113"><b>path-empty</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor111"><b>path-noscheme</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor63">path-rootless</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor112"><b>path-rootless</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;pchar  <a href="#anchor121">1</a>, <a href="#anchor124">2</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor117"><b>pchar</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor35"><b>pct-encoded</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor71">port</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor97"><b>port</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;query  <a href="#anchor59">1</a>, <a href="#anchor134">2</a>, <a href="#anchor140">3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor120"><b>query</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor95"><b>reg-name</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor128">relative-ref</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor133"><b>relative-ref</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor39"><b>reserved</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;scheme  <a href="#anchor56">1</a>, <a href="#anchor139">2</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor66"><b>scheme</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor114"><b>segment</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor115"><b>segment-nz</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor116"><b>segment-nz-nc</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor31"><b>SP</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor41"><b>sub-delims</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor43"><b>unreserved</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor127">URI</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor55"><b>URI</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor126"><b>URI-reference</b></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor69">userinfo</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor73"><b>userinfo</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor125"><b>URI-reference</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor10"><b>URL</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor11"><b>URN</b></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#anchor72"><b>userinfo</b></a></td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Tim Berners-Lee</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">World Wide Web Consortium</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Massachusetts Institute of Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">77 Massachusetts Avenue</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cambridge, MA  02139</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-617-253-5702</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+1-617-258-5999</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text">timbl@w3.org</td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.w3.org/People/Berners-Lee/">http://www.w3.org/People/Berners-Lee/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Roy T. Fielding</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Day Software</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">5251 California Ave., Suite 110</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Irvine, CA  92617</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-949-679-2960</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+1-949-679-2972</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text">fielding@gbiv.com</td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://roy.gbiv.com/">http://roy.gbiv.com/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Larry Masinter</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Adobe Systems Incorporated</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">345 Park Ave</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">San Jose, CA  95110</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1-408-536-3024</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text">LMM@acm.org</td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://larry.masinter.net/">http://larry.masinter.net/</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The Internet Society (2005).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY),
THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM
ALL WARRANTIES,
EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at ietf-ipr@ietf.org.</p>
<h3>Acknowledgment</h3>
<p class='copyright'>
Funding for the RFC Editor function is currently provided by
the Internet Society.</p>
</body></html>
