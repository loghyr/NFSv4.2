<!-- Copyright (C) The IETF Trust (2011) -->
<!-- Copyright (C) The Internet Society (2011) -->

<section anchor="sec:sparse" title="Sparse Files">
  <section anchor="ss:sparse:intro" title="Introduction">
    <t>
      A sparse file is a common way of representing a large file without
      having to utilize all of the disk space for it.  Consequently, a
      sparse file uses less physical space than its size indicates.  This
      means the file contains 'holes', byte ranges within the file that
      contain no data.  Most modern file systems support sparse files,
      including most UNIX file systems and NTFS, but notably not Apple's
      HFS+.  Common examples of sparse files include Virtual Machine (VM)
      OS/disk images, database files, log files, and even checkpoint
      recovery files most commonly used by the HPC community.
    </t>

    <t>
      If an application reads a hole in a sparse file, the file system must
      return all zeros to the application.   For local data access there
      is little penalty, but with NFS these zeroes must be transferred back
      to the client.  If an application uses the NFS client to read data
      into memory, this wastes time and bandwidth as the application waits
      for the zeroes to be transferred.
    </t>

    <t>
      A sparse file is typically created by initializing the file to
      be all zeros - nothing is written to the data in the file, instead
      the hole is recorded in the metadata for the file. So a 8G disk
      image might be represented initially by a couple hundred bits
      in the inode and nothing on the disk. If the VM then writes
      100M to a file in the middle of the image, there would now be
      two holes represented in the metadata and 100M in the data.
    </t>

    <t>
      This section introduces a new operation READ_PLUS which supports
      all the features of READ but includes an extension to support sparse
      pattern files.  READ_PLUS is guaranteed to perform
      no worse than READ, and can dramatically improve performance with
      sparse files.  READ_PLUS does not depend on pNFS protocol features,
      but can be used by pNFS to support sparse files.
    </t>
  </section>

  <section anchor="ss:sparse:terms" title="Terminology">
    <t>
      <list style="hanging">
        <t hangText="Regular file:">
          An object of file type NF4REG or NF4NAMEDATTR.
        </t>

        <t hangText="Sparse file:">
          A Regular file that contains one or more Holes.
        </t>

        <t hangText="Hole:">
          A byte range within a Sparse file that contains regions of
          all zeroes.  For block-based file systems, this could also be an
          unallocated region of the file.
        </t>

        <t hangText='Hole Threshold:'>
          The minimum length of a Hole as determined by the server.
          If a server chooses to define a Hole Threshold, then it
          would not return hole information (nfs_readplusreshole)
          with a hole_offset and hole_length that specify a range
          shorter than the Hole Threshold.
        </t> 
      </list>
    </t>
  </section>

  <section anchor="ss:sparse:overiew" title="Overview of Sparse Files and NFSv4">
    <t>
      This section provides sparse file support to the largest
      number of NFS client and server implementations, and as such proposes
      to add a new return code to the READ_PLUS operation
      instead of proposing additions or extensions of new or existing
      optional features (such as pNFS).
    </t>
  </section>

  <section anchor="ss:sparse:readplus" title="Operation 65: READ_PLUS">
    <t>
      The section introduces a new read operation, named READ_PLUS, which
      allows NFS clients to avoid reading holes in a sparse file. READ_PLUS
      is guaranteed to perform no worse than READ, and can dramatically
      improve performance with sparse files.
    </t>

    <t>
      READ_PLUS supports all the features of the existing NFSv4.1 READ
      operation <xref target="ref:RFC5661" /> and adds a simple yet
      significant extension to the
      format of its response.  The change allows the client to avoid
      returning all zeroes from a file hole, wasting computational and
      network resources and reducing performance.  READ_PLUS uses a new
      result structure that tells the client that the result is all zeroes
      AND the byte-range of the hole in which the request was made.
      Returning the hole's byte-range, and only upon request, avoids
      transferring large Data Region Maps that may be soon invalidated and
      contain information about a file that may not even be read in its
      entirely.
    </t>

    <t>
      A new read operation is required due to NFSv4.1 minor versioning
      rules that do not allow modification of existing operation's
      arguments or results.  READ_PLUS is designed in such a way to allow
      future extensions to the result structure.  The same approach could
      be taken to extend the argument structure, but a good use case is
      first required to make such a change.
    </t>

    <section title="ARGUMENT">
      <?rfc include='autogen/read_plus_args.xml'?>
    </section>

    <section title="RESULT">
      <?rfc include='autogen/read_plus_res.xml'?>
    </section>

    <section title="DESCRIPTION">

      <t>
        The READ_PLUS operation is based upon the NFSv4.1 READ operation
        <xref target="ref:RFC5661" />, and similarly reads data from the
        regular file identified by the current filehandle.
      </t>

      <t>
        The client provides an offset of where the READ_PLUS is to start and a
        count of how many bytes are to be read.  An offset of zero means to
        read data starting at the beginning of the file.  If offset is
        greater than or equal to the size of the file, the status NFS4_OK is
        returned with nfs_readplusrestype4 set to READ_OK, data length set to
        zero, and eof set to TRUE.  The READ_PLUS is subject to access
        permissions checking.
      </t>

      <t>
        If the client specifies a count value of zero, the READ_PLUS succeeds
        and returns zero bytes of data, again subject to access permissions
        checking.  In all situations, the server may choose to return fewer
        bytes than specified by the client.  The client needs to check for
        this condition and handle the condition appropriately.
      </t>

      <t>
        If the client specifies an offset and count value that is entirely
        contained within a hole of the file, the status NFS4_OK is returned
        with nfs_readplusresok4 set to READ_HOLE, and if information is
        available regarding the hole, a nfs_readplusreshole structure
        containing the offset and range of the entire hole.  The
        nfs_readplusreshole structure is considered valid until the file is
        changed (detected via the change attribute).  The server MUST provide
        the same semantics for nfs_readplusreshole as if the client read the
        region and received zeroes; the implied holes contents lifetime MUST
        be exactly the same as any other read data.
      </t>

      <t>
        If the client specifies an offset and count value that begins in a
        non-hole of the file but extends into hole the server should return a
        short read with status NFS4_OK, nfs_readplusresok4 set to READ_OK,
        and data length set to the number of bytes returned.  The client will
        then issue another READ_PLUS for the remaining bytes, which the server
        will respond with information about the hole in the file.
      </t>

      <t>
        If the server knows that the requested byte range is into a hole of
        the file, but has no further information regarding the hole, it
        returns a nfs_readplusreshole structure with holeres4 set to
        HOLE_NOINFO.
      </t>

      <t>
        If hole information is available and can be returned to
        the client, the server returns a nfs_readplusreshole structure with
        the value of holeres4 to HOLE_INFO.  The values of hole_offset and
        hole_length define the byte-range for the current hole in the file.
        These values represent the information known to the server and may
        describe a byte-range smaller than the true size of the hole.
      </t>

      <t>
        Except when special stateids are used, the stateid value for a
        READ_PLUS request represents a value returned from a previous byte-
        range lock or share reservation request or the stateid associated
        with a delegation.  The stateid identifies the associated owners if
        any and is used by the server to verify that the associated locks are
        still valid (e.g., have not been revoked).
      </t>

      <t>
        If the read ended at the end-of-file (formally, in a correctly formed
        READ_PLUS operation, if offset + count is equal to the size of the
        file), or the READ_PLUS operation extends beyond the size of the file
        (if offset + count is greater than the size of the file), eof is
        returned as TRUE; otherwise, it is FALSE.  A successful READ_PLUS of
        an empty file will always return eof as TRUE.
      </t>

      <t>
        If the current filehandle is not an ordinary file, an error will be
        returned to the client.  In the case that the current filehandle
        represents an object of type NF4DIR, NFS4ERR_ISDIR is returned.  If
        the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is
        returned.  In all other cases, NFS4ERR_WRONG_TYPE is returned.
      </t>

      <t>
        For a READ_PLUS with a stateid value of all bits equal to zero, the
        server MAY allow the READ_PLUS to be serviced subject to mandatory
        byte-range locks or the current share deny modes for the file.  For a
        READ_PLUS with a stateid value of all bits equal to one, the server
        MAY allow READ_PLUS operations to bypass locking checks at the server.
      </t>

      <t>
        On success, the current filehandle retains its value.
      </t>
    </section>

    <section title="IMPLEMENTATION">
      <t>
        If the server returns a "short read" (i.e., fewer data than requested
        and eof is set to FALSE), the client should send another READ_PLUS to
        get the remaining data.  A server may return less data than requested
        under several circumstances.  The file may have been truncated by
        another client or perhaps on the server itself, changing the file
        size from what the requesting client believes to be the case.  This
        would reduce the actual amount of data available to the client.  It
        is possible that the server reduce the transfer size and so return a
        short read result.  Server resource exhaustion may also occur in a
        short read.
      </t>

      <t>
        If mandatory byte-range locking is in effect for the file, and if the
        byte-range corresponding to the data to be read from the file is
        WRITE_LT locked by an owner not associated with the stateid, the
        server will return the NFS4ERR_LOCKED error.  The client should try
        to get the appropriate READ_LT via the LOCK operation before re-
        attempting the READ_PLUS.  When the READ_PLUS completes, the client
        should release the byte-range lock via LOCKU. In addition, the
        server MUST return a nfs_readplusreshole structure with values of
        hole_offset and hole_length that are within the owner’s locked
        byte range.
      </t>

      <t>
        If another client has an OPEN_DELEGATE_WRITE delegation for the file
        being read, the delegation must be recalled, and the operation cannot
        proceed until that delegation is returned or revoked.  Except where
        this happens very quickly, one or more NFS4ERR_DELAY errors will be
        returned to requests made while the delegation remains outstanding.
        Normally, delegations will not be recalled as a result of a READ_PLUS
        operation since the recall will occur as a result of an earlier OPEN.
        However, since it is possible for a READ_PLUS to be done with a
        special stateid, the server needs to check for this case even though
        the client should have done an OPEN previously.
      </t>

      <section title="Additional pNFS Implementation Information">

        <t>
          With pNFS, the semantics of using READ_PLUS remains the same.  Any
          data server MAY return a READ_HOLE result for a READ_PLUS request that
          it receives.
        </t>

        <t>
          When a data server chooses to return a READ_HOLE result, it has the
          option of returning hole information for the data stored on that
          data server (as defined by the data layout), but it MUST not return
          a nfs_readplusreshole structure with a byte range that includes
          data managed by another data server.
        </t>

        <t>
          <list style="numbers">
            <t>
              Data servers that cannot determine hole information
              SHOULD return HOLE_NOINFO.
            </t>

            <t>
              Data servers that can obtain hole information for the
              parts of the file stored on that data server, the data
              server SHOULD return HOLE_INFO and the byte range of
              the hole stored on that data server.
            </t>
          </list>
        </t>

        <t>
          A data server should do its best to return as much information about
          a hole as is feasible without having to contact the metadata server.
          If communication with the metadata server is required, then every
          attempt should be taken to minimize the number of requests.
        </t>
          
        <t>
          If mandatory locking is enforced, then the data server must also
          ensure that to return only information for a Hole that is within
          the owner’s locked byte range.
        </t>
      </section>
    </section>

    <section title="READ_PLUS with Sparse Files Example">

      <t>
        To see how the return value READ_HOLE will work, the following table
        describes a sparse file.  For each byte range, the file contains
        either non-zero data or a hole. In addition, the server in this
        example uses a hole threshold of 32K.
      </t>


      <texttable anchor="space_example">
        <ttcol align='left' >Byte-Range</ttcol>
        <ttcol align='left' >Contents</ttcol>

        <c>0-15999    </c> <c>Hole    </c>
        <c>16K-31999  </c> <c>Non-Zero</c>
        <c>32K-255999 </c> <c>Hole    </c>
        <c>256K-287999</c> <c>Non-Zero</c>
        <c>288K-353999</c> <c>Hole    </c>
        <c>354K-417999</c> <c>Non-Zero</c>
      </texttable>

      <t>
        Under the given circumstances, if a client was to read the file from
        beginning to end with a max read size of 64K, the following will be
        the result.  This assumes the client has already opened the file and
        acquired a valid stateid and just needs to issue READ_PLUS requests.
      </t>

      <t>
        <list style="numbers">
          <t>
            READ_PLUS(s, 0, 64K) --> NFS_OK, readplusrestype4 = READ_OK, eof =
            false, data&lt;&gt;[32K].  Return a short read, as the last half of the
            request was all zeroes. Note that the first hole is read back as
            all zeros as it is below the hole threshhold.
          </t>

          <t>
            READ_PLUS(s, 32K, 64K) --> NFS_OK, readplusrestype4 = READ_HOLE,
            nfs_readplusreshole(HOLE_INFO)(32K, 224K). The requested range was
            all zeros, and the current hole begins at offset 32K and is 224K
            in length.
          </t>

          <t>
            READ_PLUS(s, 256K, 64K) --> NFS_OK, readplusrestype4 = READ_OK, eof
            = false, data&lt;&gt;[32K].  Return a short read, as the last half of
            the request was all zeroes.
          </t>

          <t>
            READ_PLUS(s, 288K, 64K) --> NFS_OK, readplusrestype4 = READ_HOLE,
            nfs_readplusreshole(HOLE_INFO)(288K, 66K).
          </t>

          <t>
           READ_PLUS(s, 354K, 64K) --> NFS_OK, readplusrestype4 = READ_OK,
           eof = true, data&lt;&gt;[64K].
          </t>
        </list>
      </t>
    </section>
  </section>

  <section anchor="ss:sparse:related" title="Related Work">
    <t>
      Solaris and ZFS support an extension to lseek(2) that allows
      applications to discover holes in a file. The values, SEEK_HOLE and
      SEEK_DATA, allow clients to seek to the next hole or beginning of
      data, respectively.
    </t>

    <t>
      XFS supports the XFS_IOC_GETBMAP extended attribute, which returns
      the Data Region Map for a file. Clients can then use this information
      to avoid reading holes in a file.
    </t>

    <t>
      NTFS and CIFS support the FSCTL_SET_SPARSE attribute, which allows
      applications to control whether empty regions of the file are
      preallocated and filled in with zeros or simply left unallocated.
    </t>
  </section>

  <section anchor='ss:sparse:other' title='Other Proposed Designs'>
    <section anchor='ss:sparse:mdshi' title='Multi-Data Server Hole Information'>
      <t>
        The current design prohibits pnfs data servers from returning hole
        information for regions of a file that are not stored on that data
        server.  Having data servers return information regarding other
        data servers changes the fundamental principal that all metadata
        information comes from the metadata server.
      </t>
        
      <t>
        Here is a brief description if we did choose to support multi-data
        server hole information:
      </t>
        
      <t>
        For a data server that can obtain hole information for the entire
        file without severe performance impact, it MAY return HOLE_INFO and
        the byte range of the entire file hole.  When a pNFS client receives
        a READ_HOLE result and a non-empty nfs_readplusreshole structure,
        it MAY use this information in conjunction with a valid layout for
        the file to determine the next data server for the next region of
        data that is not in a hole.
      </t>
    </section>

    <section anchor='ss:sparse:dra' title='Data Result Array'>
      <t>
        If a single read request contains one or more Holes with a length
        greater than the Sparse Threshold, the current design would return
        results indicating a short read to the client.  A client would then
        send a series of read requests to the server to retrieve information
        for the Holes and the remaining data.  To avoid turning a single
        read request into several exchanges between the client and server,
        the server may need to choose a relatively large Sparse Threshold
        in order to decrease the number of short reads it creates.  A large
        Sparse Threshold may miss many smaller holes, which in turn may
        negate the benefits of sparse read support.
      </t>
        
      <t>
        To avoid this situation, one option is to have the READ_PLUS operation
        return information for multiple holes in a single return value.
        This would allow several small holes to be described in a single
        read response without requiring multliple exchanges between the
        client and server.
      </t>
        
      <t>
        One important item to consider with returning an array of data
        chunks is its impact on RDMA, which may use different block sizes
        on the client and server (among other things).
      </t>
    </section>

    <section anchor='ss:sparse:udsm' title='User-Defined Sparse Mask'>
      <t>
        Add mask (instead of just zeroes). Specified by server or client? 
      </t>
    </section>

    <section anchor='ss:sparse:af' title='Allocated flag'>
      <t>
        A Hole on the server may be an allocated byte-range consisting of
        all zeroes or may not be allocated at all.  To ensure this information
        is properly communicated to the client, it may be beneficial to add
        a 'alloc' flag to the HOLE_INFO section of nfs_readplusreshole.
        This would allow an NFS client to copy a file from one file system
        to another and have it more closely resemble the original.
      </t>
    </section>

    <section anchor='ss:sparse:dspfl' title='Dense and Sparse pNFS File Layouts'>
      <t>
        The hole information returned form a data server must be understood
        by pNFS clients using both Dense or Sparse file layout types.  Does
        the current READ_PLUS return value work for both layout types?  Does
        the data server know if it is using dense or sparse so that it can
        return the correct hole_offset and hole_length values?
      </t>
    </section>
  </section>
</section>
