<!-- Copyright (C) The IETF Trust (2011-2014) -->
<!-- Copyright (C) The Internet Society (2011-2014) -->

<section anchor="sec:sparse" title="Sparse Files">
  <section anchor="ss:sparse:intro" title="Introduction">
    <t>
      A sparse file is a common way of representing a large file without
      having to utilize all of the disk space for it.  Consequently, a
      sparse file uses less physical space than its size indicates.  This
      means the file contains 'holes', byte ranges within the file that
      contain no data.  Most modern file systems support sparse files,
      including most UNIX file systems and NTFS, but notably not Apple's
      HFS+.  Common examples of sparse files include Virtual Machine (VM)
      OS/disk images, database files, log files, and even checkpoint
      recovery files most commonly used by the HPC community.
    </t>

    <t>
      If an application reads a hole in a sparse file, the file system must
      return all zeros to the application.   For local data access there
      is little penalty, but with NFS these zeroes must be transferred back
      to the client.  If an application uses the NFS client to read data
      into memory, this wastes time and bandwidth as the application waits
      for the zeroes to be transferred.
    </t>

    <t>
      A sparse file is typically created by initializing the file to
      be all zeros - nothing is written to the data in the file, instead
      the hole is recorded in the metadata for the file. So a 8G disk
      image might be represented initially by a couple hundred bits
      in the inode and nothing on the disk. If the VM then writes
      100M to a file in the middle of the image, there would now be
      two holes represented in the metadata and 100M in the data.
    </t>

    <t>
      No new operation is needed to allow the creation of a sparsely
      populated file, when a file is created and a write occurs past
      the current size of the file, the non-allocated region will either
      be a hole or filled with zeros.  The choice of behavior is dictated
      by the underlying filesystem and is transparent to the application.
      What is needed are the abilities to read sparse files and to punch
      holes to reinitialize the contents of a file.
    </t>

    <t>
      Two new operations WRITE_HOLE (<xref target="op:write_hole" />)
      and READ_PLUS (<xref target="op:read_plus" />) are
      introduced.  WRITE_HOLE allows for the hole punching.  I.e.,
      an application might want to reinitialize a range of the file.
      READ_PLUS supports all the features of READ but includes
      an extension to support sparse files.  READ_PLUS is guaranteed
      to perform no worse than READ, and can dramatically improve
      performance with sparse files.  READ_PLUS does not depend on
      pNFS protocol features, but can be used by pNFS to support
      sparse files.
    </t>
  </section>

  <section anchor="ss:sparse:terms" title="Terminology">
    <t>
      <list style="hanging">
        <t hangText="Regular file:">
          An object of file type NF4REG or NF4NAMEDATTR.
        </t>

        <t hangText="Sparse file:">
          A Regular file that contains one or more holes.
        </t>

        <t hangText="Hole:">
          A byte range within a Sparse file that contains regions of
          all zeroes.  For block-based file systems, this could also be an
          unallocated region of the file.
        </t>

        <t hangText='Hole Threshold:'>
          The minimum length of a Hole as determined by the server.
          If a server chooses to define a Hole Threshold, then it
          would not return hole information about holes with a length
          shorter than the Hole Threshold.
        </t>
      </list>
    </t>
  </section>

  <section anchor="ss:sparse:new_ops" title="New Operations">
    <t>
      READ_PLUS and WRITE_HOLE are new variants of the NFSv4.1 READ
      and WRITE operations <xref target="RFC5661" />.  Besides being
      able to support all of the data semantics of those operations,
      they can also be used by the client and server to efficiently
      transfer holes.  Note that as the client has no a priori
      knowledge of whether a hole is present or not, if it supports
      these operations and so does the server, then it should always
      use the READ_PLUS operation in preference to the READ operation..
    </t>

    <section anchor="ss:sparse:read_plus" title="READ_PLUS">
      <t>
       For holes, READ_PLUS extends the response to avoid returning
       data for portions of the file which are initialized and
       contain no backing store.  Additionally it will do so if
       the result would appear to be a hole. I.e., if the result
       was a data block composed entirely of zeros, then it is
       easier to return a hole. Returning data blocks of uninitialized
       data wastes computational and network resources, thus
       reducing performance.
      </t>

      <t>
        If the client sends a READ operation, it is explicitly
        stating that it is not supporting sparse files. So
        if a READ occurs on a sparse file, then the server must
        expand such data to be raw bytes. If a READ occurs in
        the middle of a hole, the server can only send back
        bytes starting from that offset. In contrast, if a READ_PLUS
        occurs in the middle of a hole, the server can send
        back a range which starts before the offset and extends past
        the range.
      </t>
    </section>

    <section anchor="ss:sparse:write_hole" title="WRITE_HOLE">
      <t>
        WRITE_HOLE can be used to hole punch, which allows the
        client to avoid the transfer of a repetitive pattern of zeros
        across the network.  If the filesystem on the server does not
        support sparse files, the WRITE_HOLE operation may return
        the result asynchronously via the CB_OFFLOAD operation.  As
        a hole punch may entail deallocating data blocks, even if
        the filesystem supports sparse files, it may still have to
        return the result via CB_OFFLOAD.
      </t>
    </section>
  </section>
</section>
