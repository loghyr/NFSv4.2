<!-- Copyright (C) The IETF Trust (2011-2013) -->
<!-- Copyright (C) The Internet Society (2011-2013) -->

<section anchor="sec:copy" title="Server-side Copy">
  <section title="Introduction">
    <t>
      The server-side copy feature provides a mechanism for
      the NFS client to perform a file copy on the server without
      the data being transmitted back and forth over the network.
      Without this feature, an NFS client copies data from one location
      to another by reading the data from the server over the network, and
      then writing the data back over the network to the server. Using this
      server-side copy operation, the client is able to instruct the server
      to copy the data locally without the data being sent back and forth
      over the network unnecessarily.
    </t>

    <t>
      If the source object and destination object are on different file
      servers, the file servers will communicate with one another to
      perform the copy operation. The server-to-server protocol by which
      this is accomplished is not defined in this document.
    </t>
  </section>

  <section title="Protocol Overview">
    <t>
      The server-side copy offload operations support both intra-server and
      inter-server file copies. An intra-server copy is a copy in which the
      source file and destination file reside on the same server. In an
      inter-server copy, the source file and destination file are on
      different servers. In both cases, the copy may be performed
      synchronously or asynchronously.
    </t>

    <t>
      Throughout the rest of this document, we refer to the NFS
      server containing the source file as the "source server"
      and the NFS server to which the file is transferred as the
      "destination server". In the case of an intra-server copy,
      the source server and destination server are the same server.
      Therefore in the context of an intra-server copy, the terms
      source server and destination server refer to the
      single server performing the copy.
    </t>

    <t>
      The operations described below are designed to copy files. Other
      file system objects can be copied by building on these operations
      or using other techniques. For example if the user wishes to copy
      a directory, the client can synthesize a directory copy by first
      creating the destination directory and then copying the source
      directory's files to the new destination directory. If the user
      wishes to copy a namespace junction <xref target="FEDFS-NSDB" />
      <xref target="FEDFS-ADMIN" />, the client can use the ONC RPC
      Federated Filesystem protocol <xref target="FEDFS-ADMIN" /> to
      perform the copy. Specifically the client can determine the
      source junction's attributes using the FEDFS_LOOKUP_FSN procedure
      and create a duplicate junction using the FEDFS_CREATE_JUNCTION
      procedure.
    </t>

    <t>
      For the inter-server copy, the operations are defined
      to be compatible with the traditional copy authentication approach.
      The client and user are authorized at the source for reading. Then
      they are authorized at the destination for writing.
    </t>

    <section title="Overview of Copy Operations">
      <t>
        <list style="hanging">
          <t hangText="COPY_NOTIFY:">
            For inter-server copies, the client sends
            this operation to the source server to notify it of a future
            file copy from a given destination server for the given user.
            (<xref target="op:copy_notify" />)
          </t>

          <t hangText="OFFLOAD_REVOKE:">
            Also for inter-server copies, the client
            sends this operation to the source server to revoke permission
            to copy a file for the given user.
            (<xref target="op:offload_revoke" />)
          </t>

          <t hangText="COPY:">
            Used by the client to request a file copy.
            (<xref target="op:copy" />)
          </t>

          <t hangText="OFFLOAD_ABORT:">
            Used by the client to abort an asynchronous file copy.
            (<xref target="op:offload_abort" />)
          </t>

          <t hangText="OFFLOAD_STATUS:">
            Used by the client to poll the status of
            an asynchronous file copy.
            (<xref target="op:offload_status" />)
          </t>

          <t hangText="CB_OFFLOAD:">
            Used by the destination server to report the
            results of an asynchronous file copy to the client.
            (<xref target="op:cb_offload" />)
          </t>
        </list>
      </t>
    </section>

    <section title="Locking the Files">
      <t>
        Both the source and destination file may need to be locked
        to protect the content during the copy operations. A client
        can achieve this by a combination of OPEN and LOCK operations.
        I.e., either share or byte range locks might be desired.
      </t>
    </section>

    <section title="Intra-Server Copy">
      <t>
        To copy a file on a single server, the client uses a COPY operation.
        The server may respond to the copy operation with the final results of
        the copy or it may perform the copy asynchronously and deliver the
        results using a CB_OFFLOAD operation callback. If the copy is performed
        asynchronously, the client may poll the status of the copy using
        OFFLOAD_STATUS or cancel the copy using OFFLOAD_ABORT.
      </t>

      <t>
        A synchronous intra-server copy is shown in
        <xref target="fig:sync-intra-server" />. In this example, the NFS
        server chooses to perform the copy synchronously. The copy operation
        is completed, either successfully or unsuccessfully, before the
        server replies to the client's request. The server's reply contains
        the final result of the operation.
      </t>

      <figure title="A synchronous intra-server copy." anchor="fig:sync-intra-server">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the source file
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the destination file
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the destination file
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the source file
     |                                      |
     |                                      |
        ]]></artwork>
      </figure>

      <t>
        An asynchronous intra-server copy is shown in
        <xref target="afig:sync-intra-server" />. In this example, the NFS
        server performs the copy asynchronously. The server's reply to
        the copy request indicates that the copy operation was initiated
        and the final result will be delivered at a later time. The server's
        reply also contains a copy stateid. The client may use this copy
        stateid to poll for status information (as shown) or to cancel the copy
        using a OFFLOAD_ABORT. When the server completes the copy, the server
        performs a callback to the client and reports the results.
      </t>

      <figure title="An asynchronous intra-server copy." anchor="afig:sync-intra-server">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the source file
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the destination file
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |                                      |
     |--- OFFLOAD_STATUS ------------------>| Client may poll
     |<------------------------------------/| for status
     |                                      |
     |                  .                   | Multiple OFFLOAD_STATUS
     |                  .                   | operations may be sent.
     |                  .                   |
     |                                      |
     |<-- CB_OFFLOAD -----------------------| Server reports results
     |\------------------------------------>|
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the destination file
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the source file
     |                                      |
     |                                      |
        ]]></artwork>
      </figure>
    </section>

    <section title="Inter-Server Copy">
      <t>
        A copy may also be performed between two servers. The copy
        protocol is designed to accommodate a variety of network
        topologies. As shown in <xref target="fig:inter-server" />,
        the client and servers may be connected by multiple networks.
        In particular, the servers may be connected by a specialized,
        high speed network (network 192.0.2.0/24 in the diagram)
        that does not include the client. The protocol allows the
        client to setup the copy between the servers (over network
        203.0.113.0/24 in the diagram) and for the servers to
        communicate on the high speed network if they choose to
        do so.
      </t>

      <figure title="An example inter-server network topology." anchor="fig:inter-server">
        <artwork><![CDATA[
                          192.0.2.0/24
              +-------------------------------------+
              |                                     |
              |                                     |
              | 192.0.2.18                          | 192.0.2.56
      +-------+------+                       +------+------+
      |     Source   |                       | Destination |
      +-------+------+                       +------+------+
              | 203.0.113.18                        | 203.0.113.56
              |                                     |
              |                                     |
              |             203.0.113.0/24          |
              +------------------+------------------+
                                 |
                                 |
                                 | 203.0.113.243
                           +-----+-----+
                           |   Client  |
                           +-----------+
        ]]></artwork>
      </figure>

      <t>
        For an inter-server copy, the client notifies the source
        server that a file will be copied by the destination
        server using a COPY_NOTIFY operation. The client then
        initiates the copy by sending the COPY operation to the
        destination server. The destination server may perform the
        copy synchronously or asynchronously.
      </t>

      <t>
        A synchronous inter-server copy is shown in
        <xref target="fig:sync-inter-server" />. In this case, the
        destination server chooses to perform the copy before
        responding to the client's COPY request.
      </t>

      <t>
        An asynchronous copy is shown in
        <xref target="fig:async-inter-server" />. In this case, the
        destination server chooses to respond to the client's COPY
        request immediately and then perform the copy
        asynchronously.
      </t>

      <figure title="A synchronous inter-server copy." anchor="fig:sync-inter-server">
        <artwork><![CDATA[
  Client                Source         Destination
     +                    +                 +
     |                    |                 |
     |--- OPEN        --->|                 | Returns os1
     |<------------------/|                 |
     |                    |                 |
     |--- COPY_NOTIFY --->|                 |
     |<------------------/|                 |
     |                    |                 |
     |--- OPEN ---------------------------->| Returns os2
     |<------------------------------------/|
     |                    |                 |
     |--- COPY ---------------------------->|
     |                    |                 |
     |                    |                 |
     |                    |<----- read -----|
     |                    |\--------------->|
     |                    |                 |
     |                    |        .        | Multiple reads may
     |                    |        .        | be necessary
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |<------------------------------------/| Destination replies
     |                    |                 | to COPY
     |                    |                 |
     |--- CLOSE --------------------------->| Release open state
     |<------------------------------------/|
     |                    |                 |
     |--- CLOSE       --->|                 | Release open state
     |<------------------/|                 |
        ]]></artwork>
      </figure>

      <figure title="An asynchronous inter-server copy." anchor="fig:async-inter-server">
        <artwork><![CDATA[
  Client                Source         Destination
    +                    +                 +
    |                    |                 |
    |--- OPEN        --->|                 | Returns os1
    |<------------------/|                 |
    |                    |                 |
    |--- LOCK        --->|                 | Optional, could be done
    |<------------------/|                 | with a share lock
    |                    |                 |
    |--- COPY_NOTIFY --->|                 | Need to pass in
    |<------------------/|                 | os1 or lock state
    |                    |                 |
    |                    |                 |
    |                    |                 |
    |--- OPEN ---------------------------->| Returns os2
    |<------------------------------------/|
    |                    |                 |
    |--- LOCK ---------------------------->| Optional ...
    |<------------------------------------/|
    |                    |                 |
    |--- COPY ---------------------------->| Need to pass in
    |<------------------------------------/| os2 or lock state
    |                    |                 |
    |                    |                 |
    |                    |<----- read -----|
    |                    |\--------------->|
    |                    |                 |
    |                    |        .        | Multiple reads may
    |                    |        .        | be necessary
    |                    |        .        |
    |                    |                 |
    |                    |                 |
    |--- OFFLOAD_STATUS ------------------>| Client may poll
    |<------------------------------------/| for status
    |                    |                 |
    |                    |        .        | Multiple OFFLOAD_STATUS
    |                    |        .        | operations may be sent
    |                    |        .        |
    |                    |                 |
    |                    |                 |
    |                    |                 |
    |<-- CB_OFFLOAD -----------------------| Destination reports
    |\------------------------------------>| results
    |                    |                 |
    |--- LOCKU --------------------------->| Only if LOCK was done
    |<------------------------------------/|
    |                    |                 |
    |--- CLOSE --------------------------->| Release open state
    |<------------------------------------/|
    |                    |                 |
    |--- LOCKU       --->|                 | Only if LOCK was done
    |<------------------/|                 |
    |                    |                 |
    |--- CLOSE       --->|                 | Release open state
    |<------------------/|                 |
    |                    |                 |
        ]]></artwork>
      </figure>
    </section>

    <section title="Server-to-Server Copy Protocol" anchor="server-to-server-proto">
      <t>
        The source server and
        destination server are not required to use a specific protocol to
        transfer the file data. The choice of what protocol to use
        is ultimately the destination server's decision.
      </t>

      <section title="Using NFSv4.x as a Server-to-Server Copy Protocol">
        <t>
          The destination server MAY use standard NFSv4.x (where x >= 1)
          to read the data from the source server. If NFSv4.x is used
          for the server-to-server copy protocol, the destination server
          can use the filehandle contained in the COPY request with
          standard NFSv4.x operations to read data
          from the source server. Specifically, the destination
          server may use the NFSv4.x OPEN operation's CLAIM_FH
          facility to open the file being copied and obtain an
          open stateid. Using the stateid, the destination server
          may then use NFSv4.x READ operations to read the file.
        </t>
      </section>

      <section title="Using an alternative Server-to-Server Copy Protocol">
        <t>
          In a homogeneous environment, the source and destination servers
          might be able to perform the file copy extremely efficiently using
          specialized protocols. For example the source and destination
          servers might be two nodes sharing a common file system format for
          the source and destination file systems. Thus the source and destination
          are in an ideal position to efficiently render the image of the source
          file to the destination file by replicating the file system formats
          at the block level. Another possibility is that the source and
          destination might be two nodes sharing a common storage area network,
          and thus there is no need to copy any data at all, and instead
          ownership of the file and its contents might simply be re-assigned
          to the destination. To allow for these possibilities, the destination
          server is allowed to use a server-to-server copy protocol of its choice.
        </t>

        <t>
          In a heterogeneous environment, using a protocol other than NFSv4.x
          (e.g., HTTP <xref target="RFC2616" /> or FTP <xref target="RFC0959" />)
          presents some challenges. In particular, the destination
          server is presented with the challenge of accessing the source file
          given only an NFSv4.x filehandle.
        </t>

        <t>
          One option for protocols that identify source files with path names
          is to use an ASCII hexadecimal representation of the source filehandle
          as the file name.
        </t>

        <t>
          Another option for the source server is to use URLs to direct the
          destination server to a specialized service. For example, the response
          to COPY_NOTIFY could include the URL ftp://s1.example.com:9999/_FH/0x12345,
          where 0x12345 is the ASCII hexadecimal representation of the source
          filehandle. When the destination server receives the source server's
          URL, it would use "_FH/0x12345" as the file name to pass to the FTP
          server listening on port 9999 of s1.example.com. On port
          9999 there would be a special instance of the FTP service that
          understands how to convert NFS filehandles to an open file descriptor
          (in many operating systems, this would require a new system call, one
          which is the inverse of the makefh() function that the pre-NFSv4 MOUNT
          service needs).
        </t>

        <t>
          Authenticating and identifying the destination server to the source
          server is also a challenge. Recommendations for how to accomplish
          this are given in <xref target="server-to-server-no-rpc-with-gss" />
          and <xref target="server-to-server-no-rpc-no-gss" />.
        </t>
      </section>
    </section>
  </section>

  <section title="Requirements for Operations" anchor="operations">
    <t>
      The implementation of server-side copy is OPTIONAL by the
      client and the server. However, in order to successfully copy
      a file, some operations MUST be supported by the client and/or
      server.
    </t>

    <t>
      If a client desires an intra-server file copy, then it MUST
      support the COPY and CB_OFFLOAD operations. If COPY returns a
      stateid, then the client MAY use the OFFLOAD_ABORT and OFFLOAD_STATUS
      operations.
    </t>

    <t>
      If a client desires an inter-server file copy, then it MUST
      support the COPY, COPY_NOTICE, and CB_OFFLOAD operations, and
      MAY use the OFFLOAD_REVOKE operation. If COPY returns a stateid,
      then the client MAY use the OFFLOAD_ABORT and OFFLOAD_STATUS
      operations.
    </t>

    <t>
      If a server supports intra-server copy, then the server MUST
      support the COPY operation. If a server’s COPY operation
      returns a stateid, then the server MUST also support these operations:
      CB_OFFLOAD, OFFLOAD_ABORT, and OFFLOAD_STATUS.
    </t>

    <t>
      If a source server supports inter-server copy, then the source
      server MUST support all these operations: COPY_NOTIFY and
      OFFLOAD_REVOKE. If a destination server supports inter-server
      copy, then the destination server MUST support the COPY
      operation. If a destination server’s COPY operation returns
      a stateid, then the destination server MUST also support these
      operations: CB_OFFLOAD, OFFLOAD_ABORT, COPY_NOTIFY, OFFLOAD_REVOKE,
      and OFFLOAD_STATUS.
    </t>

    <t>
      Each operation is performed in the context of the user identified
      by the ONC RPC credential of its containing COMPOUND or CB_COMPOUND
      request. For example, a OFFLOAD_ABORT operation issued by a given user
      indicates that a specified COPY operation initiated by the same user
      be canceled. Therefore a OFFLOAD_ABORT MUST NOT interfere with a copy
      of the same file initiated by another user.
    </t>

    <t>
      An NFS server MAY allow an administrative user to monitor or cancel
      copy operations using an implementation specific interface.
    </t>

    <section title="netloc4 - Network Locations">
      <t>
        The server-side copy operations specify network locations using
        the netloc4 data type shown below:
      </t>

      <?rfc include='autogen/type_netloc_type4.xml'?>

      <t>
        If the netloc4 is of type NL4_NAME, the nl_name field MUST be
        specified as a UTF-8 string. The nl_name is expected to be
        resolved to a network address via DNS, LDAP, NIS, /etc/hosts,
        or some other means. If the netloc4 is of type NL4_URL, a
        server URL <xref target="RFC3986" /> appropriate for the
        server-to-server copy operation is specified as a UTF-8 string.
        If the netloc4 is of type NL4_NETADDR, the nl_addr field MUST
        contain a valid netaddr4 as defined in Section 3.3.9 of
        <xref target="RFC5661" />.
      </t>

      <t>
        When netloc4 values are used for an inter-server copy as
        shown in <xref target="fig:inter-server" />, their values
        may be evaluated on the source server, destination server,
        and client. The network environment in which these systems
        operate should be configured so that the netloc4 values
        are interpreted as intended on each system.
      </t>
    </section>

    <section title="Copy Offload Stateids" anchor="ss:copy:stateid">
      <t>
        A server may perform a copy offload operation asynchronously.  An
        asynchronous copy is tracked using a copy offload stateid.  Copy
        offload stateids are included in the COPY, OFFLOAD_ABORT,
        OFFLOAD_STATUS, and CB_OFFLOAD operations.
      </t>

      <t>
        Section 8.2.4 of <xref target="RFC5661" /> specifies that
        stateids are valid until either (A) the client or server
        restart or (B) the client returns the resource.
      </t>

      <t>
        A copy offload stateid will be valid until either (A) the client or
        server restarts or (B) the client returns the resource by issuing a
        OFFLOAD_ABORT operation or the client replies to a CB_OFFLOAD
        operation.
      </t>

      <t>
        A copy offload stateid's seqid MUST NOT be 0.  In the context of a
        copy offload operation, it is ambiguous to indicate the most recent
        copy offload operation using a stateid with seqid of 0.  Therefore a
        copy offload stateid with seqid of 0 MUST be considered invalid.
      </t>
    </section>
  </section>

  <section anchor="ss:copy:security" title="Security Considerations">
    <t>
      The security considerations pertaining to NFSv4 <xref target="I-D.ietf-nfsv4-rfc3530bis" />
      apply to this chapter.
    </t>

    <t>
      The standard security mechanisms provide by NFSv4 <xref target="I-D.ietf-nfsv4-rfc3530bis" />
      may be used to secure the protocol described in this chapter.
    </t>

    <t>
      NFSv4 clients and servers supporting the inter-server copy
      operations described in this chapter are REQUIRED to implement the
      mechanism described in <xref target="server-to-server-with-rpc">,
      and to support rejecting COPY_NOTIFY requests that do not use
      RPCSEC_GSS with privacy.  This requirement to implement is not
      a requirement to use; for example, a server may depending on
      configuration also allow COPY_NOTIFY requests that use only AUTH_SYS.
    </t>

    <section title="Inter-Server Copy Security" anchor="server-to-server-sec">
      <section title="Requirements for Secure Inter-Server Copy">
        <t>
          Inter-server copy is driven by several requirements:
        </t>

        <t>
          <list style="symbols">
            <t>
              The specification must not mandate an inter-server copy
              protocol. There are many ways to copy data. Some will be
              more optimal than others depending on the identities of
              the source server and destination server. For example
              the source and destination servers might be two nodes sharing
              a common file system format for the source and destination
              file systems. Thus the source and destination are in an
              ideal position to efficiently render the image of the source
              file to the destination file by replicating
              the file system formats at the block level. In other cases, the
              source and destination might be two nodes
              sharing a common storage area network, and thus there is no
              need to copy any data at all, and instead
              ownership of the file and its contents simply gets re-assigned
              to the destination.
            </t>

            <t>
              The specification must provide guidance for using NFSv4.x as
              a copy protocol. For those source and destination servers
              willing to use NFSv4.x there are specific security considerations
              that this specification can and does address.
            </t>

            <t>
              The specification must not mandate pre-configuration between the
              source and destination server. Requiring that the source and
              destination first have a "copying relationship" increases the
              administrative burden. However the specification MUST NOT
              preclude implementations that require pre-configuration.
            </t>

            <t>
              The specification must not mandate a trust relationship between
              the source and destination server. The NFSv4 security model
              requires mutual authentication between a principal on an NFS
              client and a principal on an NFS server. This model MUST continue
              with the introduction of COPY.
            </t>
          </list>
        </t>
      </section>

      <section title="Inter-Server Copy via ONC RPC"
       anchor="server-to-server-with-rpc">
        <t>
          In the absence of a strong security mechanism designed for the
	  purpose, the challenge is how the source server
          and destination server identify themselves to each other,
          especially in the presence of multi-homed source and
          destination servers. In a multi-homed environment, the
          destination server might not contact the source server
          from the same network address specified by the client
          in the COPY_NOTIFY. This can be overcome using the
          procedure described below.
        </t>

        <t>
          When the client sends the source server the COPY_NOTIFY operation,
          the source server may reply to the client with a list of target
          addresses, names, and/or URLs and assign them to the unique quadruple:
          &lt;random number, source fh, user ID, destination address Y&gt;.  If the destination
          uses one of these target netlocs to contact the source server, the source
          server will be able to uniquely identify the destination server, even
          if the destination server does not connect from the address specified
          by the client in COPY_NOTIFY.  The level of assurance in this identification
          depends on the unpredictability, strength and secrecy of the random number.
        </t>

        <t>
          For example, suppose the network topology is as shown in
          <xref target="fig:inter-server" />.  If the source filehandle
          is 0x12345, the source server may respond to a COPY_NOTIFY
          for destination 203.0.113.56 with the URLs:
        </t>

        <t>
          <list style="empty">
            <t>nfs://203.0.113.18//_COPY/FvhH1OKbu8VrxvV1erdjvR7N/203.0.113.56/_FH/0x12345</t>
            <t>nfs://192.0.2.18//_COPY/FvhH1OKbu8VrxvV1erdjvR7N/203.0.113.56/_FH/0x12345</t>
          </list>
        </t>

        <t>
          The name component after _COPY is 24 characters of base 64, more than enough
          to encode a 128 bit random number.
        </t>

        <t>
          The client will then send these URLs to the destination server
          in the COPY operation. Suppose that the 192.0.2.0/24 network
          is a high speed network and the destination server decides to
          transfer the file over this network. If the destination
          contacts the source server from 192.0.2.56 over this network
          using NFSv4.1, it does the following:
        </t>

        <t>
          <list style="hanging">
            <t hangText="COMPOUND"> { PUTROOTFH, LOOKUP "_COPY" ;
              LOOKUP "FvhH1OKbu8VrxvV1erdjvR7N" ;
              LOOKUP "203.0.113.56";
              LOOKUP "_FH" ; OPEN "0x12345" ; GETFH }
            </t>
          </list>
        </t>

        <t>
          Provided that the random number is unpredictable and has been kept secret
          by the parties involved, the source server will therefore know that these
          NFSv4.x operations are being issued by the destination server identified
          in the COPY_NOTIFY.  This random number technique only provides initial
          authentication of the destination server, and cannot defend against
          man-in-the-middle attacks after authentication or an eavesdropper that
          observes the random number on the wire. Other secure communication
          techniques (e.g., IPsec) are necessary to block these attacks.
        </t>

	<t>
	  Servers SHOULD reject COPY_NOTIFY requests that do not use
	  RPCSEC_GSS with privacy, thus ensuring the URL in the
	  COPY_NOTIFY reply is encrypted.  For the same reason, clients
	  SHOULD send COPY requests to the destination using RPCSEC_GSS
	  with privacy.
	</t>
      </section>

      <section title="Inter-Server Copy without ONC RPC and RPCSEC_GSSv3"
         anchor="server-to-server-no-rpc-no-gss">
        <t>
          The same techniques as <xref target="server-to-server-with-rpc-no-gss" />,
          using unique URLs for each destination server, can be used for other
          protocols (e.g., HTTP <xref target="RFC2616" /> and FTP <xref target="RFC0959" />)
          as well.
        </t>
      </section>
    </section>
  </section>
</section>
