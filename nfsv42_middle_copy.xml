<section anchor="sec:copy" title="NFS Server-side Copy">
  <section title="Introduction">
    <t>
      This document describes a server-side copy feature for
      the NFS protocol.
    </t>

    <t>
      The server-side copy feature provides a mechanism for
      the NFS client to perform a file copy on the server without
      the data being transmitted back and forth over the network.
    </t>

    <t>
      Without this feature, an NFS client copies data from one location
      to another by reading the data from the server over the network, and
      then writing the data back over the network to the server. Using this
      server-side copy operation, the client is able to instruct the server
      to copy the data locally without the data being sent back and forth
      over the network unnecessarily.
    </t>

    <t>
      In general, this feature is useful whenever data is copied
      from one location to another on the server. It is particularly useful
      when copying the contents of a file from a backup. Backup-versions
      of a file are copied for a number of reasons, including restoring
      and cloning data.
    </t>

    <t>
      If the source object and destination object are on different file
      servers, the file servers will communicate with one another to
      perform the copy operation. The server-to-server protocol by which
      this is accomplished is not defined in this document.
    </t>
  </section>

  <section title="Protocol Overview">
    <t>
      The server-side copy offload operations support both intra-server and
      inter-server file copies. An intra-server copy is a copy in which the
      source file and destination file reside on the same server. In an
      inter-server copy, the source file and destination file are on
      different servers. In both cases, the copy may be performed
      synchronously or asynchronously.
    </t>

    <t>
      Throughout the rest of this document, we refer to the NFS
      server containing the source file as the "source server"
      and the NFS server to which the file is transferred as the
      "destination server". In the case of an intra-server copy,
      the source server and destination server are the same server.
      Therefore in the context of an intra-server copy, the terms
      source server and destination server refer to the
      single server performing the copy.
    </t>

    <t>
      The operations described below are designed to copy files. Other
      file system objects can be copied by building on these operations
      or using other techniques. For example if the user wishes to copy
      a directory, the client can synthesize a directory copy by first
      creating the destination directory and then copying the source
      directory's files to the new destination directory. If the user
      wishes to copy a namespace junction <xref target="FEDFS-NSDB"/>
      <xref target="FEDFS-ADMIN"/>, the client can use the ONC RPC
      Federated Filesystem protocol <xref target="FEDFS-ADMIN"/> to
      perform the copy. Specifically the client can determine the
      source junction's attributes using the FEDFS_LOOKUP_FSN procedure
      and create a duplicate junction using the FEDFS_CREATE_JUNCTION
      procedure.
    </t>

    <t>
      For the inter-server copy protocol, the operations are defined
      to be compatible with a server-to-server copy protocol in which
      the destination server reads the file data from the source server.
      This model in which the file data is pulled from the source by the
      destination has a number of advantages over a model in which the
      source pushes the file data to the destination. The advantages
      of the pull model include:
    </t>

    <t>
      <list style="symbols">
        <t>
          The pull model only requires a remote server (i.e., the destination
          server) to be granted read access. A push model requires a
          remote server (i.e., the source server) to be granted write
          access, which is more privileged.
        </t>

        <t>
          The pull model allows the destination server to stop reading
          if it has run out of space. In a push model, the destination
          server must flow control the source server in this situation.
        </t>

        <t>
          The pull model allows the destination server to easily flow
          control the data stream by adjusting the size of its read
          operations. In a push model, the destination server does not
          have this ability. The source server in a push model is capable
          of writing chunks larger than the destination server has
          requested in attributes and session parameters. In theory, the
          destination server could perform a "short" write in this situation,
          but this approach is known to behave poorly in practice.
        </t>
      </list>
    </t>

    <t>
      The following operations are provided to support server-side copy:
    </t>

    <t>
      <list style="hanging">
        <t hangText="COPY_NOTIFY:">
          For inter-server copies, the client sends
          this operation to the source server to notify it of a future
          file copy from a given destination server for the given user.
        </t>

        <t hangText="COPY_REVOKE:">
          Also for inter-server copies, the client
          sends this operation to the source server to revoke permission
          to copy a file for the given user.
        </t>

        <t hangText="COPY:">
          Used by the client to request a file copy.
        </t>

        <t hangText="COPY_ABORT:">
          Used by the client to abort an asynchronous file copy.
        </t>

        <t hangText="COPY_STATUS:">
          Used by the client to poll the status of
          an asynchronous file copy.
        </t>

        <t hangText="CB_COPY:">
          Used by the destination server to report the
          results of an asynchronous file copy to the client.
        </t>
      </list>
    </t>

    <t>
      These operations are described in detail in <xref target="operations"/>.
      This section provides an overview of how these operations are used
      to perform server-side copies.
    </t>

    <section title="Intra-Server Copy">
      <t>
        To copy a file on a single server, the client uses a COPY operation.
        The server may respond to the copy operation with the final results of
        the copy or it may perform the copy asynchronously and deliver the
        results using a CB_COPY operation callback. If the copy is performed
        asynchronously, the client may poll the status of the copy using
        COPY_STATUS or cancel the copy using COPY_ABORT.
      </t>

      <t>
        A synchronous intra-server copy is shown in
        <xref target="sync-intra-server-fig"/>. In this example, the NFS
        server chooses to perform the copy synchronously. The copy operation
        is completed, either successfully or unsuccessfully, before the
        server replies to the client's request. The server's reply contains
        the final result of the operation.
      </t>

      <figure title="A synchronous intra-server copy." anchor="sync-intra-server-fig">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |                                      |
        ]]></artwork>
      </figure>

      <t>
        An asynchronous intra-server copy is shown in
        <xref target="async-intra-server-fig"/>. In this example, the NFS
        server performs the copy asynchronously. The server's reply to
        the copy request indicates that the copy operation was initiated
        and the final result will be delivered at a later time. The server's
        reply also contains a copy stateid. The client may use this copy
        stateid to poll for status information (as shown) or to cancel the copy
        using a COPY_ABORT. When the server completes the copy, the server
        performs a callback to the client and reports the results.
      </t>

      <figure title="An asynchronous intra-server copy." anchor="async-intra-server-fig">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |                                      |
     |--- COPY_STATUS --------------------->| Client may poll
     |<------------------------------------/| for status
     |                                      |
     |                  .                   | Multiple COPY_STATUS
     |                  .                   | operations may be sent.
     |                  .                   |
     |                                      |
     |<-- CB_COPY --------------------------| Server reports results
     |\------------------------------------>|
     |                                      |
        ]]></artwork>
      </figure>
    </section>

    <section title="Inter-Server Copy">
      <t>
        A copy may also be performed between two servers. The copy
        protocol is designed to accommodate a variety of network
        topologies. As shown in <xref target="inter-server-fig"/>,
        the client and servers may be connected by multiple networks.
        In particular, the servers may be connected by a specialized,
        high speed network (network 192.168.33.0/24 in the diagram)
        that does not include the client. The protocol allows the
        client to setup the copy between the servers (over network
        10.11.78.0/24 in the diagram) and for the servers to
        communicate on the high speed network if they choose to
        do so.
      </t>

      <figure title="An example inter-server network topology." anchor="inter-server-fig">
        <artwork><![CDATA[
                          192.168.33.0/24
              +-------------------------------------+
              |                                     |
              |                                     |
              | 192.168.33.18                       | 192.168.33.56
      +-------+------+                       +------+------+
      |     Source   |                       | Destination |
      +-------+------+                       +------+------+
              | 10.11.78.18                         | 10.11.78.56
              |                                     |
              |                                     |
              |             10.11.78.0/24           |
              +------------------+------------------+
                                 |
                                 |
                                 | 10.11.78.243
                           +-----+-----+
                           |   Client  |
                           +-----------+
        ]]></artwork>
      </figure>

      <t>
        For an inter-server copy, the client notifies the source
        server that a file will be copied by the destination
        server using a COPY_NOTIFY operation. The client then
        initiates the copy by sending the COPY operation to the
        destination server. The destination server may perform the
        copy synchronously or asynchronously.
      </t>

      <t>
        A synchronous inter-server copy is shown in
        <xref target="sync-inter-server-fig"/>. In this case, the
        destination server chooses to perform the copy before
        responding to the client's COPY request.
      </t>

      <t>
        An asynchronous copy is shown in
        <xref target="async-inter-server-fig"/>. In this case, the
        destination server chooses to respond to the client's COPY
        request immediately and then perform the copy
        asynchronously.
      </t>

      <figure title="A synchronous inter-server copy." anchor="sync-inter-server-fig">
        <artwork><![CDATA[
  Client                Source         Destination
     +                    +                 +
     |                    |                 |
     |--- COPY_NOTIFY --->|                 |
     |<------------------/|                 |
     |                    |                 |
     |                    |                 |
     |--- COPY ---------------------------->|
     |                    |                 |
     |                    |                 |
     |                    |<----- read -----|
     |                    |\--------------->|
     |                    |                 |
     |                    |        .        | Multiple reads may
     |                    |        .        | be necessary
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |<------------------------------------/| Destination replies
     |                    |                 | to COPY
        ]]></artwork>
      </figure>

      <figure title="An asynchronous inter-server copy." anchor="async-inter-server-fig">
        <artwork><![CDATA[
  Client                Source         Destination
     +                    +                 +
     |                    |                 |
     |--- COPY_NOTIFY --->|                 |
     |<------------------/|                 |
     |                    |                 |
     |                    |                 |
     |--- COPY ---------------------------->|
     |<------------------------------------/|
     |                    |                 |
     |                    |                 |
     |                    |<----- read -----|
     |                    |\--------------->|
     |                    |                 |
     |                    |        .        | Multiple reads may
     |                    |        .        | be necessary
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |--- COPY_STATUS --------------------->| Client may poll
     |<------------------------------------/| for status
     |                    |                 |
     |                    |        .        | Multiple COPY_STATUS
     |                    |        .        | operations may be sent
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |                    |                 |
     |<-- CB_COPY --------------------------| Destination reports
     |\------------------------------------>| results
     |                    |                 |
        ]]></artwork>
      </figure>
    </section>

    <section title="Server-to-Server Copy Protocol" anchor="server-to-server-proto">
      <t>
        During an inter-server copy, the destination server reads
        the file data from the source server. The source server and
        destination server are not required to use a specific protocol to
        transfer the file data. The choice of what protocol to use
        is ultimately the destination server's decision.
      </t>

      <section title="Using NFSv4.x as a Server-to-Server Copy Protocol">
        <t>
          The destination server MAY use standard NFSv4.x (where x >= 1)
          to read the data from the source server. If NFSv4.x is used
          for the server-to-server copy protocol, the destination server
          can use the filehandle contained in the COPY request with
          standard NFSv4.x operations to read data
          from the source server. Specifically, the destination
          server may use the NFSv4.x OPEN operation's CLAIM_FH
          facility to open the file being copied and obtain an
          open stateid. Using the stateid, the destination server
          may then use NFSv4.x READ operations to read the file.
        </t>
      </section>

      <section title="Using an alternative Server-to-Server Copy Protocol">
        <t>
          In a homogeneous environment, the source and destination servers
          might be able to perform the file copy extremely efficiently using
          specialized protocols. For example the source and destination
          servers might be two nodes sharing a common file system format for
          the source and destination file systems. Thus the source and destination
          are in an ideal position to efficiently render the image of the source
          file to the destination file by replicating the file system formats
          at the block level. Another possibility is that the source and
          destination might be two nodes sharing a common storage area network,
          and thus there is no need to copy any data at all, and instead
          ownership of the file and its contents might simply be re-assigned
          to the destination. To allow for these possibilities, the destination
          server is allowed to use a server-to-server copy protocol of its choice.
        </t>

        <t>
          In a heterogeneous environment, using a protocol other than NFSv4.x
          (e.g,. HTTP <xref target="RFC2616"/> or FTP <xref target="RFC0959"/>)
          presents some challenges. In particular, the destination
          server is presented with the challenge of accessing the source file
          given only an NFSv4.x filehandle.
        </t>

        <t>
          One option for protocols that identify source files with path names
          is to use an ASCII hexadecimal representation of the source filehandle
          as the file name.
        </t>

        <t>
          Another option for the source server is to use URLs to direct the
          destination server to a specialized service. For example, the response
          to COPY_NOTIFY could include the URL ftp://s1.example.com:9999/_FH/0x12345,
          where 0x12345 is the ASCII hexadecimal representation of the source
          filehandle. When the destination server receives the source server's
          URL, it would use "_FH/0x12345" as the file name to pass to the FTP
          server listening on port 9999 of s1.example.com. On port
          9999 there would be a special instance of the FTP service that
          understands how to convert NFS filehandles to an open file descriptor
          (in many operating systems, this would require a new system call, one
          which is the inverse of the makefh() function that the pre-NFSv4 MOUNT
          service needs).
        </t>

        <t>
          Authenticating and identifying the destination server to the source
          server is also a challenge. Recommendations for how to accomplish
          this are given in <xref target="server-to-server-no-rpc-with-gss"/>
          and <xref target="server-to-server-no-rpc-no-gss"/>.
        </t>
      </section>
    </section>
  </section>

  <section title="Operations" anchor="operations">
    <t>
      In the sections that follow, several operations are defined that
      together provide the server-side copy feature. These operations
      are intended to be OPTIONAL operations as defined in section 17 of
      <xref target="RFC5661"/>. The COPY_NOTIFY, COPY_REVOKE, COPY, COPY_ABORT,
      and COPY_STATUS operations are designed to be sent within an NFSv4
      COMPOUND procedure. The CB_COPY operation is designed to be sent
      within an NFSv4 CB_COMPOUND procedure.
    </t>

    <t>
      Each operation is performed in the context of the user identified
      by the ONC RPC credential of its containing COMPOUND or CB_COMPOUND
      request. For example, a COPY_ABORT operation issued by a given user
      indicates that a specified COPY operation initiated by the same user
      be canceled. Therefore a COPY_ABORT MUST NOT interfere with a copy
      of the same file initiated by another user.
    </t>

    <t>
      An NFS server MAY allow an administrative user to monitor or cancel
      copy operations using an implementation specific interface.
    </t>

    <section title="netloc4 - Network Locations">
      <t>
        The server-side copy operations specify network locations using
        the netloc4 data type shown below:
      </t>

      <?rfc include='autogen/type_netloc_type4.xml'?>

      <t>
        If the netloc4 is of type NL4_NAME, the nl_name field MUST be
        specified as a UTF-8 string. The nl_name is expected to be
        resolved to a network address via DNS, LDAP, NIS, /etc/hosts,
        or some other means. If the netloc4 is of type NL4_URL, a
        server URL <xref target="RFC3986"/> appropriate for the
        server-to-server copy operation is specified as a UTF-8 string.
        If the netloc4 is of type NL4_NETADDR, the nl_addr field MUST
        contain a valid netaddr4 as defined in Section 3.3.9 of
        <xref target="RFC5661"/>.
      </t>

      <t>
        When netloc4 values are used for an inter-server copy as
        shown in <xref target="inter-server-fig"/>, their values
        may be evaluated on the source server, destination server,
        and client. The network environment in which these systems
        operate should be configured so that the netloc4 values
        are interpreted as intended on each system.
      </t>
    </section>

    <section title="Operation 61: COPY_NOTIFY - Notify a source server of a future copy">
      <section title="ARGUMENT">
        <?rfc include='autogen/copy_notify_args.xml'?>
      </section>

      <section title="RESULT">
        <?rfc include='autogen/copy_notify_res.xml'?>
      </section>

      <section title="DESCRIPTION">
        <t>
          This operation is used for an inter-server copy. A client
          sends this operation in a COMPOUND request to the source
          server to authorize a destination server identified by
          cna_destination_server to read the file specified by
          CURRENT_FH on behalf of the given user.
        </t>

        <t>
          The cna_destination_server MUST be specified using the
          netloc4 network location format. The server is not required
          to resolve the cna_destination_server address before completing
          this operation.
        </t>

        <t>
          If this operation succeeds, the source server will allow the
          cna_destination_server to copy the specified file on behalf
          of the given user. If COPY_NOTIFY succeeds, the destination
          server is granted permission to read the file as long as both
          of the following conditions are met:
        </t>

        <t>
          <list style="symbols">
            <t>
              The destination server begins reading the source file
              before the cnr_lease_time expires. If the cnr_lease_time
              expires while the destination server is still reading
              the source file, the destination server is allowed to
              finish reading the file.
            </t>

            <t>
              The client has not issued a COPY_REVOKE for
              the same combination of user, filehandle,
              and destination server.
            </t>
          </list>
        </t>

        <t>
          The cnr_lease_time is chosen by the source server. A
          cnr_lease_time of 0 (zero) indicates an infinite lease. To
          renew the copy lease time the client should resend the same
          copy notification request to the source server.
        </t>

        <t>
          To avoid the need for synchronized clocks, copy lease times
          are granted by the server as a time delta. However, there is a
          requirement that the client and server clocks do not drift
          excessively over the duration of the lease. There is also the
          issue of propagation delay across the network which could easily
          be several hundred milliseconds as well as the possibility that
          requests will be lost and need to be retransmitted.
        </t>

        <t>
          To take propagation delay into account, the client should
          subtract it from copy lease times (e.g., if the client estimates
          the one-way propagation delay as 200 milliseconds, then it can
          assume that the lease is already 200 milliseconds old when it gets
          it). In addition, it will take another 200 milliseconds to get a
          response back to the server. So the client must send a lease
          renewal or send the copy offload request to the cna_destination_server
          at least 400 milliseconds before the copy lease would expire. If
          the propagation delay varies over the life of the lease (e.g., the
          client is on a mobile host), the client will need to continuously
          subtract the increase in propagation delay from the copy lease times.
        </t>

        <t>
          The server's copy lease period configuration should take into
          account the network distance of the clients that will be
          accessing the server's resources. It is expected that the lease
          period will take into account the network propagation delays and
          other network delay factors for the client population. Since the
          protocol does not allow for an automatic method to determine an
          appropriate copy lease period, the server's administrator may have
          to tune the copy lease period.
        </t>

        <t>
          A successful response will also contain a list of names, addresses,
          and URLs called cnr_source_server, on which the source is willing to
          accept connections from the destination. These might not be reachable
          from the client and might be located on networks to which the client
          has no connection.
        </t>

        <t>
          If the client wishes to perform an inter-server copy, the client
          MUST send a COPY_NOTIFY to the source server. Therefore, the source
          server MUST support COPY_NOTIFY.
        </t>

        <t>
          For a copy only involving one server (the source and destination
          are on the same server), this operation is unnecessary.
        </t>

        <t>
          The COPY_NOTIFY operation may fail for the following reasons
          (this is a partial list):
        </t>

        <t>
          <list style="hanging">
            <t hangText="NFS4ERR_MOVED:">
              The file system which contains the source file
              is not present on the source server. The client can determine the
              correct location and reissue the operation with the correct location.
            </t>

            <t hangText="NFS4ERR_NOTSUPP:">
              The copy offload operation is not supported by
              the NFS server receiving this request.
            </t>

            <t hangText="NFS4ERR_WRONGSEC:">
              The security mechanism being used by the client
              does not match the server's security policy.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Operation 62: COPY_REVOKE - Revoke a destination server's copy privileges">

      <section title="ARGUMENT">
        <?rfc include='autogen/copy_revoke_args.xml'?>
      </section>

      <section title="RESULT">
        <?rfc include='autogen/copy_revoke_res.xml'?>
      </section>

      <section title="DESCRIPTION">
        <t>
          This operation is used for an inter-server copy. A client sends this
          operation in a COMPOUND request to the source server to revoke the
          authorization of a destination server identified by
          cra_destination_server from
          reading the file specified by CURRENT_FH on behalf of given user. If the
          cra_destination_server has already begun copying the file, a successful
          return from this operation indicates that further access will be prevented.
        </t>

        <t>
          The cra_destination_server MUST be specified using the
          netloc4 network location format. The server is not required
          to resolve the cra_destination_server address before completing
          this operation.
        </t>

        <t>
          The COPY_REVOKE operation is useful in situations in which the
          source server granted a very long or infinite lease on the
          destination server's ability to read the source file and
          all copy operations on the source file have been completed.
        </t>

        <t>
          For a copy only involving one server (the source and destination
          are on the same server), this operation is unnecessary.
        </t>

        <t>
          If the server supports COPY_NOTIFY, the server is
          REQUIRED to support the COPY_REVOKE operation.
        </t>

        <t>
          The COPY_REVOKE operation may fail for the following reasons
          (this is a partial list):
        </t>

        <t>
          <list style="hanging">

            <t hangText="NFS4ERR_MOVED:">
              The file system which contains the source file
              is not present on the source server. The client can determine the correct
              location and reissue the operation with the correct location.
            </t>

            <t hangText="NFS4ERR_NOTSUPP:">
              The copy offload operation is not supported by
              the NFS server receiving this request.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Operation 59: COPY - Initiate a server-side copy">
      <section title="ARGUMENT">
        <?rfc include='autogen/copy_args.xml'?>
      </section>

      <section title="RESULT">
        <?rfc include='autogen/copy_res.xml'?>
      </section>

      <section title="DESCRIPTION">
        <t>
          The COPY operation is used for both intra- and inter-server
          copies. In both cases, the COPY is always sent from the client
          to the destination server of the file copy. The COPY operation
          requests that a file be copied from the location specified by the
          SAVED_FH value to the location specified by the combination of
          CURRENT_FH and ca_destination.
        </t>

        <t>
          The SAVED_FH must be a regular file. If SAVED_FH is not a
          regular file, the operation MUST fail and return NFS4ERR_WRONG_TYPE.
        </t>

        <t>
          In order to set SAVED_FH to the source file handle,
          the compound procedure requesting the COPY will
          include a sub-sequence of operations such as
        </t>

        <figure>
          <artwork>
   PUTFH source-fh
   SAVEFH
          </artwork>
        </figure>

        <t>
          If the request is for a server-to-server copy, the source-fh
          is a filehandle from the source server and the compound
          procedure is being executed on the destination server. In
          this case, the source-fh is a foreign filehandle on the
          server receiving the COPY request. If either PUTFH or
          SAVEFH checked the validity of the filehandle, the operation
          would likely fail and return NFS4ERR_STALE.
        </t>

        <t>
          In order to avoid this problem, the minor version incorporating
          the COPY operations will need to make a few small changes in
          the handling of existing operations. If a server supports the
          server-to-server COPY feature, a PUTFH followed by a SAVEFH
          MUST NOT return NFS4ERR_STALE for either operation. These
          restrictions do not pose substantial difficulties for
          servers. The CURRENT_FH and SAVED_FH may be validated in the
          context of the operation referencing them and an NFS4ERR_STALE
          error returned for an invalid file handle at that point.
        </t>

        <t>
          The CURRENT_FH and ca_destination together specify the
          destination of the copy operation. If ca_destination
          is of 0 (zero) length, then CURRENT_FH specifies the target file.
          In this case, CURRENT_FH MUST be a regular file and not a directory.
          If ca_destination is not of 0 (zero) length, the ca_destination
          argument specifies the file name to which the data will be copied
          within the directory identified by CURRENT_FH. In this case,
          CURRENT_FH MUST be a directory and not a regular file.
        </t>

        <t>
          If the file named by ca_destination does not exist and the operation
          completes successfully, the file will be visible in the file system
          namespace. If the file does not exist and the operation fails, the
          file MAY be visible in the file system namespace depending on when
          the failure occurs and on the implementation of the NFS server
          receiving the COPY operation. If the ca_destination name
          cannot be created in the destination file system (due to
          file name restrictions, such as case or length), the operation
          MUST fail.
        </t>

        <t>
          The ca_src_offset is the offset within the source file from
          which the data will be read, the ca_dst_offset is the offset
          within the destination file to which the data will be
          written, and the ca_count is the number of bytes that will be
          copied. An offset of 0 (zero) specifies the start of the file. A
          count of 0 (zero) requests that all bytes from ca_src_offset
          through EOF be copied to the destination. If concurrent modifications
          to the source file overlap with the source file region being copied,
          the data copied may include all, some, or none of the
          modifications. The client can use standard NFS operations (e.g., OPEN with
          OPEN4_SHARE_DENY_WRITE or mandatory byte range locks) to protect against
          concurrent modifications if the client is concerned about this. If the
          source file's end of file is being modified in parallel with a copy that
          specifies a count of 0 (zero) bytes, the amount of data copied is
          implementation dependent (clients may guard against this case by specifying
          a non-zero count value or preventing modification of the source file as
          mentioned above).
        </t>

        <t>
          If the source offset or the source offset plus count is
          greater than or equal to the size of the source file, the
          operation will fail with NFS4ERR_INVAL. The destination
          offset or destination offset plus count may be greater than
          the size of the destination file. This allows for the client
          to issue parallel copies to implement operations such as
          "cat file1 file2 file3 file4 > dest".
        </t>

        <t>
          If the destination file is created as a result of this command, the
          destination file's size will be equal to the number of bytes
          successfully copied. If the destination file already existed, the
          destination file's size may increase as a result of this operation
          (e.g. if ca_dst_offset plus ca_count is greater than the destination's
          initial size).
        </t>

        <t>
          If the ca_source_server list is specified, then this is an inter-server
          copy operation and the source file is on a remote server.  The client
          is expected to have previously issued a successful COPY_NOTIFY request
          to the remote source server. The ca_source_server list SHOULD be the
          same as the COPY_NOTIFY response's cnr_source_server list. If the client
          includes the entries from the COPY_NOTIFY response's cnr_source_server
          list in the ca_source_server list, the source server can indicate a
          specific copy protocol for the destination server to use by returning
          a URL, which specifies both a protocol service and server name.
          Server-to-server copy protocol considerations are described in
          <xref target="server-to-server-proto"/> and
          <xref target="server-to-server-sec"/>.
        </t>

        <t>
          The ca_flags argument allows the copy operation to be
          customized in the following ways using the guarded flag
          (COPY4_GUARDED) and the metadata flag (COPY4_METADATA).
        </t>

        <t>
          [NOTE: Earlier versions of this document defined a
          COPY4_SPACE_RESERVED flag for controlling space
          reservations on the destination file. This flag has been
          removed with the expectation that the space_reserve
          attribute defined in XXX_TDH_XXX
          will be adopted.]
        </t>

        <t>
          If the guarded flag is set and the destination exists on the
          server, this operation will fail with NFS4ERR_EXIST.
        </t>

        <t>
          If the guarded flag is not set and the destination exists
          on the server, the behavior is implementation dependent.
        </t>

        <t>
          If the metadata flag is set and the client is requesting a
          whole file copy (i.e., ca_count is 0 (zero)), a subset of
          the destination file's attributes MUST be the same as the
          source file's corresponding attributes and a subset of
          the destination file's attributes SHOULD be the same as
          the source file's corresponding attributes. The attributes
          in the MUST and SHOULD copy subsets will be defined for each
          NFS version.
        </t>

        <t>
          For NFSv4.1, <xref target="req_attr_tbl"/> and
          <xref target="rec_attr_tbl"/> list the REQUIRED and
          RECOMMENDED attributes respectively. A "MUST" in the
          "Copy to destination file?" column indicates that the
          attribute is part of the MUST copy set. A "SHOULD" in
          the "Copy to destination file?" column indicates that
          the attribute is part of the SHOULD copy set.
        </t>

        <texttable anchor="req_attr_tbl">
          <ttcol align='left' >Name</ttcol>
          <ttcol align='left' >Id</ttcol>
          <ttcol align='left' >Copy to destination file?</ttcol>

          <c>supported_attrs</c>   <c>0</c> <c>no</c>
          <c>type</c>              <c>1</c> <c>MUST</c>
          <c>fh_expire_type</c>    <c>2</c> <c>no</c>
          <c>change</c>            <c>3</c> <c>SHOULD</c>
          <c>size</c>              <c>4</c> <c>MUST</c>
          <c>link_support</c>      <c>5</c> <c>no</c>
          <c>symlink_support</c>   <c>6</c> <c>no</c>
          <c>named_attr</c>        <c>7</c> <c>no</c>
          <c>fsid</c>              <c>8</c> <c>no</c>
          <c>unique_handles</c>    <c>9</c> <c>no</c>
          <c>lease_time</c>        <c>10</c><c>no</c>
          <c>rdattr_error</c>      <c>11</c><c>no</c>
          <c>filehandle</c>        <c>19</c><c>no</c>
          <c>suppattr_exclcreat</c><c>75</c><c>no</c>
        </texttable>

        <texttable anchor="rec_attr_tbl">
          <ttcol align='left' >Name</ttcol>
          <ttcol align='left' >Id</ttcol>
          <ttcol align='left' >Copy to destination file?</ttcol>

          <c>acl</c>               <c>12</c><c>MUST</c>
          <c>aclsupport</c>        <c>13</c><c>no</c>
          <c>archive</c>           <c>14</c><c>no</c>
          <c>cansettime</c>        <c>15</c><c>no</c>
          <c>case_insensitive</c>  <c>16</c><c>no</c>
          <c>case_preserving</c>   <c>17</c><c>no</c>
          <c>change_policy</c>     <c>60</c><c>no</c>
          <c>chown_restricted</c>  <c>18</c><c>MUST</c>
          <c>dacl</c>              <c>58</c><c>MUST</c>
          <c>dir_notif_delay</c>   <c>56</c><c>no</c>
          <c>dirent_notif_delay</c><c>57</c><c>no</c>
          <c>fileid</c>            <c>20</c><c>no</c>
          <c>files_avail</c>       <c>21</c><c>no</c>
          <c>files_free</c>        <c>22</c><c>no</c>
          <c>files_total</c>       <c>23</c><c>no</c>
          <c>fs_charset_cap</c>    <c>76</c><c>no</c>
          <c>fs_layout_type</c>    <c>62</c><c>no</c>
          <c>fs_locations</c>      <c>24</c><c>no</c>
          <c>fs_locations_info</c> <c>67</c><c>no</c>
          <c>fs_status</c>         <c>61</c><c>no</c>
          <c>hidden</c>            <c>25</c><c>MUST</c>
          <c>homogeneous</c>       <c>26</c><c>no</c>
          <c>layout_alignment</c>  <c>66</c><c>no</c>
          <c>layout_blksize</c>    <c>65</c><c>no</c>
          <c>layout_hint</c>       <c>63</c><c>no</c>
          <c>layout_type</c>       <c>64</c><c>no</c>
          <c>maxfilesize</c>       <c>27</c><c>no</c>
          <c>maxlink</c>           <c>28</c><c>no</c>
          <c>maxname</c>           <c>29</c><c>no</c>
          <c>maxread</c>           <c>30</c><c>no</c>
          <c>maxwrite</c>          <c>31</c><c>no</c>
          <c>mdsthreshold</c>      <c>68</c><c>no</c>
          <c>mimetype</c>          <c>32</c><c>MUST</c>
          <c>mode</c>              <c>33</c><c>MUST</c>
          <c>mode_set_masked</c>   <c>74</c><c>no</c>
          <c>mounted_on_fileid</c> <c>55</c><c>no</c>
          <c>no_trunc</c>          <c>34</c><c>no</c>
          <c>numlinks</c>          <c>35</c><c>no</c>
          <c>owner</c>             <c>36</c><c>MUST</c>
          <c>owner_group</c>       <c>37</c><c>MUST</c>
          <c>quota_avail_hard</c>  <c>38</c><c>no</c>
          <c>quota_avail_soft</c>  <c>39</c><c>no</c>
          <c>quota_used</c>        <c>40</c><c>no</c>
          <c>rawdev</c>            <c>41</c><c>no</c>
          <c>retentevt_get</c>     <c>71</c><c>MUST</c>
          <c>retentevt_set</c>     <c>72</c><c>no</c>
          <c>retention_get</c>     <c>69</c><c>MUST</c>
          <c>retention_hold</c>    <c>73</c><c>MUST</c>
          <c>retention_set</c>     <c>70</c><c>no</c>
          <c>sacl</c>              <c>59</c><c>MUST</c>
          <c>space_avail</c>       <c>42</c><c>no</c>
          <c>space_free</c>        <c>43</c><c>no</c>
          <c>space_total</c>       <c>44</c><c>no</c>
          <c>space_used</c>        <c>45</c><c>no</c>
          <c>system</c>            <c>46</c><c>MUST</c>
          <c>time_access</c>       <c>47</c><c>MUST</c>
          <c>time_access_set</c>   <c>48</c><c>no</c>
          <c>time_backup</c>       <c>49</c><c>no</c>
          <c>time_create</c>       <c>50</c><c>MUST</c>
          <c>time_delta</c>        <c>51</c><c>no</c>
          <c>time_metadata</c>     <c>52</c><c>SHOULD</c>
          <c>time_modify</c>       <c>53</c><c>MUST</c>
          <c>time_modify_set</c>   <c>54</c><c>no</c>
        </texttable>

        <t>
          [NOTE: The space_reserve attribute XXX_TDH_XXX
           will be in the MUST set.]
        </t>

        <t>
          [NOTE: The source file's attribute values will take precedence
          over any attribute values inherited by the destination file.]
        </t>

        <t>
          In the case of an inter-server copy or an intra-server copy
          between file systems, the attributes supported for the source
          file and destination file could be different. By definition,the
          REQUIRED attributes will be supported in all cases. If the
          metadata flag is set and the source file has a RECOMMENDED
          attribute that is not supported for the destination file, the
          copy MUST fail with NFS4ERR_ATTRNOTSUPP.
        </t>

        <t>
          Any attribute supported by the destination server that is not
          set on the source file SHOULD be left unset.
        </t>

        <t>
          Metadata attributes not exposed via the NFS protocol SHOULD
          be copied to the destination file where appropriate.
        </t>

        <t>
          The destination file's named attributes are not duplicated
          from the source file. After the copy process completes, the
          client MAY attempt to duplicate named attributes using standard
          NFSv4 operations. However, the destination file's named
          attribute capabilities MAY be different from the source
          file's named attribute capabilities.
        </t>

        <t>
          If the metadata flag is not set and the client is requesting a
          whole file copy (i.e., ca_count is 0 (zero)), the destination
          file's metadata is implementation dependent.
        </t>

        <t>
          If the client is requesting a partial file copy (i.e., ca_count
          is not 0 (zero)), the client SHOULD NOT set the metadata flag
          and the server MUST ignore the metadata flag.
        </t>

        <t>
          If the operation does not result in an immediate failure, the
          server will return NFS4_OK, and the CURRENT_FH will remain
          the destination's filehandle.
        </t>

        <t>
          If an immediate failure does occur, cr_bytes_copied will be
          set to the number of bytes copied to the destination file before
          the error occurred. The cr_bytes_copied value indicates the number
          of bytes copied but not which specific bytes have been copied.
        </t>

        <t>
          A return of NFS4_OK indicates that either the operation is
          complete or the operation was initiated and a callback will
          be used to deliver the final status of the operation.
        </t>

        <t>
          If the cr_callback_id is returned, this indicates that the operation
          was initiated and a CB_COPY callback will deliver the final results
          of the operation. The cr_callback_id stateid is termed a copy stateid
          in this context. The server is given the option of returning the
          results in a callback because the data may require a relatively long
          period of time to copy.
        </t>

        <t>
          If no cr_callback_id is returned, the operation completed synchronously
          and no callback will be issued by the server. The completion status of
          the operation is indicated by cr_status.
        </t>

        <t>
          If the copy completes successfully, either synchronously or
          asynchronously, the data copied from the source file to the destination
          file MUST appear identical to the NFS client. However, the NFS server's
          on disk representation of the data in the source file and destination file
          MAY differ. For example, the NFS server might encrypt, compress,
          deduplicate, or otherwise represent the on disk data in the source and
          destination file differently.
        </t>

        <t>
          In the event of a failure the state of the destination file is
          implementation dependent. The COPY operation may fail for the following
          reasons (this is a partial list).
        </t>

        <t>
          <list style="hanging">

            <t hangText="NFS4ERR_MOVED:">
              The file system which contains the
              source file, or the destination file or directory is not present.
              The client can determine the correct location and reissue the
              operation with the correct location.
            </t>

            <t hangText="NFS4ERR_NOTSUPP:">
              The copy offload operation is not supported by
              the NFS server receiving this request.
            </t>

            <t hangText="NFS4ERR_PARTNER_NOTSUPP:">
              The remote server does not support the
              server-to-server copy offload protocol.
            </t>

            <t hangText="NFS4ERR_PARTNER_NO_AUTH:">
              The remote server does not authorize
              a server-to-server copy offload operation. This may be due to the
              client's failure to send the COPY_NOTIFY operation to the remote server,
              the remote server receiving a server-to-server copy offload request
              after the copy lease time expired, or for some other permission problem.
            </t>

            <t hangText="NFS4ERR_FBIG:">
              The copy operation would have caused the file
              to grow beyond the server's limit.
            </t>

            <t hangText="NFS4ERR_NOTDIR:">
              The CURRENT_FH is a file and ca_destination
              has non-zero length.
            </t>

            <t hangText="NFS4ERR_WRONG_TYPE:">
              The SAVED_FH is not a regular file.
            </t>

            <t hangText="NFS4ERR_ISDIR:">
              The CURRENT_FH is a directory and ca_destination
              has zero length.
            </t>

            <t hangText="NFS4ERR_INVAL:">
              The source offset or offset plus count are
              greater than or equal to the size of the source file.
            </t>

            <t hangText="NFS4ERR_DELAY:">
              The server does not have the resources to
              perform the copy operation at the current time. The client should
              retry the operation sometime in the future.
            </t>

            <t hangText="NFS4ERR_METADATA_NOTSUPP:">
              The destination file cannot
              support the same metadata as the source file.
            </t>

            <t hangText="NFS4ERR_WRONGSEC:">
              The security mechanism being used by the client
              does not match the server's security policy.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Operation 60: COPY_ABORT - Cancel a server-side copy">
      <section title="ARGUMENT">
        <?rfc include='autogen/copy_abort_args.xml'?>
      </section>

      <section title="RESULT">
        <?rfc include='autogen/copy_abort_res.xml'?>
      </section>

      <section title="DESCRIPTION">
        <t>
          COPY_ABORT is used for both intra- and inter-server
          asynchronous copies. The COPY_ABORT operation allows the client
          to cancel a server-side copy operation that it initiated. This operation
          is sent in a COMPOUND request from the client to the destination
          server. This operation may be used to cancel a copy when
          the application that requested the copy exits before the operation
          is completed or for some other reason.
        </t>

        <t>
          The request contains the filehandle and copy stateid cookies
          that act as the context for the previously initiated copy
          operation.
        </t>

        <t>
          The result's car_status field indicates whether the cancel
          was successful or not. A value of NFS4_OK indicates that the
          copy operation was canceled and no callback will be issued
          by the server. A copy operation that is successfully canceled
          may result in none, some, or all of the data copied.
        </t>

        <t>
          If the server supports asynchronous copies, the server is
          REQUIRED to support the COPY_ABORT operation.
        </t>

        <t>
          The COPY_ABORT operation may fail for the following reasons
          (this is a partial list):
        </t>

        <t>
          <list style="hanging">

            <t hangText="NFS4ERR_NOTSUPP:">
              The abort operation is not supported by
              the NFS server receiving this request.
            </t>

            <t hangText="NFS4ERR_RETRY:">
              The abort failed, but a retry
              at some time in the future MAY succeed.
            </t>

            <t hangText="NFS4ERR_COMPLETE_ALREADY:">
              The abort failed,
              and a callback will deliver the results of the copy
              operation.
            </t>

            <t hangText="NFS4ERR_SERVERFAULT:">
              An error occurred on the server
              that does not map to a specific error code.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Operation 63: COPY_STATUS - Poll for status of a server-side copy">
      <section title="ARGUMENT">
        <?rfc include='autogen/copy_status_args.xml'?>
      </section>

      <section title="RESULT">
        <?rfc include='autogen/copy_status_res.xml'?>
      </section>

      <section title="DESCRIPTION">
        <t>
          COPY_STATUS is used for both intra- and inter-server asynchronous
          copies. The COPY_STATUS operation allows the client to poll the
          server to determine the status of an asynchronous copy operation.
          This operation is sent by the client to the destination server.
        </t>

        <t>
          If this operation is successful, the number of bytes copied are
          returned to the client in the csr_bytes_copied field. The
          csr_bytes_copied value indicates the number of bytes copied but
          not which specific bytes have been copied.
        </t>

        <t>
          If the optional csr_complete field is present, the copy has
          completed. In this case the status value indicates the result
          of the asynchronous copy operation. In all cases, the server will
          also deliver the final results of the asynchronous copy in a
          CB_COPY operation.
        </t>

        <t>
          The failure of this operation does not indicate the result of
          the asynchronous copy in any way.
        </t>

        <t>
          If the server supports asynchronous copies, the server is
          REQUIRED to support the COPY_STATUS operation.
        </t>

        <t>
          The COPY_STATUS operation may fail for the following reasons
          (this is a partial list):
        </t>

        <t>
          <list style="hanging">

            <t hangText="NFS4ERR_NOTSUPP:">
              The copy status operation is not supported by
              the NFS server receiving this request.
            </t>

            <t hangText="NFS4ERR_BAD_STATEID:">
              The stateid is not valid (see <xref target="copy_stateid"/> below).
            </t>

            <t hangText="NFS4ERR_EXPIRED:">
              The stateid has expired (see Copy Offload Stateid section below).
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Operation 15: CB_COPY - Report results of a server-side copy">
      <section title="ARGUMENT">
        <?rfc include='autogen/cb_copy_args.xml'?>
      </section>

      <section title="RESULT">
        <?rfc include='autogen/cb_copy_res.xml'?>
      </section>

      <section title="DESCRIPTION">
        <t>
          CB_COPY is used for both intra- and inter-server asynchronous
          copies. The CB_COPY callback informs the client of the result of
          an asynchronous server-side copy. This operation is sent by the
          destination server to the client in a CB_COMPOUND request. The
          copy is identified by the filehandle and stateid arguments. The result
          is indicated by the status field. If the copy failed, cca_bytes_copied
          contains the number of bytes copied before the failure occurred.
          The cca_bytes_copied value indicates the number of bytes copied
          but not which specific bytes have been copied.
        </t>

        <t>
          In the absence of an established backchannel, the server
          cannot signal the completion of the COPY via a CB_COPY callback.
          The loss of a callback channel would be indicated by the server
          setting the SEQ4_STATUS_CB_PATH_DOWN flag in the sr_status_flags
          field of the SEQUENCE operation. The client must re-establish the
          callback channel to receive the status of the COPY operation.
          Prolonged loss of the callback channel could result in the server
          dropping the COPY operation state and invalidating the copy stateid.
        </t>

        <t>
          If the client supports the COPY operation, the client is
          REQUIRED to support the CB_COPY operation.
        </t>

        <t>
          The CB_COPY operation may fail for the following reasons
          (this is a partial list):
        </t>

        <t>
          <list style="hanging">
            <t hangText="NFS4ERR_NOTSUPP:">
              The copy offload operation is not supported by
              the NFS client receiving this request.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Copy Offload Stateids" anchor="copy_stateid">
      <t>
        A server may perform a copy offload operation asynchronously. An
        asynchronous copy is tracked using a copy offload stateid. Copy
        offload stateids are included in the COPY, COPY_ABORT,
        COPY_STATUS, and CB_COPY operations.
      </t>

      <t>
        Section 8.2.4 of <xref target="RFC5661"/> specifies that stateids
        are valid until either (A) the client or server restart or (B)
        the client returns the resource.
      </t>

      <t>
        A copy offload stateid will be valid until either (A) the client
        or server restart or (B) the client returns the resource by
        issuing a COPY_ABORT operation or the client replies to a
        CB_COPY operation.
      </t>

      <t>
        A copy offload stateid's seqid MUST NOT be 0 (zero). In the
        context of a copy offload operation, it is ambiguous to indicate
        the most recent copy offload operation using a stateid with
        seqid of 0 (zero). Therefore a copy offload stateid with seqid
        of 0 (zero) MUST be considered invalid.
      </t>
    </section>
  </section>

  <section title="Security Considerations">
    <t>
      The security considerations pertaining to NFSv4 <xref target="RFC3530bis" />
      apply to this document.
    </t>

    <t>
      The standard security mechanisms provide by NFSv4 <xref target="RFC3530bis" />
      may be used to secure the protocol described in this document.
    </t>

    <t>
      NFSv4 clients and servers supporting the the inter-server copy
      operations described in this document are REQUIRED to implement
      <xref target="RPCSEC_GSSv3"/>, including the RPCSEC_GSSv3
      privileges copy_from_auth and copy_to_auth. If the server-to-server
      copy protocol is ONC RPC based, the servers are also REQUIRED to
      implement the RPCSEC_GSSv3 privilege copy_confirm_auth. These
      requirements to implement are not requirements to use. NFSv4 clients
      and servers are RECOMMENDED to use <xref target="RPCSEC_GSSv3"/>
      to secure server-side copy operations.
    </t>

    <section title="Inter-Server Copy Security" anchor="server-to-server-sec">
      <section title="Requirements for Secure Inter-Server Copy">
        <t>
          Inter-server copy is driven by several requirements:
        </t>

        <t>
          <list style="symbols">
            <t>
              The specification MUST NOT mandate an inter-server copy
              protocol. There are many ways to copy data. Some will be
              more optimal than others depending on the identities of
              the source server and destination server. For example
              the source and destination servers might be two nodes sharing
              a common file system format for the source and destination
              file systems. Thus the source and destination are in an
              ideal position to efficiently render the image of the source
              file to the destination file by replicating
              the file system formats at the block level. In other cases, the
              source and destination might be two nodes
              sharing a common storage area network, and thus there is no
              need to copy any data at all, and instead
              ownership of the file and its contents simply gets re-assigned
              to the destination.
            </t>

            <t>
              The specification MUST provide guidance for using NFSv4.x as
              a copy protocol. For those source and destination servers
              willing to use NFSv4.x there are specific security considerations
              that this specification can and does address.
            </t>

            <t>
              The specification MUST NOT mandate pre-configuration between the
              source and destination server. Requiring that the source and
              destination first have a "copying relationship" increases the
              administrative burden. However the specification MUST NOT
              preclude implementations that require pre-configuration.
            </t>

            <t>
              The specification MUST NOT mandate a trust relationship between
              the source and destination server. The NFSv4 security model
              requires mutual authentication between a principal on an NFS
              client and a principal on an NFS server. This model MUST continue
              with the introduction of COPY.
            </t>
          </list>
        </t>
      </section>

      <section title="Inter-Server Copy with RPCSEC_GSSv3">
        <t>
          When the client sends a COPY_NOTIFY to the source server to expect
          the destination to attempt to copy data from the source server, it
          is expected that this copy is being done on behalf of the principal
          (called the "user principal") that sent the RPC request that encloses
          the COMPOUND procedure that contains the COPY_NOTIFY operation. The
          user principal is identified by the RPC credentials. A mechanism that
          allows the user principal to authorize the destination server to perform
          the copy in a manner that lets the source server properly authenticate
          the destination's copy, and without allowing the destination to
          exceed its authorization is necessary.
        </t>

        <t>
          An approach that sends delegated credentials of the client's user
          principal to the destination server is not used for the following
          reasons. If the client's user delegated its credentials, the
          destination would authenticate as the user principal. If the
          destination were using the NFSv4 protocol to perform the copy,
          then the source server would authenticate the destination server
          as the user principal, and the file copy would securely proceed.
          However, this approach would allow the destination server to
          copy other files. The user principal would have to trust the
          destination server to not do so. This is counter to the requirements,
          and therefore is not considered. Instead an approach using
          RPCSEC_GSSv3 <xref target="RPCSEC_GSSv3"/> privileges is proposed.
        </t>

        <t>
          One of the stated applications of the proposed RPCSEC_GSSv3
          protocol is compound client host and user authentication
          [+ privilege assertion]. For inter-server file copy, we require
          compound NFS server host and user authentication
          [+ privilege assertion]. The distinction between the two is one
          without meaning.
        </t>

        <t>
          RPCSEC_GSSv3 introduces the notion of privileges. We define three privileges:
        </t>

        <t>
          <list style="hanging">

            <t hangText="copy_from_auth:">
              A user principal is authorizing a source principal
              ("nfs@&lt;source&gt;") to allow a destination principal
              ("nfs@&lt;destination&gt;") to copy a file from the source
              to the destination. This privilege is established on the
              source server before the user principal sends a COPY_NOTIFY
              operation to the source server.

              <vspace blankLines="1"/>
              <?rfc include='autogen/copy_from_auth.xml'?>
              <vspace blankLines="1"/>

              cap_shared_secret is a secret value the user
              principal generates.
            </t>

            <t hangText="copy_to_auth:">
              A user principal is authorizing a destination principal
              ("nfs@&lt;destination&gt;") to allow it to copy a file
              from the source to the destination. This privilege is
              established on the destination server before the user
              principal sends a COPY operation to the destination server.

              <vspace blankLines="1"/>
              <?rfc include='autogen/copy_to_auth.xml'?>
              <vspace blankLines="1"/>

              ctap_shared_secret is a secret value the user principal
              generated and was used to establish the copy_from_auth
              privilege with the source principal.
            </t>

            <t hangText="copy_confirm_auth:">
              A destination principal is confirming with the
              source principal that it is authorized to copy data
              from the source on behalf of the user principal. When
              the inter-server copy protocol is NFSv4, or for that
              matter, any protocol capable of being secured via
              RPCSEC_GSSv3 (i.e., any ONC RPC protocol), this privilege
              is established before the file is copied from the
              source to the destination.

              <vspace blankLines="1"/>
              <?rfc include='autogen/copy_confirm_auth.xml'?>
            </t>
          </list>
        </t>

        <section title="Establishing a Security Context">
          <t>
            When the user principal wants to COPY a file between two servers, if it has
            not established copy_from_auth and copy_to_auth privileges on the servers,
            it establishes them:
          </t>

          <t>
            <list style="symbols">

              <t>
                The user principal generates a secret it will share with the two
                servers. This shared secret will be placed in the cfap_shared_secret
                and ctap_shared_secret fields of the appropriate privilege data types,
                copy_from_auth_priv and copy_to_auth_priv.
              </t>

              <t>
                An instance of copy_from_auth_priv is filled in with the shared
                secret, the destination server, and the NFSv4 user id of the
                user principal. It will be sent with an RPCSEC_GSS3_CREATE
                procedure, and so cfap_seq_num is set to the seq_num of the
                credential of the RPCSEC_GSS3_CREATE procedure. Because
                cfap_shared_secret is a secret, after XDR encoding
                copy_from_auth_priv, GSS_Wrap() (with privacy) is invoked
                on copy_from_auth_priv. The RPCSEC_GSS3_CREATE procedure's
                arguments are:

                <vspace blankLines="1"/>

                <figure>
                  <artwork>
   struct {
      rpc_gss3_gss_binding    *compound_binding;
      rpc_gss3_chan_binding   *chan_binding_mic;
      rpc_gss3_assertion      assertions&lt;&gt;;
      rpc_gss3_extension      extensions&lt;&gt;;
   } rpc_gss3_create_args;
                 </artwork>
                </figure>

                <vspace blankLines="1"/>

                The string "copy_from_auth" is placed in assertions[0].privs. The
                output of GSS_Wrap() is placed in extensions[0].data. The field
                extensions[0].critical is set to TRUE. The source server calls
                GSS_Unwrap() on the privilege, and verifies that the seq_num matches
                the credential. It then verifies that the NFSv4 user id being asserted
                matches the source server's mapping of the user principal. If it
                does, the privilege is established on the source server as:
                &lt;"copy_from_auth", user id, destination&gt;. The successful
                reply to RPCSEC_GSS3_CREATE has:

                <vspace blankLines="1"/>

                <figure>
                  <artwork>
   struct {
      opaque                  handle&lt;&gt;;
      rpc_gss3_chan_binding   *chan_binding_mic;
      rpc_gss3_assertion      granted_assertions&lt;&gt;;
      rpc_gss3_assertion      server_assertions&lt;&gt;;
      rpc_gss3_extension      extensions&lt;&gt;;
   } rpc_gss3_create_res;
                  </artwork>
                </figure>

                <vspace blankLines="1"/>

                The field "handle" is the RPCSEC_GSSv3 handle that the client
                will use on COPY_NOTIFY requests involving the source and
                destination server. granted_assertions[0].privs will be equal to
                "copy_from_auth". The server will return a GSS_Wrap() of
                copy_to_auth_priv.
              </t>

              <t>
                An instance of copy_to_auth_priv is filled in with the
                shared secret, the source server, and the NFSv4 user id.
                It will be sent with an RPCSEC_GSS3_CREATE procedure, and
                so ctap_seq_num is set to the seq_num of the credential of
                the RPCSEC_GSS3_CREATE procedure. Because ctap_shared_secret
                is a secret, after XDR encoding copy_to_auth_priv,
                GSS_Wrap() is invoked on copy_to_auth_priv. The RPCSEC_GSS3_CREATE
                procedure's arguments are:

                <vspace blankLines="1"/>

                <figure>
                  <artwork>
   struct {
      rpc_gss3_gss_binding    *compound_binding;
      rpc_gss3_chan_binding   *chan_binding_mic;
      rpc_gss3_assertion      assertions&lt;&gt;;
      rpc_gss3_extension      extensions&lt;&gt;;
   } rpc_gss3_create_args;
                  </artwork>
                </figure>

                <vspace blankLines="1"/>

                The string "copy_to_auth" is placed in assertions[0].privs.
                The output of GSS_Wrap() is placed in extensions[0].data. The
                field extensions[0].critical is set to TRUE. After unwrapping,
                verifying the seq_num, and the user principal to NFSv4 user
                ID mapping, the destination establishes a privilege of
                &lt;"copy_to_auth", user id, source&gt;. The successful reply
                to RPCSEC_GSS3_CREATE has:

                <vspace blankLines="1"/>

                <figure>
                  <artwork>
   struct {
      opaque                  handle&lt;&gt;;
      rpc_gss3_chan_binding   *chan_binding_mic;
      rpc_gss3_assertion      granted_assertions&lt;&gt;;
      rpc_gss3_assertion      server_assertions&lt;&gt;;
      rpc_gss3_extension      extensions&lt;&gt;;
   } rpc_gss3_create_res;
                  </artwork>
                </figure>

                <vspace blankLines="1"/>

                The field "handle" is the RPCSEC_GSSv3 handle that the client will
                use on COPY requests involving the source and destination server.
                The field granted_assertions[0].privs will be equal to "copy_to_auth".
                The server will return a GSS_Wrap() of copy_to_auth_priv.
              </t>
            </list>
          </t>
        </section>

        <section title="Starting a Secure Inter-Server Copy">
          <t>
            When the client sends a COPY_NOTIFY request to the source server, it uses
            the privileged "copy_from_auth" RPCSEC_GSSv3 handle. cna_destination_server
            in COPY_NOTIFY MUST be the same as the name of the destination server
            specified in copy_from_auth_priv. Otherwise, COPY_NOTIFY will fail with
            NFS4ERR_ACCESS. The source server verifies that the privilege
            &lt;"copy_from_auth", user id, destination&gt; exists, and annotates it
            with the source filehandle, if the user principal has read
            access to the source file, and if administrative policies give the user
            principal and the NFS client read access to the source file (i.e., if the
            ACCESS operation would grant read access). Otherwise, COPY_NOTIFY will fail
            with NFS4ERR_ACCESS.
          </t>

          <t>
            When the client sends a COPY request to the destination server, it uses
            the privileged "copy_to_auth" RPCSEC_GSSv3 handle. ca_source_server in
            COPY MUST be the same as the name of the source server specified in
            copy_to_auth_priv. Otherwise, COPY will fail with NFS4ERR_ACCESS. The
            destination server verifies that the privilege
            &lt;"copy_to_auth", user id, source&gt; exists, and annotates it with the
            source and destination filehandles. If the client has failed to establish
            the "copy_to_auth" policy it will reject the request with
            NFS4ERR_PARTNER_NO_AUTH.
          </t>

          <t>
            If the client sends a COPY_REVOKE to the source server to rescind the
            destination server's copy privilege, it uses the privileged
            "copy_from_auth" RPCSEC_GSSv3 handle and the cra_destination_server
            in COPY_REVOKE MUST be the same as the name of the destination server
            specified in copy_from_auth_priv. The source server will then
            delete the &lt;"copy_from_auth", user id, destination&gt; privilege
            and fail any subsequent copy requests sent under the auspices of this
            privilege from the destination server.
          </t>
        </section>

        <section title="Securing ONC RPC Server-to-Server Copy Protocols">
          <t>
            After a destination server has a "copy_to_auth" privilege established on
            it, and it receives a COPY request, if it knows it will use an ONC RPC
            protocol to copy data, it will establish a "copy_confirm_auth" privilege
            on the source server, using nfs@&lt;destination&gt; as the initiator
            principal, and nfs@&lt;source&gt; as the target principal.
          </t>

          <t>
            The value of the field ccap_shared_secret_mic is a GSS_VerifyMIC() of
            the shared secret passed in the copy_to_auth privilege.  The field
            ccap_username is the mapping of the user principal to an NFSv4 user
            name ("user"@"domain" form), and MUST be the same as ctap_username
            and cfap_username. The field ccap_seq_num is the seq_num of the
            RPCSEC_GSSv3 credential used for the RPCSEC_GSS3_CREATE procedure
            the destination will send to the source server to establish the
            privilege.
          </t>

          <t>
            The source server verifies the privilege, and establishes a
            &lt;"copy_confirm_auth", user id, destination&gt; privilege. If the
            source server fails to verify the privilege, the COPY operation will
            be rejected with NFS4ERR_PARTNER_NO_AUTH. All subsequent ONC RPC
            requests sent from the destination to copy data from the source to
            the destination will use the RPCSEC_GSSv3 handle returned by the
            source's RPCSEC_GSS3_CREATE response.
          </t>

          <t>
            Note that the use of the "copy_confirm_auth" privilege
            accomplishes the following:
          </t>

          <t>
            <list style="symbols">
              <t>
                if a protocol like NFS is being used, with export policies,
                export policies can be overridden in case the destination server
                as-an-NFS-client is not authorized
              </t>

              <t>
                manual configuration to allow a copy relationship between the source
                and destination is not needed.
              </t>
            </list>
          </t>

          <t>
            If the attempt to establish a "copy_confirm_auth" privilege fails,
            then when the user principal sends a COPY request to destination,
            the destination server will reject it with NFS4ERR_PARTNER_NO_AUTH.
          </t>
        </section>

        <section title="Securing Non ONC RPC Server-to-Server Copy Protocols"
         anchor="server-to-server-no-rpc-with-gss">
          <t>
            If the destination won't be using ONC RPC to copy the data, then
            the source and destination are using an unspecified copy protocol.
            The destination could use the shared secret and the NFSv4 user id to
            prove to the source server that the user principal has authorized
            the copy.
          </t>

          <t>
            For protocols that authenticate user names with passwords
            (e.g., HTTP <xref target="RFC2616"/> and FTP <xref target="RFC0959"/>),
            the nfsv4 user id could be used as the user name, and an ASCII
            hexadecimal representation of the RPCSEC_GSSv3 shared secret could be
            used as the user password or as input into non-password authentication
            methods like CHAP <xref target="RFC1994"/>.
          </t>
        </section>
      </section>

      <section title="Inter-Server Copy via ONC RPC but without RPCSEC_GSSv3"
       anchor="server-to-server-with-rpc-no-gss">
        <t>
          ONC RPC security flavors other than RPCSEC_GSSv3 MAY be used with
          the server-side copy offload operations described in this
          document. In particular, host-based ONC RPC security flavors
          such as AUTH_NONE and AUTH_SYS MAY be used. If a host-based
          security flavor is used, a minimal level of protection for
          the server-to-server copy protocol is possible.
        </t>

        <t>
          In the absence of strong security mechanisms such as
          RPCSEC_GSSv3, the challenge is how the source server
          and destination server identify themselves to each other,
          especially in the presence of multi-homed source and
          destination servers. In a multi-homed environment, the
          destination server might not contact the source server
          from the same network address specified by the client
          in the COPY_NOTIFY. This can be overcome using the
          procedure described below.
        </t>

        <t>
          When the client sends the source server the COPY_NOTIFY
          operation, the source server may reply to the client with a
          list of target addresses, names, and/or URLs and assign them
          to the unique triple: &lt;source fh, user ID, destination address Y&gt;.
          If the destination uses one of these target netlocs to contact
          the source server, the source server will be able to uniquely
          identify the destination server, even if the destination server
          does not connect from the address specified by the client in
          COPY_NOTIFY.
        </t>

        <t>
          For example, suppose the network topology is as shown in
          <xref target="inter-server-fig"/>.  If the source filehandle
          is 0x12345, the source server may respond to a COPY_NOTIFY
          for destination 10.11.78.56 with the URLs:
        </t>

        <t>
          <list style="empty">
            <t> nfs://10.11.78.18//_COPY/10.11.78.56/_FH/0x12345 </t>
            <t> nfs://192.168.33.18//_COPY/10.11.78.56/_FH/0x12345 </t>
          </list>
        </t>

        <t>
          The client will then send these URLs to the destination server
          in the COPY operation. Suppose that the 192.168.33.0/24 network
          is a high speed network and the destination server decides to
          transfer the file over this network. If the destination
          contacts the source server from 192.168.33.56 over this network
          using NFSv4.1, it does the following:
        </t>

        <t>
          <list style="hanging">
            <t hangText="COMPOUND"> { PUTROOTFH, LOOKUP "_COPY" ; LOOKUP "10.11.78.56";
              LOOKUP "_FH" ; OPEN "0x12345" ; GETFH }
            </t>
          </list>
        </t>

        <t>
          The source server will therefore know that these NFSv4.1
          operations are being issued by the destination server identified
          in the COPY_NOTIFY.
        </t>
      </section>

      <section title="Inter-Server Copy without ONC RPC and RPCSEC_GSSv3"
         anchor="server-to-server-no-rpc-no-gss">
        <t>
          The same techniques as <xref target="server-to-server-with-rpc-no-gss"/>,
          using unique URLs for each destination server, can be used for other
          protocols (e.g., HTTP <xref target="RFC2616"/> and FTP <xref target="RFC0959"/>)
          as well.
        </t>
      </section>
    </section>
  </section>
</section>
