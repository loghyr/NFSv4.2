<!-- Copyright (C) The IETF Trust (2011) -->
<!-- Copyright (C) The Internet Society (2011) -->

<section anchor="sec:copy" title="NFS Server-side Copy">
  <section title="Introduction">
    <t>
      This section describes a server-side copy feature for
      the NFS protocol.
    </t>

    <t>
      The server-side copy feature provides a mechanism for
      the NFS client to perform a file copy on the server without
      the data being transmitted back and forth over the network.
    </t>

    <t>
      Without this feature, an NFS client copies data from one location
      to another by reading the data from the server over the network, and
      then writing the data back over the network to the server. Using this
      server-side copy operation, the client is able to instruct the server
      to copy the data locally without the data being sent back and forth
      over the network unnecessarily.
    </t>

    <t>
      In general, this feature is useful whenever data is copied
      from one location to another on the server. It is particularly useful
      when copying the contents of a file from a backup. Backup-versions
      of a file are copied for a number of reasons, including restoring
      and cloning data.
    </t>

    <t>
      If the source object and destination object are on different file
      servers, the file servers will communicate with one another to
      perform the copy operation. The server-to-server protocol by which
      this is accomplished is not defined in this document.
    </t>
  </section>

  <section title="Protocol Overview">
    <t>
      The server-side copy offload operations support both intra-server and
      inter-server file copies. An intra-server copy is a copy in which the
      source file and destination file reside on the same server. In an
      inter-server copy, the source file and destination file are on
      different servers. In both cases, the copy may be performed
      synchronously or asynchronously.
    </t>

    <t>
      Throughout the rest of this document, we refer to the NFS
      server containing the source file as the "source server"
      and the NFS server to which the file is transferred as the
      "destination server". In the case of an intra-server copy,
      the source server and destination server are the same server.
      Therefore in the context of an intra-server copy, the terms
      source server and destination server refer to the
      single server performing the copy.
    </t>

    <t>
      The operations described below are designed to copy files. Other
      file system objects can be copied by building on these operations
      or using other techniques. For example if the user wishes to copy
      a directory, the client can synthesize a directory copy by first
      creating the destination directory and then copying the source
      directory's files to the new destination directory. If the user
      wishes to copy a namespace junction <xref target="ref:FEDFS-NSDB" />
      <xref target="ref:FEDFS-ADMIN" />, the client can use the ONC RPC
      Federated Filesystem protocol <xref target="ref:FEDFS-ADMIN" /> to
      perform the copy. Specifically the client can determine the
      source junction's attributes using the FEDFS_LOOKUP_FSN procedure
      and create a duplicate junction using the FEDFS_CREATE_JUNCTION
      procedure.
    </t>

    <t>
      For the inter-server copy protocol, the operations are defined
      to be compatible with a server-to-server copy protocol in which
      the destination server reads the file data from the source server.
      This model in which the file data is pulled from the source by the
      destination has a number of advantages over a model in which the
      source pushes the file data to the destination. The advantages
      of the pull model include:
    </t>

    <t>
      <list style="symbols">
        <t>
          The pull model only requires a remote server (i.e., the destination
          server) to be granted read access. A push model requires a
          remote server (i.e., the source server) to be granted write
          access, which is more privileged.
        </t>

        <t>
          The pull model allows the destination server to stop reading
          if it has run out of space. In a push model, the destination
          server must flow control the source server in this situation.
        </t>

        <t>
          The pull model allows the destination server to easily flow
          control the data stream by adjusting the size of its read
          operations. In a push model, the destination server does not
          have this ability. The source server in a push model is capable
          of writing chunks larger than the destination server has
          requested in attributes and session parameters. In theory, the
          destination server could perform a "short" write in this situation,
          but this approach is known to behave poorly in practice.
        </t>
      </list>
    </t>

    <t>
      The following operations are provided to support server-side copy:
    </t>

    <t>
      <list style="hanging">
        <t hangText="COPY_NOTIFY:">
          For inter-server copies, the client sends
          this operation to the source server to notify it of a future
          file copy from a given destination server for the given user.
        </t>

        <t hangText="COPY_REVOKE:">
          Also for inter-server copies, the client
          sends this operation to the source server to revoke permission
          to copy a file for the given user.
        </t>

        <t hangText="COPY:">
          Used by the client to request a file copy.
        </t>

        <t hangText="COPY_ABORT:">
          Used by the client to abort an asynchronous file copy.
        </t>

        <t hangText="COPY_STATUS:">
          Used by the client to poll the status of
          an asynchronous file copy.
        </t>

        <t hangText="CB_COPY:">
          Used by the destination server to report the
          results of an asynchronous file copy to the client.
        </t>
      </list>
    </t>

    <t>
      These operations are described in detail in <xref target="operations" />.
      This section provides an overview of how these operations are used
      to perform server-side copies.
    </t>

    <section title="Intra-Server Copy">
      <t>
        To copy a file on a single server, the client uses a COPY operation.
        The server may respond to the copy operation with the final results of
        the copy or it may perform the copy asynchronously and deliver the
        results using a CB_COPY operation callback. If the copy is performed
        asynchronously, the client may poll the status of the copy using
        COPY_STATUS or cancel the copy using COPY_ABORT.
      </t>

      <t>
        A synchronous intra-server copy is shown in
        <xref target="sync-intra-server-fig" />. In this example, the NFS
        server chooses to perform the copy synchronously. The copy operation
        is completed, either successfully or unsuccessfully, before the
        server replies to the client's request. The server's reply contains
        the final result of the operation.
      </t>

      <figure title="A synchronous intra-server copy." anchor="sync-intra-server-fig">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |                                      |
        ]]></artwork>
      </figure>

      <t>
        An asynchronous intra-server copy is shown in
        <xref target="async-intra-server-fig" />. In this example, the NFS
        server performs the copy asynchronously. The server's reply to
        the copy request indicates that the copy operation was initiated
        and the final result will be delivered at a later time. The server's
        reply also contains a copy stateid. The client may use this copy
        stateid to poll for status information (as shown) or to cancel the copy
        using a COPY_ABORT. When the server completes the copy, the server
        performs a callback to the client and reports the results.
      </t>

      <figure title="An asynchronous intra-server copy." anchor="async-intra-server-fig">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |                                      |
     |--- COPY_STATUS --------------------->| Client may poll
     |<------------------------------------/| for status
     |                                      |
     |                  .                   | Multiple COPY_STATUS
     |                  .                   | operations may be sent.
     |                  .                   |
     |                                      |
     |<-- CB_COPY --------------------------| Server reports results
     |\------------------------------------>|
     |                                      |
        ]]></artwork>
      </figure>
    </section>

    <section title="Inter-Server Copy">
      <t>
        A copy may also be performed between two servers. The copy
        protocol is designed to accommodate a variety of network
        topologies. As shown in <xref target="inter-server-fig" />,
        the client and servers may be connected by multiple networks.
        In particular, the servers may be connected by a specialized,
        high speed network (network 192.168.33.0/24 in the diagram)
        that does not include the client. The protocol allows the
        client to setup the copy between the servers (over network
        10.11.78.0/24 in the diagram) and for the servers to
        communicate on the high speed network if they choose to
        do so.
      </t>

      <figure title="An example inter-server network topology." anchor="inter-server-fig">
        <artwork><![CDATA[
                          192.168.33.0/24
              +-------------------------------------+
              |                                     |
              |                                     |
              | 192.168.33.18                       | 192.168.33.56
      +-------+------+                       +------+------+
      |     Source   |                       | Destination |
      +-------+------+                       +------+------+
              | 10.11.78.18                         | 10.11.78.56
              |                                     |
              |                                     |
              |             10.11.78.0/24           |
              +------------------+------------------+
                                 |
                                 |
                                 | 10.11.78.243
                           +-----+-----+
                           |   Client  |
                           +-----------+
        ]]></artwork>
      </figure>

      <t>
        For an inter-server copy, the client notifies the source
        server that a file will be copied by the destination
        server using a COPY_NOTIFY operation. The client then
        initiates the copy by sending the COPY operation to the
        destination server. The destination server may perform the
        copy synchronously or asynchronously.
      </t>

      <t>
        A synchronous inter-server copy is shown in
        <xref target="sync-inter-server-fig" />. In this case, the
        destination server chooses to perform the copy before
        responding to the client's COPY request.
      </t>

      <t>
        An asynchronous copy is shown in
        <xref target="async-inter-server-fig" />. In this case, the
        destination server chooses to respond to the client's COPY
        request immediately and then perform the copy
        asynchronously.
      </t>

      <figure title="A synchronous inter-server copy." anchor="sync-inter-server-fig">
        <artwork><![CDATA[
  Client                Source         Destination
     +                    +                 +
     |                    |                 |
     |--- COPY_NOTIFY --->|                 |
     |<------------------/|                 |
     |                    |                 |
     |                    |                 |
     |--- COPY ---------------------------->|
     |                    |                 |
     |                    |                 |
     |                    |<----- read -----|
     |                    |\--------------->|
     |                    |                 |
     |                    |        .        | Multiple reads may
     |                    |        .        | be necessary
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |<------------------------------------/| Destination replies
     |                    |                 | to COPY
        ]]></artwork>
      </figure>

      <figure title="An asynchronous inter-server copy." anchor="async-inter-server-fig">
        <artwork><![CDATA[
  Client                Source         Destination
     +                    +                 +
     |                    |                 |
     |--- COPY_NOTIFY --->|                 |
     |<------------------/|                 |
     |                    |                 |
     |                    |                 |
     |--- COPY ---------------------------->|
     |<------------------------------------/|
     |                    |                 |
     |                    |                 |
     |                    |<----- read -----|
     |                    |\--------------->|
     |                    |                 |
     |                    |        .        | Multiple reads may
     |                    |        .        | be necessary
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |--- COPY_STATUS --------------------->| Client may poll
     |<------------------------------------/| for status
     |                    |                 |
     |                    |        .        | Multiple COPY_STATUS
     |                    |        .        | operations may be sent
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |                    |                 |
     |<-- CB_COPY --------------------------| Destination reports
     |\------------------------------------>| results
     |                    |                 |
        ]]></artwork>
      </figure>
    </section>

    <section title="Server-to-Server Copy Protocol" anchor="server-to-server-proto">
      <t>
        During an inter-server copy, the destination server reads
        the file data from the source server. The source server and
        destination server are not required to use a specific protocol to
        transfer the file data. The choice of what protocol to use
        is ultimately the destination server's decision.
      </t>

      <section title="Using NFSv4.x as a Server-to-Server Copy Protocol">
        <t>
          The destination server MAY use standard NFSv4.x (where x >= 1)
          to read the data from the source server. If NFSv4.x is used
          for the server-to-server copy protocol, the destination server
          can use the filehandle contained in the COPY request with
          standard NFSv4.x operations to read data
          from the source server. Specifically, the destination
          server may use the NFSv4.x OPEN operation's CLAIM_FH
          facility to open the file being copied and obtain an
          open stateid. Using the stateid, the destination server
          may then use NFSv4.x READ operations to read the file.
        </t>
      </section>

      <section title="Using an alternative Server-to-Server Copy Protocol">
        <t>
          In a homogeneous environment, the source and destination servers
          might be able to perform the file copy extremely efficiently using
          specialized protocols. For example the source and destination
          servers might be two nodes sharing a common file system format for
          the source and destination file systems. Thus the source and destination
          are in an ideal position to efficiently render the image of the source
          file to the destination file by replicating the file system formats
          at the block level. Another possibility is that the source and
          destination might be two nodes sharing a common storage area network,
          and thus there is no need to copy any data at all, and instead
          ownership of the file and its contents might simply be re-assigned
          to the destination. To allow for these possibilities, the destination
          server is allowed to use a server-to-server copy protocol of its choice.
        </t>

        <t>
          In a heterogeneous environment, using a protocol other than NFSv4.x
          (e.g,. HTTP <xref target="ref:RFC2616" /> or FTP <xref target="ref:RFC0959" />)
          presents some challenges. In particular, the destination
          server is presented with the challenge of accessing the source file
          given only an NFSv4.x filehandle.
        </t>

        <t>
          One option for protocols that identify source files with path names
          is to use an ASCII hexadecimal representation of the source filehandle
          as the file name.
        </t>

        <t>
          Another option for the source server is to use URLs to direct the
          destination server to a specialized service. For example, the response
          to COPY_NOTIFY could include the URL ftp://s1.example.com:9999/_FH/0x12345,
          where 0x12345 is the ASCII hexadecimal representation of the source
          filehandle. When the destination server receives the source server's
          URL, it would use "_FH/0x12345" as the file name to pass to the FTP
          server listening on port 9999 of s1.example.com. On port
          9999 there would be a special instance of the FTP service that
          understands how to convert NFS filehandles to an open file descriptor
          (in many operating systems, this would require a new system call, one
          which is the inverse of the makefh() function that the pre-NFSv4 MOUNT
          service needs).
        </t>

        <t>
          Authenticating and identifying the destination server to the source
          server is also a challenge. Recommendations for how to accomplish
          this are given in <xref target="server-to-server-no-rpc-with-gss" />
          and <xref target="server-to-server-no-rpc-no-gss" />.
        </t>
      </section>
    </section>
  </section>

  <section title="Operations" anchor="operations">
    <t>
      In the sections that follow, several operations are defined that
      together provide the server-side copy feature. These operations
      are intended to be OPTIONAL operations as defined in section 17 of
      <xref target="ref:RFC5661" />. The COPY_NOTIFY, COPY_REVOKE, COPY, COPY_ABORT,
      and COPY_STATUS operations are designed to be sent within an NFSv4
      COMPOUND procedure. The CB_COPY operation is designed to be sent
      within an NFSv4 CB_COMPOUND procedure.
    </t>

    <t>
      Each operation is performed in the context of the user identified
      by the ONC RPC credential of its containing COMPOUND or CB_COMPOUND
      request. For example, a COPY_ABORT operation issued by a given user
      indicates that a specified COPY operation initiated by the same user
      be canceled. Therefore a COPY_ABORT MUST NOT interfere with a copy
      of the same file initiated by another user.
    </t>

    <t>
      An NFS server MAY allow an administrative user to monitor or cancel
      copy operations using an implementation specific interface.
    </t>

    <section title="netloc4 - Network Locations">
      <t>
        The server-side copy operations specify network locations using
        the netloc4 data type shown below:
      </t>

      <?rfc include='autogen/type_netloc_type4.xml'?>

      <t>
        If the netloc4 is of type NL4_NAME, the nl_name field MUST be
        specified as a UTF-8 string. The nl_name is expected to be
        resolved to a network address via DNS, LDAP, NIS, /etc/hosts,
        or some other means. If the netloc4 is of type NL4_URL, a
        server URL <xref target="ref:RFC3986" /> appropriate for the
        server-to-server copy operation is specified as a UTF-8 string.
        If the netloc4 is of type NL4_NETADDR, the nl_addr field MUST
        contain a valid netaddr4 as defined in Section 3.3.9 of
        <xref target="ref:RFC5661" />.
      </t>

      <t>
        When netloc4 values are used for an inter-server copy as
        shown in <xref target="inter-server-fig" />, their values
        may be evaluated on the source server, destination server,
        and client. The network environment in which these systems
        operate should be configured so that the netloc4 values
        are interpreted as intended on each system.
      </t>
    </section>

    <section title="Copy Offload Stateids" anchor="copy_stateid">
      <t>
        A server may perform a copy offload operation asynchronously. An
        asynchronous copy is tracked using a copy offload stateid. Copy
        offload stateids are included in the COPY, COPY_ABORT,
        COPY_STATUS, and CB_COPY operations.
      </t>

      <t>
        Section 8.2.4 of <xref target="ref:RFC5661" /> specifies that stateids
        are valid until either (A) the client or server restart or (B)
        the client returns the resource.
      </t>

      <t>
        A copy offload stateid will be valid until either (A) the client
        or server restart or (B) the client returns the resource by
        issuing a COPY_ABORT operation or the client replies to a
        CB_COPY operation.
      </t>

      <t>
        A copy offload stateid's seqid MUST NOT be 0 (zero). In the
        context of a copy offload operation, it is ambiguous to indicate
        the most recent copy offload operation using a stateid with
        seqid of 0 (zero). Therefore a copy offload stateid with seqid
        of 0 (zero) MUST be considered invalid.
      </t>
    </section>
  </section>

  <section title="Security Considerations">
    <t>
      The security considerations pertaining to NFSv4 <xref target="ref:RFC3530bis" />
      apply to this document.
    </t>

    <t>
      The standard security mechanisms provide by NFSv4 <xref target="ref:RFC3530bis" />
      may be used to secure the protocol described in this document.
    </t>

    <t>
      NFSv4 clients and servers supporting the the inter-server copy
      operations described in this document are REQUIRED to implement
      <xref target="ref:rpcsecgssv3" />, including the RPCSEC_GSSv3
      privileges copy_from_auth and copy_to_auth. If the server-to-server
      copy protocol is ONC RPC based, the servers are also REQUIRED to
      implement the RPCSEC_GSSv3 privilege copy_confirm_auth. These
      requirements to implement are not requirements to use. NFSv4 clients
      and servers are RECOMMENDED to use <xref target="ref:rpcsecgssv3" />
      to secure server-side copy operations.
    </t>

    <section title="Inter-Server Copy Security" anchor="server-to-server-sec">
      <section title="Requirements for Secure Inter-Server Copy">
        <t>
          Inter-server copy is driven by several requirements:
        </t>

        <t>
          <list style="symbols">
            <t>
              The specification MUST NOT mandate an inter-server copy
              protocol. There are many ways to copy data. Some will be
              more optimal than others depending on the identities of
              the source server and destination server. For example
              the source and destination servers might be two nodes sharing
              a common file system format for the source and destination
              file systems. Thus the source and destination are in an
              ideal position to efficiently render the image of the source
              file to the destination file by replicating
              the file system formats at the block level. In other cases, the
              source and destination might be two nodes
              sharing a common storage area network, and thus there is no
              need to copy any data at all, and instead
              ownership of the file and its contents simply gets re-assigned
              to the destination.
            </t>

            <t>
              The specification MUST provide guidance for using NFSv4.x as
              a copy protocol. For those source and destination servers
              willing to use NFSv4.x there are specific security considerations
              that this specification can and does address.
            </t>

            <t>
              The specification MUST NOT mandate pre-configuration between the
              source and destination server. Requiring that the source and
              destination first have a "copying relationship" increases the
              administrative burden. However the specification MUST NOT
              preclude implementations that require pre-configuration.
            </t>

            <t>
              The specification MUST NOT mandate a trust relationship between
              the source and destination server. The NFSv4 security model
              requires mutual authentication between a principal on an NFS
              client and a principal on an NFS server. This model MUST continue
              with the introduction of COPY.
            </t>
          </list>
        </t>
      </section>

      <section title="Inter-Server Copy with RPCSEC_GSSv3">
        <t>
          When the client sends a COPY_NOTIFY to the source server to expect
          the destination to attempt to copy data from the source server, it
          is expected that this copy is being done on behalf of the principal
          (called the "user principal") that sent the RPC request that encloses
          the COMPOUND procedure that contains the COPY_NOTIFY operation. The
          user principal is identified by the RPC credentials. A mechanism that
          allows the user principal to authorize the destination server to perform
          the copy in a manner that lets the source server properly authenticate
          the destination's copy, and without allowing the destination to
          exceed its authorization is necessary.
        </t>

        <t>
          An approach that sends delegated credentials of the client's user
          principal to the destination server is not used for the following
          reasons. If the client's user delegated its credentials, the
          destination would authenticate as the user principal. If the
          destination were using the NFSv4 protocol to perform the copy,
          then the source server would authenticate the destination server
          as the user principal, and the file copy would securely proceed.
          However, this approach would allow the destination server to
          copy other files. The user principal would have to trust the
          destination server to not do so. This is counter to the requirements,
          and therefore is not considered. Instead an approach using
          RPCSEC_GSSv3 <xref target="ref:rpcsecgssv3" /> privileges is proposed.
        </t>

        <t>
          One of the stated applications of the proposed RPCSEC_GSSv3
          protocol is compound client host and user authentication
          [+ privilege assertion]. For inter-server file copy, we require
          compound NFS server host and user authentication
          [+ privilege assertion]. The distinction between the two is one
          without meaning.
        </t>

        <t>
          RPCSEC_GSSv3 introduces the notion of privileges. We define three privileges:
        </t>

        <t>
          <list style="hanging">

            <t hangText="copy_from_auth:">
              A user principal is authorizing a source principal
              ("nfs@&lt;source&gt;") to allow a destination principal
              ("nfs@&lt;destination&gt;") to copy a file from the source
              to the destination. This privilege is established on the
              source server before the user principal sends a COPY_NOTIFY
              operation to the source server.

              <vspace blankLines="1" />
              <?rfc include='autogen/copy_from_auth.xml'?>
              <vspace blankLines="1" />

              cap_shared_secret is a secret value the user
              principal generates.
            </t>

            <t hangText="copy_to_auth:">
              A user principal is authorizing a destination principal
              ("nfs@&lt;destination&gt;") to allow it to copy a file
              from the source to the destination. This privilege is
              established on the destination server before the user
              principal sends a COPY operation to the destination server.

              <vspace blankLines="1" />
              <?rfc include='autogen/copy_to_auth.xml'?>
              <vspace blankLines="1" />

              ctap_shared_secret is a secret value the user principal
              generated and was used to establish the copy_from_auth
              privilege with the source principal.
            </t>

            <t hangText="copy_confirm_auth:">
              A destination principal is confirming with the
              source principal that it is authorized to copy data
              from the source on behalf of the user principal. When
              the inter-server copy protocol is NFSv4, or for that
              matter, any protocol capable of being secured via
              RPCSEC_GSSv3 (i.e., any ONC RPC protocol), this privilege
              is established before the file is copied from the
              source to the destination.

              <vspace blankLines="1" />
              <?rfc include='autogen/copy_confirm_auth.xml'?>
            </t>
          </list>
        </t>

        <section title="Establishing a Security Context">
          <t>
            When the user principal wants to COPY a file between two servers, if it has
            not established copy_from_auth and copy_to_auth privileges on the servers,
            it establishes them:
          </t>

          <t>
            <list style="symbols">

              <t>
                The user principal generates a secret it will share with the two
                servers. This shared secret will be placed in the cfap_shared_secret
                and ctap_shared_secret fields of the appropriate privilege data types,
                copy_from_auth_priv and copy_to_auth_priv.
              </t>

              <t>
                An instance of copy_from_auth_priv is filled in with the shared
                secret, the destination server, and the NFSv4 user id of the
                user principal. It will be sent with an RPCSEC_GSS3_CREATE
                procedure, and so cfap_seq_num is set to the seq_num of the
                credential of the RPCSEC_GSS3_CREATE procedure. Because
                cfap_shared_secret is a secret, after XDR encoding
                copy_from_auth_priv, GSS_Wrap() (with privacy) is invoked
                on copy_from_auth_priv. The RPCSEC_GSS3_CREATE procedure's
                arguments are:

                <vspace blankLines="1" />

                <figure>
                  <artwork>
   struct {
      rpc_gss3_gss_binding    *compound_binding;
      rpc_gss3_chan_binding   *chan_binding_mic;
      rpc_gss3_assertion      assertions&lt;&gt;;
      rpc_gss3_extension      extensions&lt;&gt;;
   } rpc_gss3_create_args;
                 </artwork>
                </figure>

                <vspace blankLines="1" />

                The string "copy_from_auth" is placed in assertions[0].privs. The
                output of GSS_Wrap() is placed in extensions[0].data. The field
                extensions[0].critical is set to TRUE. The source server calls
                GSS_Unwrap() on the privilege, and verifies that the seq_num matches
                the credential. It then verifies that the NFSv4 user id being asserted
                matches the source server's mapping of the user principal. If it
                does, the privilege is established on the source server as:
                &lt;"copy_from_auth", user id, destination&gt;. The successful
                reply to RPCSEC_GSS3_CREATE has:

                <vspace blankLines="1" />

                <figure>
                  <artwork>
   struct {
      opaque                  handle&lt;&gt;;
      rpc_gss3_chan_binding   *chan_binding_mic;
      rpc_gss3_assertion      granted_assertions&lt;&gt;;
      rpc_gss3_assertion      server_assertions&lt;&gt;;
      rpc_gss3_extension      extensions&lt;&gt;;
   } rpc_gss3_create_res;
                  </artwork>
                </figure>

                <vspace blankLines="1" />

                The field "handle" is the RPCSEC_GSSv3 handle that the client
                will use on COPY_NOTIFY requests involving the source and
                destination server. granted_assertions[0].privs will be equal to
                "copy_from_auth". The server will return a GSS_Wrap() of
                copy_to_auth_priv.
              </t>

              <t>
                An instance of copy_to_auth_priv is filled in with the
                shared secret, the source server, and the NFSv4 user id.
                It will be sent with an RPCSEC_GSS3_CREATE procedure, and
                so ctap_seq_num is set to the seq_num of the credential of
                the RPCSEC_GSS3_CREATE procedure. Because ctap_shared_secret
                is a secret, after XDR encoding copy_to_auth_priv,
                GSS_Wrap() is invoked on copy_to_auth_priv. The RPCSEC_GSS3_CREATE
                procedure's arguments are:

                <vspace blankLines="1" />

                <figure>
                  <artwork>
   struct {
      rpc_gss3_gss_binding    *compound_binding;
      rpc_gss3_chan_binding   *chan_binding_mic;
      rpc_gss3_assertion      assertions&lt;&gt;;
      rpc_gss3_extension      extensions&lt;&gt;;
   } rpc_gss3_create_args;
                  </artwork>
                </figure>

                <vspace blankLines="1" />

                The string "copy_to_auth" is placed in assertions[0].privs.
                The output of GSS_Wrap() is placed in extensions[0].data. The
                field extensions[0].critical is set to TRUE. After unwrapping,
                verifying the seq_num, and the user principal to NFSv4 user
                ID mapping, the destination establishes a privilege of
                &lt;"copy_to_auth", user id, source&gt;. The successful reply
                to RPCSEC_GSS3_CREATE has:

                <vspace blankLines="1" />

                <figure>
                  <artwork>
   struct {
      opaque                  handle&lt;&gt;;
      rpc_gss3_chan_binding   *chan_binding_mic;
      rpc_gss3_assertion      granted_assertions&lt;&gt;;
      rpc_gss3_assertion      server_assertions&lt;&gt;;
      rpc_gss3_extension      extensions&lt;&gt;;
   } rpc_gss3_create_res;
                  </artwork>
                </figure>

                <vspace blankLines="1" />

                The field "handle" is the RPCSEC_GSSv3 handle that the client will
                use on COPY requests involving the source and destination server.
                The field granted_assertions[0].privs will be equal to "copy_to_auth".
                The server will return a GSS_Wrap() of copy_to_auth_priv.
              </t>
            </list>
          </t>
        </section>

        <section title="Starting a Secure Inter-Server Copy">
          <t>
            When the client sends a COPY_NOTIFY request to the source server, it uses
            the privileged "copy_from_auth" RPCSEC_GSSv3 handle. cna_destination_server
            in COPY_NOTIFY MUST be the same as the name of the destination server
            specified in copy_from_auth_priv. Otherwise, COPY_NOTIFY will fail with
            NFS4ERR_ACCESS. The source server verifies that the privilege
            &lt;"copy_from_auth", user id, destination&gt; exists, and annotates it
            with the source filehandle, if the user principal has read
            access to the source file, and if administrative policies give the user
            principal and the NFS client read access to the source file (i.e., if the
            ACCESS operation would grant read access). Otherwise, COPY_NOTIFY will fail
            with NFS4ERR_ACCESS.
          </t>

          <t>
            When the client sends a COPY request to the destination server, it uses
            the privileged "copy_to_auth" RPCSEC_GSSv3 handle. ca_source_server in
            COPY MUST be the same as the name of the source server specified in
            copy_to_auth_priv. Otherwise, COPY will fail with NFS4ERR_ACCESS. The
            destination server verifies that the privilege
            &lt;"copy_to_auth", user id, source&gt; exists, and annotates it with the
            source and destination filehandles. If the client has failed to establish
            the "copy_to_auth" policy it will reject the request with
            NFS4ERR_PARTNER_NO_AUTH.
          </t>

          <t>
            If the client sends a COPY_REVOKE to the source server to rescind the
            destination server's copy privilege, it uses the privileged
            "copy_from_auth" RPCSEC_GSSv3 handle and the cra_destination_server
            in COPY_REVOKE MUST be the same as the name of the destination server
            specified in copy_from_auth_priv. The source server will then
            delete the &lt;"copy_from_auth", user id, destination&gt; privilege
            and fail any subsequent copy requests sent under the auspices of this
            privilege from the destination server.
          </t>
        </section>

        <section title="Securing ONC RPC Server-to-Server Copy Protocols">
          <t>
            After a destination server has a "copy_to_auth" privilege established on
            it, and it receives a COPY request, if it knows it will use an ONC RPC
            protocol to copy data, it will establish a "copy_confirm_auth" privilege
            on the source server, using nfs@&lt;destination&gt; as the initiator
            principal, and nfs@&lt;source&gt; as the target principal.
          </t>

          <t>
            The value of the field ccap_shared_secret_mic is a GSS_VerifyMIC() of
            the shared secret passed in the copy_to_auth privilege.  The field
            ccap_username is the mapping of the user principal to an NFSv4 user
            name ("user"@"domain" form), and MUST be the same as ctap_username
            and cfap_username. The field ccap_seq_num is the seq_num of the
            RPCSEC_GSSv3 credential used for the RPCSEC_GSS3_CREATE procedure
            the destination will send to the source server to establish the
            privilege.
          </t>

          <t>
            The source server verifies the privilege, and establishes a
            &lt;"copy_confirm_auth", user id, destination&gt; privilege. If the
            source server fails to verify the privilege, the COPY operation will
            be rejected with NFS4ERR_PARTNER_NO_AUTH. All subsequent ONC RPC
            requests sent from the destination to copy data from the source to
            the destination will use the RPCSEC_GSSv3 handle returned by the
            source's RPCSEC_GSS3_CREATE response.
          </t>

          <t>
            Note that the use of the "copy_confirm_auth" privilege
            accomplishes the following:
          </t>

          <t>
            <list style="symbols">
              <t>
                if a protocol like NFS is being used, with export policies,
                export policies can be overridden in case the destination server
                as-an-NFS-client is not authorized
              </t>

              <t>
                manual configuration to allow a copy relationship between the source
                and destination is not needed.
              </t>
            </list>
          </t>

          <t>
            If the attempt to establish a "copy_confirm_auth" privilege fails,
            then when the user principal sends a COPY request to destination,
            the destination server will reject it with NFS4ERR_PARTNER_NO_AUTH.
          </t>
        </section>

        <section title="Securing Non ONC RPC Server-to-Server Copy Protocols"
         anchor="server-to-server-no-rpc-with-gss">
          <t>
            If the destination won't be using ONC RPC to copy the data, then
            the source and destination are using an unspecified copy protocol.
            The destination could use the shared secret and the NFSv4 user id to
            prove to the source server that the user principal has authorized
            the copy.
          </t>

          <t>
            For protocols that authenticate user names with passwords
            (e.g., HTTP <xref target="ref:RFC2616" /> and FTP <xref target="ref:RFC0959" />),
            the nfsv4 user id could be used as the user name, and an ASCII
            hexadecimal representation of the RPCSEC_GSSv3 shared secret could be
            used as the user password or as input into non-password authentication
            methods like CHAP <xref target="ref:RFC1994" />.
          </t>
        </section>
      </section>

      <section title="Inter-Server Copy via ONC RPC but without RPCSEC_GSSv3"
       anchor="server-to-server-with-rpc-no-gss">
        <t>
          ONC RPC security flavors other than RPCSEC_GSSv3 MAY be used with
          the server-side copy offload operations described in this
          document. In particular, host-based ONC RPC security flavors
          such as AUTH_NONE and AUTH_SYS MAY be used. If a host-based
          security flavor is used, a minimal level of protection for
          the server-to-server copy protocol is possible.
        </t>

        <t>
          In the absence of strong security mechanisms such as
          RPCSEC_GSSv3, the challenge is how the source server
          and destination server identify themselves to each other,
          especially in the presence of multi-homed source and
          destination servers. In a multi-homed environment, the
          destination server might not contact the source server
          from the same network address specified by the client
          in the COPY_NOTIFY. This can be overcome using the
          procedure described below.
        </t>

        <t>
          When the client sends the source server the COPY_NOTIFY operation,
          the source server may reply to the client with a list of target
          addresses, names, and/or URLs and assign them to the unique quadruple:
          &lt;random number, source fh, user ID, destination address Y&gt;.  If the destination
          uses one of these target netlocs to contact the source server, the source
          server will be able to uniquely identify the destination server, even
          if the destination server does not connect from the address specified
          by the client in COPY_NOTIFY.  The level of assurance in this identification
          depends on the unpredictability, strength and secrecy of the random number.
        </t>

        <t>
          For example, suppose the network topology is as shown in
          <xref target="inter-server-fig" />.  If the source filehandle
          is 0x12345, the source server may respond to a COPY_NOTIFY
          for destination 10.11.78.56 with the URLs:
        </t>

        <t>
          <list style="empty">
            <t>nfs://10.11.78.18//_COPY/FvhH1OKbu8VrxvV1erdjvR7N/10.11.78.56/_FH/0x12345</t>
            <t>nfs://192.168.33.18//_COPY/FvhH1OKbu8VrxvV1erdjvR7N/10.11.78.56/_FH/0x12345</t>
          </list>
        </t>

        <t>
          The name component after _COPY is 24 characters of base 64, more than enough
          to encode a 128 bit random number.
        </t>

        <t>
          The client will then send these URLs to the destination server
          in the COPY operation. Suppose that the 192.168.33.0/24 network
          is a high speed network and the destination server decides to
          transfer the file over this network. If the destination
          contacts the source server from 192.168.33.56 over this network
          using NFSv4.1, it does the following:
        </t>

        <t>
          <list style="hanging">
            <t hangText="COMPOUND"> { PUTROOTFH, LOOKUP "_COPY" ;
              LOOKUP "FvhH1OKbu8VrxvV1erdjvR7N" ;
              LOOKUP "10.11.78.56";
              LOOKUP "_FH" ; OPEN "0x12345" ; GETFH }
            </t>
          </list>
        </t>

        <t>
          Provided that the random number is unpredictable and has been kept secret
          by the parties involved, the source server will therefore know that these
          NFSv4.x operations are being issued by the destination server identified
          in the COPY_NOTIFY.  This random number technique only provides initial
          authentication of the destination server, and cannot defend against
          man-in-the-middle attacks after authentication or an eavesdropper that
          observes the random number on the wire. Other secure communication
          techniques (e.g., IPsec) are necessary to block these attacks. 
        </t>
      </section>

      <section title="Inter-Server Copy without ONC RPC and RPCSEC_GSSv3"
         anchor="server-to-server-no-rpc-no-gss">
        <t>
          The same techniques as <xref target="server-to-server-with-rpc-no-gss" />,
          using unique URLs for each destination server, can be used for other
          protocols (e.g., HTTP <xref target="ref:RFC2616" /> and FTP <xref target="ref:RFC0959" />)
          as well.
        </t>
      </section>
    </section>
  </section>
</section>
