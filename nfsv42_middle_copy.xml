<!-- Copyright (C) The IETF Trust (2011-2014) -->
<!-- Copyright (C) The Internet Society (2011-2014) -->

<section anchor="sec:copy" title="Server Side Copy">
  <section title="Introduction">
    <t>
      The server-side copy features provide mechanisms which allow an
      NFS client to copy file data on a server or between two servers
      without the data being transmitted back and forth over the network
      through the NFS client.  Without these features, an NFS client
      would copy data from one location to another by reading the data
      from the source server over the network, and then writing the data
      back over the network to the destination server.
    </t>

    <t>
      If the source object and destination object are on different file
      servers, the file servers will communicate with one another to
      perform the copy operation. The server-to-server protocol by which
      this is accomplished is not defined in this document.
    </t>
  </section>

  <section title="Protocol Overview">
    <t>
      The server-side copy offload operations support both intra-server
      and inter-server file copies. An intra-server copy is a copy in
      which the source file and destination file reside on the same
      server. In an inter-server copy, the source file and destination
      file are on different servers. In both cases, the copy may be
      performed synchronously or asynchronously.
    </t>

    <t>
      In addition, the CLONE operation provides copy-like functionality
      in the intra-sever case which is both synchronous and atomic,
      in that other operations may not see the target file in any state
      between that before the clone operation and after it.
    </t>

    <t>
      Throughout the rest of this document, we refer to the NFS server
      containing the source file as the "source server" and the NFS
      server to which the file is transferred as the "destination
      server". In the case of an intra-server copy, the source server and
      destination server are the same server.  Therefore in the context
      of an intra-server copy, the terms source server and destination
      server refer to the single server performing the copy.
    </t>

    <t>
      The new operations are designed to copy files or regions within
      them.  Other file system objects can be copied by building on
      these operations or using other techniques.  For example, if a user
      wishes to copy a directory, the client can synthesize a directory
      copy operation by first creating the destination directory and the
      individual (empty) files within it, and then copying the contents
      of the source directory's files to files in the new destination
      directory.
    </t>

    <t>
      For the inter-server copy, the operations are defined to be
      compatible with the traditional copy authorization approach.
      The client and user are authorized at the source for reading. Then
      they are authorized at the destination for writing.
    </t>

    <section anchor='ss:cp:over' title="Copy Operations">
      <t>
        <list style="hanging">
          <t hangText="CLONE:">
            Used by the client to request an synchronous atomic
            copy-like operation.  (<xref target="op:clone" />)
          </t>

          <t hangText="COPY_NOTIFY:">
            Used by the client to request the source server to authorize a
            future file copy that will be made by a given destination
            server on behalf of the given user. (<xref target="op:copy_notify" />)
          </t>

          <t hangText="COPY:">
            Used by the client to request a file copy.
            (<xref target="op:copy" />)
          </t>

          <t hangText="OFFLOAD_CANCEL:">
            Used by the client to terminate an asynchronous file copy.
            (<xref target="op:offload_close" />)
          </t>

          <t hangText="OFFLOAD_STATUS:">
            Used by the client to poll the status of
            an asynchronous file copy.
            (<xref target="op:offload_status" />)
          </t>

          <t hangText="CB_OFFLOAD:">
            Used by the destination server to report the
            results of an asynchronous file copy to the client.
            (<xref target="op:cb_offload" />)
          </t>
        </list>
      </t>
    </section>

    <section title="Requirements for Operations" anchor="ss:copy:ops">
      <t>
        Three OPTIONAL features are provided relative to server-side
        copy. A server may choose independently to implement any of them.
        A server implementing any of these features may be REQUIRED to
        implement certain operations.  Other operations are OPTIONAL in
        the context of a particular feature
        <xref target='sec:operations:mandlist' />, but may become
        REQUIRED depending on server behavior.  Clients need to use
        these operations to successfully copy a file.
      </t>

      <t>
        For a client to do an intra-server file copy, it needs to use
        either the COPY or the CLONE operation.  If COPY is used the
        client MUST support the CB_OFFLOAD operation.  If COPY is used and
        it returns a stateid, then the client MAY use the OFFLOAD_CANCEL
        and OFFLOAD_STATUS operations.
      </t>

      <t>
        For a client to do an inter-server file copy, then it needs to
        use the COPY and COPY_NOTIFY operations and MUST support the
        CB_OFFLOAD operation. If COPY returns a stateid, then the client
        MAY use the OFFLOAD_CANCEL and OFFLOAD_STATUS operations.
      </t>

      <t>
        If a server supports intra-server copy feature, then the server
        MUST support the COPY operation.  If a server's COPY operation
        returns a stateid, then the server MUST also support these
        operations: CB_OFFLOAD, OFFLOAD_CANCEL, and OFFLOAD_STATUS.
      </t>

      <t>
        If a server supports the clone feature, then it MUST support
        the CLONE operations and the clone_blksize attribute on any
        filesystem on which CLONE is supported (as either source or
        destination file).
      </t>

      <t>
        If a source server supports inter-server copy feature, then it
        MUST support the operations COPY_NOTIFY and OFFLOAD_CANCEL. If
        a destination server supports inter-server copy feature, then
        it MUST support the COPY operation.  If a destination server's
        COPY operation returns a stateid, then the destination server
        MUST also support these operations: CB_OFFLOAD, OFFLOAD_CANCEL,
        COPY_NOTIFY, and OFFLOAD_STATUS.
      </t>

      <t>
        Each operation is performed in the context of the user
        identified by the Open Network Computing (ONC) RPC credential of its containing COMPOUND
        or CB_COMPOUND request. For example, an OFFLOAD_CANCEL operation
        issued by a given user indicates that a specified COPY operation
        initiated by the same user be canceled. Therefore an OFFLOAD_CANCEL
        MUST NOT interfere with a copy of the same file initiated by
        another user.
      </t>

      <t>
        An NFS server MAY allow an administrative user to monitor or
        cancel copy operations using an implementation specific
        interface.
      </t>
    </section>
  </section>

  <section title="Requirements for Inter-Server Copy">
    <t>
      The specification of inter-server copy is driven by several requirements:
    </t>

    <t>
      <list style="symbols">
        <t>
          The specification MUST NOT mandate the server-to-server
          protocol.
        </t>

        <t>
          The specification MUST provide guidance for using NFSv4.x
          as a copy protocol. For those source and destination
          servers willing to use NFSv4.x, there are specific security
          considerations that this specification MUST address.
        </t>

        <t>
          The specification MUST NOT mandate preconfiguration between
          the source and destination server. Requiring that the
          source and destination first have a "copying relationship"
          increases the administrative burden. However the specification
          MUST NOT preclude implementations that require preconfiguration.
        </t>

        <t>
          The specification MUST NOT mandate a trust relationship
          between the source and destination server. The NFSv4
          security model requires mutual authentication between a
          principal on an NFS client and a principal on an NFS
          server. This model MUST continue with the introduction
          of COPY.
        </t>
      </list>
    </t>
  </section>

  <section title="Implementation Considerations">
    <section anchor="ss:copy:lock" title="Locking the Files">
      <t>
        Both the source and destination file may need to be locked
        to protect the content during the copy operations. A client
        can achieve this by a combination of OPEN and LOCK operations.
        I.e., either share or byte range locks might be desired.
      </t>

      <t>
        Note that when the client establishes a lock stateid on the
        source, the context of that stateid is for the client and
        not the destination.  As such, there might already be an
        outstanding stateid, issued to the destination as client
        of the source, with the same value as that provided for the
        lock stateid. The source MUST interpret the lock stateid as
        that of the client, i.e., when the destination presents it
        in the context of a inter-server copy, it is on behalf of
        the client.
      </t>
    </section>

    <section title="Client Caches">
      <t>
        In a traditional copy, if the client is in the process of
        writing to the file before the copy (and perhaps with
        a write  delegation), it will be straightforward to update
        the destination server.  With an inter-server copy, the
        source has no insight into the changes cached on the client.
        The client SHOULD write back the data to the source.  If
        it does not do so, it is possible that the destination will
        receive a corrupt copy of file.
      </t>
    </section>
  </section>

  <section title="Intra-Server Copy">
    <t>
      To copy a file on a single server, the client uses a COPY operation.
      The server may respond to the copy operation with the final results of
      the copy or it may perform the copy asynchronously and deliver the
      results using a CB_OFFLOAD operation callback. If the copy is performed
      asynchronously, the client may poll the status of the copy using
      OFFLOAD_STATUS or cancel the copy using OFFLOAD_CANCEL.
    </t>

    <t>
      A synchronous intra-server copy is shown in
      <xref target="fig:sync-intra-server" />. In this example, the NFS
      server chooses to perform the copy synchronously. The copy operation
      is completed, either successfully or unsuccessfully, before the
      server replies to the client's request. The server's reply contains
      the final result of the operation.
    </t>

    <figure title="A synchronous intra-server copy." anchor="fig:sync-intra-server">
      <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the source file
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the destination file
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the destination file
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the source file
     |                                      |
     |                                      |
      ]]></artwork>
    </figure>

    <t>
      An asynchronous intra-server copy is shown in
      <xref target="afig:sync-intra-server" />. In this example, the NFS
      server performs the copy asynchronously. The server's reply to
      the copy request indicates that the copy operation was initiated
      and the final result will be delivered at a later time. The server's
      reply also contains a copy stateid. The client may use this copy
      stateid to poll for status information (as shown) or to cancel the copy
      using an OFFLOAD_CANCEL. When the server completes the copy, the server
      performs a callback to the client and reports the results.
    </t>

    <figure title="An asynchronous intra-server copy." anchor="afig:sync-intra-server">
      <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the source file
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the destination file
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |                                      |
     |--- OFFLOAD_STATUS ------------------>| Client may poll
     |<------------------------------------/| for status
     |                                      |
     |                  .                   | Multiple OFFLOAD_STATUS
     |                  .                   | operations may be sent.
     |                  .                   |
     |                                      |
     |<-- CB_OFFLOAD -----------------------| Server reports results
     |\------------------------------------>|
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the destination file
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the source file
     |                                      |
     |                                      |
      ]]></artwork>
    </figure>
  </section>

  <section title="Inter-Server Copy">
    <t>
      A copy may also be performed between two servers. The copy
      protocol is designed to accommodate a variety of network
      topologies. As shown in <xref target="fig:inter-server" />,
      the client and servers may be connected by multiple networks.
      In particular, the servers may be connected by a specialized,
      high speed network (network 192.0.2.0/24 in the diagram)
      that does not include the client. The protocol allows the
      client to setup the copy between the servers (over network
      203.0.113.0/24 in the diagram) and for the servers to
      communicate on the high speed network if they choose to
      do so.
    </t>

    <figure title="An example inter-server network topology." anchor="fig:inter-server">
      <artwork><![CDATA[
                          192.0.2.0/24
              +-------------------------------------+
              |                                     |
              |                                     |
              | 192.0.2.18                          | 192.0.2.56
      +-------+------+                       +------+------+
      |     Source   |                       | Destination |
      +-------+------+                       +------+------+
              | 203.0.113.18                        | 203.0.113.56
              |                                     |
              |                                     |
              |             203.0.113.0/24          |
              +------------------+------------------+
                                 |
                                 |
                                 | 203.0.113.243
                           +-----+-----+
                           |   Client  |
                           +-----------+
      ]]></artwork>
    </figure>

    <t>
      For an inter-server copy, the client notifies the source
      server that a file will be copied by the destination
      server using a COPY_NOTIFY operation. The client then
      initiates the copy by sending the COPY operation to the
      destination server. The destination server may perform the
      copy synchronously or asynchronously.
    </t>

    <t>
      A synchronous inter-server copy is shown in
      <xref target="fig:sync-inter-server" />. In this case, the
      destination server chooses to perform the copy before
      responding to the client's COPY request.
    </t>

    <t>
      An asynchronous copy is shown in
      <xref target="fig:async-inter-server" />. In this case, the
      destination server chooses to respond to the client's COPY
      request immediately and then perform the copy
      asynchronously.
    </t>

    <figure title="A synchronous inter-server copy." anchor="fig:sync-inter-server">
      <artwork><![CDATA[
  Client                Source         Destination
     +                    +                 +
     |                    |                 |
     |--- OPEN        --->|                 | Returns
     |<------------------/|                 | open state os1
     |                    |                 |
     |--- COPY_NOTIFY --->|                 |
     |<------------------/|                 |
     |                    |                 |
     |--- OPEN ---------------------------->| Returns
     |<------------------------------------/| open state os2
     |                    |                 |
     |--- COPY ---------------------------->|
     |                    |                 |
     |                    |                 |
     |                    |<----- read -----|
     |                    |\--------------->|
     |                    |                 |
     |                    |        .        | Multiple reads may
     |                    |        .        | be necessary
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |<------------------------------------/| Destination replies
     |                    |                 | to COPY
     |                    |                 |
     |--- CLOSE --------------------------->| Release os2
     |<------------------------------------/|
     |                    |                 |
     |--- CLOSE       --->|                 | Release os1
     |<------------------/|                 |
      ]]></artwork>
    </figure>

    <figure title="An asynchronous inter-server copy." anchor="fig:async-inter-server">
      <artwork><![CDATA[
  Client                Source         Destination
    +                    +                 +
    |                    |                 |
    |--- OPEN        --->|                 | Returns
    |<------------------/|                 | open state os1
    |                    |                 |
    |--- LOCK        --->|                 | Optional, could be done
    |<------------------/|                 | with a share lock
    |                    |                 |
    |--- COPY_NOTIFY --->|                 | Need to pass in
    |<------------------/|                 | os1 or lock state
    |                    |                 |
    |                    |                 |
    |                    |                 |
    |--- OPEN ---------------------------->| Returns
    |<------------------------------------/| open state os2
    |                    |                 |
    |--- LOCK ---------------------------->| Optional ...
    |<------------------------------------/|
    |                    |                 |
    |--- COPY ---------------------------->| Need to pass in
    |<------------------------------------/| os2 or lock state
    |                    |                 |
    |                    |                 |
    |                    |<----- read -----|
    |                    |\--------------->|
    |                    |                 |
    |                    |        .        | Multiple reads may
    |                    |        .        | be necessary
    |                    |        .        |
    |                    |                 |
    |                    |                 |
    |--- OFFLOAD_STATUS ------------------>| Client may poll
    |<------------------------------------/| for status
    |                    |                 |
    |                    |        .        | Multiple OFFLOAD_STATUS
    |                    |        .        | operations may be sent
    |                    |        .        |
    |                    |                 |
    |                    |                 |
    |                    |                 |
    |<-- CB_OFFLOAD -----------------------| Destination reports
    |\------------------------------------>| results
    |                    |                 |
    |--- LOCKU --------------------------->| Only if LOCK was done
    |<------------------------------------/|
    |                    |                 |
    |--- CLOSE --------------------------->| Release os2
    |<------------------------------------/|
    |                    |                 |
    |--- LOCKU       --->|                 | Only if LOCK was done
    |<------------------/|                 |
    |                    |                 |
    |--- CLOSE       --->|                 | Release os1
    |<------------------/|                 |
    |                    |                 |
      ]]></artwork>
    </figure>
  </section>

  <section title="Server-to-Server Copy Protocol" anchor="sec:SSC-proto">
    <t>
      The choice of what protocol to use in an inter-server copy
      is ultimately the destination server's decision. However, the
      destination server has to be cognizant that it is working on
      behalf of the client.
    </t>

    <section title="Considerations on Selecting a Copy Protocol">
      <t>
        The client can have requirements over both the size of
        transactions and error recovery semantics. It may want to
        split the copy up such that each chunk is synchronously
        transferred. It may want the copy protocol to copy the bytes
        in consecutive order such that upon an error, the client can
        restart the copy at the last known good offset. If the
        destination server cannot meet these requirements, the client
        may prefer the traditional copy mechanism such that it
        can meet those requirements.
      </t>
    </section>

    <section title="Using NFSv4.x as the Copy Protocol">
      <t>
        The destination server MAY use standard NFSv4.x (where x >= 1)
        operations to read the data from the source server. If NFSv4.x is used
        for the server-to-server copy protocol, the destination server
        can use the source filehandle and ca_src_stateid provided in the
        COPY request with standard NFSv4.x operations to read data
        from the source server. Note that the ca_src_stateid MUST be
        the cnr_stateid returned from the source via the COPY_NOTIFY (<xref target='op:copy_notify' />).
      </t>
    </section>

    <section title="Using an Alternative Copy Protocol">
      <t>
        In a homogeneous environment, the source and destination
        servers might be able to perform the file copy extremely
        efficiently using specialized protocols. For example the
        source and destination servers might be two nodes sharing
        a common file system format for the source and destination
        file systems. Thus the source and destination are in an
        ideal position to efficiently render the image of the
        source file to the destination file by replicating the
        file system formats at the block level. Another possibility
        is that the source and destination might be two nodes
        sharing a common storage area network, and thus there is
        no need to copy any data at all, and instead ownership
        of the file and its contents might simply be re-assigned
        to the destination. To allow for these possibilities, the
        destination server is allowed to use a server-to-server
        copy protocol of its choice.
      </t>

      <t>
        In a heterogeneous environment, using a protocol other
        than NFSv4.x (e.g., HTTP <xref target="RFC7230" /> or FTP
        <xref target="RFC959" />) presents some challenges. In
        particular, the destination server is presented with the
        challenge of accessing the source file given only an
        NFSv4.x filehandle.
      </t>

      <t>
        One option for protocols that identify source files with
        path names is to use an ASCII hexadecimal representation
        of the source filehandle as the file name.
      </t>

      <t>
        Another option for the source server is to use URLs to
        direct the destination server to a specialized service.
        For example, the response to COPY_NOTIFY could include
        the URL ftp://s1.example.com:9999/_FH/0x12345, where
        0x12345 is the ASCII hexadecimal representation of the
        source filehandle. When the destination server receives
        the source server's URL, it would use "_FH/0x12345" as
        the file name to pass to the FTP server listening on port
        9999 of s1.example.com. On port 9999 there would be a
        special instance of the FTP service that understands how
        to convert NFS filehandles to an open file descriptor (in
        many operating systems, this would require a new system
        call, one which is the inverse of the makefh() function
        that the pre-NFSv4 MOUNT service needs).
      </t>

      <t>
        Authenticating and identifying the destination server to
        the source server is also a challenge. Recommendations
        for how to accomplish this are given in <xref
        target="sec:SSC-no-rpc" />.
      </t>
    </section>
  </section>

  <section title="netloc4 - Network Locations">
    <t>
      The server-side copy operations specify network locations using
      the netloc4 data type shown below:
    </t>

    <t>
      &lt;CODE BEGINS&gt;
    </t>

    <?rfc include='autogen/type_netloc_type4.xml'?>

    <t>
      &lt;CODE ENDS&gt;
    </t>

    <t>
      If the netloc4 is of type NL4_NAME, the nl_name field MUST be
      specified as a UTF-8 string. The nl_name is expected to be
      resolved to a network address via DNS, Lightweight Directory
      Access Protocol (LDAP), Network Information Service (NIS), /etc/hosts,
      or some other means. If the netloc4 is of type NL4_URL, a
      server URL <xref target="RFC3986" /> appropriate for the
      server-to-server copy operation is specified as a UTF-8 string.
      If the netloc4 is of type NL4_NETADDR, the nl_addr field MUST
      contain a valid netaddr4 as defined in Section 3.3.9 of
      <xref target="RFC5661" />.
    </t>

    <t>
      When netloc4 values are used for an inter-server copy as
      shown in <xref target="fig:inter-server" />, their values
      may be evaluated on the source server, destination server,
      and client. The network environment in which these systems
      operate should be configured so that the netloc4 values
      are interpreted as intended on each system.
    </t>
  </section>

  <section title="Copy Offload Stateids" anchor="ss:copy:stateid">
    <t>
      A server may perform a copy offload operation asynchronously.  An
      asynchronous copy is tracked using a copy offload stateid.  Copy
      offload stateids are included in the COPY, OFFLOAD_CANCEL,
      OFFLOAD_STATUS, and CB_OFFLOAD operations.
    </t>

    <t>
      A copy offload stateid will be valid until either (A) the client or
      server restarts or (B) the client returns the resource by issuing a
      OFFLOAD_CANCEL operation or the client replies to a CB_OFFLOAD
      operation.
    </t>

    <t>
      A copy offload stateid's seqid MUST NOT be zero.  In the context of a
      copy offload operation, it is ambiguous to indicate the most recent
      copy offload operation using a stateid with seqid of zero.  Therefore a
      copy offload stateid with seqid of zero MUST be considered invalid.
    </t>
  </section>

  <section anchor="ss:copy:security" title="Security Considerations">
    <t>
      The security considerations pertaining to NFSv4.1 <xref target="RFC5661" />
      apply to this section. And as such, the standard security
      mechanisms used by the protocol can be used to secure
      the server-to-server operations.
    </t>

    <t>
      NFSv4 clients and servers supporting the inter-server copy
      operations described in this chapter are REQUIRED to implement
      the mechanism described in <xref target="sec:SSC-rpc-with-gss" />,
      and to support rejecting COPY_NOTIFY requests that do not use
      RPCSEC_GSS with privacy.  If the server-to-server copy protocol
      is ONC RPC based, the servers are also REQUIRED to implement <xref
      target="rpcsec_gssv3" /> including the RPCSEC_GSSv3 copy_to_auth,
      copy_from_auth, and copy_confirm_auth structured privileges.
      This requirement to implement is not a requirement to use;
      for example, a server may depending on configuration also allow
      COPY_NOTIFY requests that use only AUTH_SYS.
    </t>

    <t>
      If a server requires the use of RPCSEC_GSSv3 copy_to_auth,
      copy_from_auth, or copy_confirm_auth and it is not used,
      the server will reject the request with NFS4ERR_PARTNER_NO_AUTH.
    </t>

    <section title="Inter-Server Copy Security" anchor="sec:SSC-sec">
      <section title="Inter-Server Copy via ONC RPC with RPCSEC_GSSv3"  anchor="sec:SSC-rpc-with-gss">
        <t>
          When the client sends a COPY_NOTIFY to the source server to
          expect the destination to attempt to copy data from the source
          server, it is expected that this copy is being done on behalf
          of the principal (called the "user principal") that sent the
          RPC request that encloses the COMPOUND procedure that contains
          the COPY_NOTIFY operation.  The user principal is identified
          by the RPC credentials.  A mechanism that allows the user
          principal to authorize the destination server to perform the
          copy, that lets the source server properly authenticate the
          destination's copy, and does not allow the destination server
          to exceed this authorization, is necessary.
        </t>

        <t>
          An approach that sends delegated credentials of the client's
          user principal to the destination server is not used for
          the following reason.  If the client's user delegated its
          credentials, the destination would authenticate as the user
          principal.  If the destination were using the NFSv4 protocol
          to perform the copy, then the source server would authenticate
          the destination server as the user principal, and the file
          copy would securely proceed.  However, this approach would
          allow the destination server to copy other files.  The user
          principal would have to trust the destination server to not
          do so.  This is counter to the requirements, and therefore is
          not considered.
        </t>

        <t>
          Instead, a feature of the RPCSEC_GSSv3
          <xref target="rpcsec_gssv3" /> protocol can be used:
          RPC application defined structured privilege assertion.
          This features allow the
          destination server to authenticate to the source server
          as acting on behalf of the user principal, and to authorize
          the destination server to perform READs of the file to
          be copied from the source on behalf of the user principal.
          Once the copy is complete, the client can destroy the
          RPCSEC_GSSv3 handles to end the authorization of both the
          source and destination servers to copy.
        </t>

        <t>
          We define three RPCSEC_GSSv3 structured privilege assertions
          that work in tandem to authorize the copy:
        </t>

        <t>
          <list style="hanging">
            <t hangText="copy_from_auth:">
              A user principal is authorizing a source principal
              ("nfs@&lt;source&gt;") to allow a destination principal
              ("nfs@&lt;destination&gt;") to setup the copy_confirm_auth
              privilege required to copy a file from the source to the
              destination on behalf of the user principal.
              This privilege is established on the source server before
              the user principal sends a COPY_NOTIFY operation to the source
              server, and the resultant RPCSEC_GSSv3 context is used to secure
              the COPY_NOTIFY operation.

              <vspace blankLines="1" />
              &lt;CODE BEGINS&gt;

              <?rfc include='autogen/copy_from_auth.xml'?>

              &lt;CODE ENDS&gt;
              <vspace blankLines="1" />

              cfp_shared_secret is an automatically generated random number
              secret value.
            </t>

            <t hangText="copy_to_auth:">
              A user principal is authorizing a destination principal
              ("nfs@&lt;destination&gt;") to setup a copy_confirm_auth
              privilege with a source principal ("nfs@&lt;source&gt;") to
              allow it to copy a file from the source to the destination
              on behalf of the user principal.  This privilege is
              established on the destination server before the user
              principal sends a COPY operation to the destination server,
              and the resultant RPCSEC_GSSv3 context is used to secure
              the COPY operation.

              <vspace blankLines="1" />
              &lt;CODE BEGINS&gt;

              <?rfc include='autogen/copy_to_auth.xml'?>

              &lt;CODE ENDS&gt;
              <vspace blankLines="1" />

              ctap_shared_secret is the automatically generated secret
              value used to establish the copy_from_auth privilege with
              the source principal. See <xref target="sec:SSC-sec-estab" />.
            </t>

            <t hangText="copy_confirm_auth:">
              A destination principal ("nfs@&lt;destination&gt;") is
              confirming with the source principal ("nfs@&lt;source&gt;")
              that it is authorized to copy data from the source.
              This privilege is established
              on the destination server before the file is copied from
              the source to the destination. The resultant RPCSEC_GSSv3
              context is used to secure the READ operations from the
              source to the destination server.

              <vspace blankLines="1" />
              &lt;CODE BEGINS&gt;

              <?rfc include='autogen/copy_confirm_auth.xml'?>

              &lt;CODE ENDS&gt;
            </t>
          </list>
        </t>

        <section title="Establishing a Security Context" anchor="sec:SSC-sec-estab">
          <t>
            When the user principal wants to COPY a file between two
            servers, if it has not established copy_from_auth and
            copy_to_auth privileges on the servers, it establishes them:
          </t>

          <t>
            <list style="symbols">
              <t>
                As noted in <xref target="rpcsec_gssv3" /> the client uses
                an existing RPCSEC_GSSv3 context termed the "parent"
                handle to establish and protect RPCSEC_GSSv3 structured
                privilege assertion exchanges.
                The copy_from_auth privilege will use the context
                established between the user principal and the source
                server used to OPEN the source file as the RPCSEC_GSSv3
                parent handle. The copy_to_auth privilege will use the
                context established between the user principal and the
                destination server used to OPEN the destination file as
                the RPCSEC_GSSv3 parent handle.
              </t>

              <t>
                A random number is generated to use as a secret to be shared
                between the two servers.  This shared secret will be placed
                in the cfap_shared_secret and ctap_shared_secret fields of
                the appropriate privilege data types, copy_from_auth_priv
                and copy_to_auth_priv.  Because of this shared_secret the
                RPCSEC_GSS3_CREATE control messages for copy_from_auth
                and copy_to_auth MUST use a Quality of Protection (QOP) of rpc_gss_svc_privacy.
              </t>

              <t>
                An instance of copy_from_auth_priv is filled in with the
                shared secret, the destination server, and the NFSv4 user id
                of the user principal and is placed in rpc_gss3_create_args
                assertions[0].privs.privilege. The
                string "copy_from_auth" is placed in
                assertions[0].privs.name.  The source server
                unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload
                and verifies that the NFSv4 user id being asserted matches
                the source server's mapping of the user principal.  If it
                does, the privilege is established on the source server as:
                &lt;"copy_from_auth", user id, destination&gt;.  The field
                "handle" in a successful reply is the RPCSEC_GSSv3
                copy_from_auth "child"
                handle that the client will use on COPY_NOTIFY requests
                to the source server.
              </t>

              <t>
                An instance of copy_to_auth_priv is filled in with the
                shared secret, the cnr_source_server list returned
                by COPY_NOTIFY, and the NFSv4 user id of the user
                principal.  The copy_to_auth_priv
                instance is placed in rpc_gss3_create_args
                assertions[0].privs.privilege. The
                string "copy_to_auth" is placed in
                assertions[0].privs.name.  The destination
                server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE
                payload and verifies that the NFSv4 user id being asserted
                matches the destination server's mapping of the user
                principal.  If it does, the privilege is established on
                the destination server as: &lt;"copy_to_auth", user id,
                source list&gt;.  The field "handle" in a successful reply is
                the RPCSEC_GSSv3 copy_to_auth "child" handle that the client
                will use on COPY requests to the destination server involving
                the source server.
              </t>
            </list>
          </t>

          <t>
            As noted in <xref target="rpcsec_gssv3" /> Section 2.3.1 "Create
            Request", both the client and the source server should associate
            the RPCSEC_GSSv3 "child" handle with the parent RPCSEC_GSSv3
            handle used to create the RPCSEC_GSSv3 child handle.
          </t>
        </section>

        <section title="Starting a Secure Inter-Server Copy">
          <t>
            When the client sends a COPY_NOTIFY request to the source
            server, it uses the privileged "copy_from_auth" RPCSEC_GSSv3
            handle.  cna_destination_server in COPY_NOTIFY MUST be the
            same as cfap_destination specified in copy_from_auth_priv.
            Otherwise, COPY_NOTIFY will fail with NFS4ERR_ACCESS.  The
            source server verifies that the privilege &lt;"copy_from_auth",
            user id, destination&gt; exists, and annotates it with the
            source filehandle, if the user principal has read access to
            the source file, and if administrative policies give the user
            principal and the NFS client read access to the source file
            (i.e., if the ACCESS operation would grant read access).
            Otherwise, COPY_NOTIFY will fail with NFS4ERR_ACCESS.
          </t>

          <t>
            When the client sends a COPY request to the destination server,
            it uses the privileged "copy_to_auth" RPCSEC_GSSv3 handle.
            ca_source_server list in COPY MUST be the same as ctap_source
            list specified in copy_to_auth_priv.  Otherwise, COPY will fail
            with NFS4ERR_ACCESS.  The destination server verifies that the
            privilege &lt;"copy_to_auth", user id, source list&gt; exists, and
            annotates it with the source and destination filehandles.
            If the COPY returns a wr_callback_id, then this is an
            asynchronous copy and the wr_callback_id must also must be
            annotated to the copy_to_auth privilege.  If the client has
            failed to establish the "copy_to_auth" privilege it will reject
            the request with NFS4ERR_PARTNER_NO_AUTH.
          </t>

          <t>
            If either the COPY_NOTIFY, or the COPY operations fail, the
            associated "copy_from_auth" and "copy_to_auth" RPCSEC_GSSv3
            handles MUST be destroyed.
          </t>
        </section>

        <section title="Securing ONC RPC Server-to-Server Copy Protocols">
          <t>
            After a destination server has a "copy_to_auth" privilege
            established on it, and it receives a COPY request, if it knows
            it will use an ONC RPC protocol to copy data, it will establish
            a "copy_confirm_auth" privilege on the source server prior to
            responding to the COPY operation as follows:
          </t>

          <t>
            <list style="symbols">
              <t>
                Before establishing an RPCSEC_GSSv3 context, a parent
                context needs to exist between nfs@&lt;destination&gt;
                as the initiator principal, and nfs@&lt;source&gt;
                as the target principal.  If NFS is to be used as the
                copy protocol, this means that the destination server
                must mount the source server using RPCSEC_GSSv3.
              </t>

              <t>
                An instance of copy_confirm_auth_priv is filled in
                with information from the established "copy_to_auth"
                privilege. The value of the field ccap_shared_secret_mic
                is a GSS_GetMIC() of the ctap_shared_secret in the
                copy_to_auth privilege using the parent handle context.
                The field ccap_username is the mapping of the user
                principal to an NFSv4 user name ("user"@"domain" form),
                and MUST be the same as the ctap_username in the
                copy_to_auth privilege.  The copy_confirm_auth_priv
                instance is placed in rpc_gss3_create_args
                assertions[0].privs.privilege.
                The string "copy_confirm_auth" is placed in
                assertions[0].privs.name.
              </t>

              <t>
                The RPCSEC_GSS3_CREATE copy_from_auth message is sent to the
                source server with a QOP of rpc_gss_svc_privacy. The source
                server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE
                payload and verifies the cap_shared_secret_mic by
                calling GSS_VerifyMIC() using the parent context on the
                cfap_shared_secret from the established "copy_from_auth"
                privilege, and verifies the that the ccap_username equals
                the cfap_username.
              </t>

              <t>
                If all verification succeeds, the
                "copy_confirm_auth" privilege is established on the source
                server as &lt; "copy_confirm_auth", shared_secret_mic,
                user id&gt; Because the shared secret has been verified,
                the resultant copy_confirm_auth RPCSEC_GSSv3 child handle
                is noted to be acting on behalf of the user principal.
              </t>

              <t>
                If the source server fails to verify the copy_from_auth
                privilege the COPY_NOTIFY operation will be rejected with
                NFS4ERR_PARTNER_NO_AUTH.
              </t>

              <t>
                If the destination server fails to verify the copy_to_auth
                or copy_confirm_auth privilege, the COPY will be rejeced with
                NFS4ERR_PARTNER_NO_AUTH, causing the client to
                destroy the associated copy_from_auth and copy_to_auth
                RPCSEC_GSSv3 structured privilege assertion handles.
              </t>

              <t>
                All subsequent ONC RPC READ requests sent from the destination
                to copy data from the source to the destination will
                use the RPCSEC_GSSv3 copy_confirm_auth child handle.
              </t>
            </list>
          </t>

          <t>
            Note that the use of the "copy_confirm_auth" privilege accomplishes
            the following:

            <list style="symbols">
              <t>
                If a protocol like NFS is being used, with export policies,
                export policies can be overridden in case the destination
                server as-an-NFS-client is not authorized
              </t>

              <t>
                Manual configuration to allow a copy relationship between
                the source and destination is not needed.
              </t>
            </list>
          </t>
        </section>

        <section title="Maintaining a Secure Inter-Server Copy">
          <t>
            If the client determines that either the copy_from_auth or
            the copy_to_auth handle becomes invalid during a copy,
            then the copy MUST be aborted by the client
            sending an OFFLOAD_CANCEL to both the source and destination
            servers and destroying the respective copy related context handles
            as described in <xref target="sec:SSC-finish" />.
          </t>
        </section>

        <section  title="Finishing or Stopping a Secure Inter-Server Copy" anchor="sec:SSC-finish">
          <t>
            Under normal operation, the client MUST destroy the
            copy_from_auth and the copy_to_auth RPCSEC_GSSv3 handle once
            the COPY operation returns for a synchronous inter-server copy
            or a CB_OFFLOAD reports the result of an asynchronous copy.
          </t>

          <t>
            The copy_confirm_auth privilege constructed from information held
            by the copy_to_auth privilege, and MUST be destroyed by the
            destination server (via an RPCSEC_GSS3_DESTROY call) when the
            copy_to_auth RPCSEC_GSSv3 handle is destroyed.
          </t>

          <t>
           The copy_confirm_auth RPCSEC_GSS3 handle is associated with a
           copy_from_auth RPCSEC_GSS3 handle on the source server via
           the shared secret and MUST be locally destroyed
           (there is no RPCSEC_GSS3_DESTROY as the source server is
           not the initiator)
           when the copy_from_auth RPCSEC_GSSv3 handle is destroyed.
          </t>

          <t>
            If the client sends an OFFLOAD_CANCEL to the source server to
            rescind the destination server's synchronous copy privilege, it
            uses the privileged "copy_from_auth" RPCSEC_GSSv3 handle and the
            cra_destination_server in OFFLOAD_CANCEL MUST be the same as the
            name of the destination server specified in copy_from_auth_priv.
            The source server will then delete the &lt;"copy_from_auth",
            user id, destination&gt; privilege and fail any subsequent
            copy requests sent under the auspices of this privilege from
            the destination server. The client MUST destroy both the
            "copy_from_auth" and the "copy_to_auth" RPCSEC_GSSv3 handles.
          </t>

          <t>
            If the client sends an OFFLOAD_STATUS to the destination
            server to check on the status of an asynchronous copy, it
            uses the privileged "copy_to_auth" RPCSEC_GSSv3 handle and
            the osa_stateid in OFFLOAD_STATUS MUST be the same as the
            wr_callback_id specified in the "copy_to_auth" privilege stored
            on the destination server.
          </t>

          <t>
            If the client sends an OFFLOAD_CANCEL to the destination server
            to cancel an asynchronous copy, it uses the privileged
            "copy_to_auth" RPCSEC_GSSv3 handle and the oaa_stateid
            in OFFLOAD_CANCEL MUST be the same as the wr_callback_id
            specified in the "copy_to_auth" privilege stored on the
            destination server. The destination server will then delete the
            &lt;"copy_to_auth", user id, source list, nounce, nounce MIC,
            context handle, handle version&gt; privilege and the associated
            "copy_confirm_auth" RPCSEC_GSSv3 handle.  The client MUST
            destroy both the copy_to_auth and copy_from_auth RPCSEC_GSSv3
            handles.
          </t>
        </section>
      </section>

      <section title="Inter-Server Copy via ONC RPC without RPCSEC_GSS" anchor="sec:SSC-rpc-no-gss">
        <t>
          ONC RPC security flavors other than RPCSEC_GSS MAY be used
          with the server-side copy offload operations described in this
          chapter.  In particular, host-based ONC RPC security flavors
          such as AUTH_NONE and AUTH_SYS MAY be used.  If a host-based
          security flavor is used, a minimal level of protection for
          the server-to-server copy protocol is possible.
        </t>

        <t>
          In the absence of a strong security mechanism designed for the
          purpose, the challenge is how the source server and destination
          server identify themselves to each other, especially in the
          presence of multi-homed source and destination servers. In
          a multi-homed environment, the destination server might
          not contact the source server from the same network address
          specified by the client in the COPY_NOTIFY.
          The cnr_stateid returned from the COPY_NOTIFY can
          be used to uniquely identify the destination server to the
          source server.  The use of cnr_stateid
          provides initial authentication of the destination server,
          but cannot defend against man-in-the-middle attacks after
          authentication or an eavesdropper that observes the opaque
          stateid on the wire. Other secure communication techniques
          (e.g., IPsec) are necessary to block these attacks.
        </t>

        <t>
          Servers SHOULD reject COPY_NOTIFY requests that do not use
          RPCSEC_GSS with privacy, thus ensuring the cnr_stateid in the
          COPY_NOTIFY reply is encrypted.  For the same reason, clients
          SHOULD send COPY requests to the destination using RPCSEC_GSS
          with privacy.
        </t>
      </section>

      <section title="Inter-Server Copy without ONC RPC" anchor="sec:SSC-no-rpc">
        <t>
          The same techniques as <xref target="sec:SSC-rpc-no-gss" />,
          using unique URLs for each destination server, can be used for other
          protocols (e.g., HTTP <xref target="RFC7230" /> and
          FTP <xref target="RFC959" />) as well.
        </t>
      </section>
    </section>
  </section>
</section>
