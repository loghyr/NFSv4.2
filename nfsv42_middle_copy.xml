<!-- Copyright (C) The IETF Trust (2011-2014) -->
<!-- Copyright (C) The Internet Society (2011-2014) -->

<section anchor="sec:copy" title="Server Side Copy">
  <section title="Introduction">
    <t>
      The server-side copy feature provides a mechanism for the NFS client
      to perform a file copy on a server or between two servers without
      the data being transmitted back and forth over the network through
      the NFS client.  Without this feature, an NFS client copies data
      from one location to another by reading the data from the source
      server over the network, and then writing the data back over the
      network to the destination server.
    </t>

    <t>
      If the source object and destination object are on different file
      servers, the file servers will communicate with one another to
      perform the copy operation. The server-to-server protocol by which
      this is accomplished is not defined in this document.
    </t>
  </section>

  <section title="Protocol Overview">
    <t>
      The server-side copy offload operations support both intra-server
      and inter-server file copies. An intra-server copy is a copy in
      which the source file and destination file reside on the same
      server. In an inter-server copy, the source file and destination
      file are on different servers. In both cases, the copy may be
      performed synchronously or asynchronously.
    </t>

    <t>
      Throughout the rest of this document, we refer to the NFS server
      containing the source file as the "source server" and the NFS
      server to which the file is transferred as the "destination
      server". In the case of an intra-server copy, the source server and
      destination server are the same server.  Therefore in the context
      of an intra-server copy, the terms source server and destination
      server refer to the single server performing the copy.
    </t>

    <t>
      The operations described below are designed to copy files. Other
      file system objects can be copied by building on these operations
      or using other techniques. For example if the user wishes to copy
      a directory, the client can synthesize a directory copy by first
      creating the destination directory and then copying the source
      directory's files to the new destination directory.
    </t>

    <t>
      For the inter-server copy, the operations are defined to be
      compatible with the traditional copy authentication approach.
      The client and user are authorized at the source for reading. Then
      they are authorized at the destination for writing.
    </t>

    <section title="Overview of Copy Operations">
      <t>
        <list style="hanging">
          <t hangText="COPY_NOTIFY:">
            For inter-server copies, the client sends
            this operation to the source server to notify it of a future
            file copy from a given destination server for the given user.
            (<xref target="op:copy_notify" />)
          </t>

          <t hangText="OFFLOAD_REVOKE:">
            Also for inter-server copies, the client
            sends this operation to the source server to revoke permission
            to copy a file for the given user.
            (<xref target="op:offload_revoke" />)
          </t>

          <t hangText="COPY:">
            Used by the client to request a file copy.
            (<xref target="op:copy" />)
          </t>

          <t hangText="OFFLOAD_ABORT:">
            Used by the client to abort an asynchronous file copy.
            (<xref target="op:offload_abort" />)
          </t>

          <t hangText="OFFLOAD_STATUS:">
            Used by the client to poll the status of
            an asynchronous file copy.
            (<xref target="op:offload_status" />)
          </t>

          <t hangText="CB_OFFLOAD:">
            Used by the destination server to report the
            results of an asynchronous file copy to the client.
            (<xref target="op:cb_offload" />)
          </t>
        </list>
      </t>
    </section>

    <section title="Locking the Files">
      <t>
        Both the source and destination file may need to be locked
        to protect the content during the copy operations. A client
        can achieve this by a combination of OPEN and LOCK operations.
        I.e., either share or byte range locks might be desired.
      </t>
    </section>

    <section title="Intra-Server Copy">
      <t>
        To copy a file on a single server, the client uses a COPY operation.
        The server may respond to the copy operation with the final results of
        the copy or it may perform the copy asynchronously and deliver the
        results using a CB_OFFLOAD operation callback. If the copy is performed
        asynchronously, the client may poll the status of the copy using
        OFFLOAD_STATUS or cancel the copy using OFFLOAD_ABORT.
      </t>

      <t>
        A synchronous intra-server copy is shown in
        <xref target="fig:sync-intra-server" />. In this example, the NFS
        server chooses to perform the copy synchronously. The copy operation
        is completed, either successfully or unsuccessfully, before the
        server replies to the client's request. The server's reply contains
        the final result of the operation.
      </t>

      <figure title="A synchronous intra-server copy." anchor="fig:sync-intra-server">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the source file
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the destination file
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the destination file
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the source file
     |                                      |
     |                                      |
        ]]></artwork>
      </figure>

      <t>
        An asynchronous intra-server copy is shown in
        <xref target="afig:sync-intra-server" />. In this example, the NFS
        server performs the copy asynchronously. The server's reply to
        the copy request indicates that the copy operation was initiated
        and the final result will be delivered at a later time. The server's
        reply also contains a copy stateid. The client may use this copy
        stateid to poll for status information (as shown) or to cancel the copy
        using a OFFLOAD_ABORT. When the server completes the copy, the server
        performs a callback to the client and reports the results.
      </t>

      <figure title="An asynchronous intra-server copy." anchor="afig:sync-intra-server">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the source file
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the destination file
     |                                      |
     |--- COPY ---------------------------->| Client requests
     |<------------------------------------/| a file copy
     |                                      |
     |                                      |
     |--- OFFLOAD_STATUS ------------------>| Client may poll
     |<------------------------------------/| for status
     |                                      |
     |                  .                   | Multiple OFFLOAD_STATUS
     |                  .                   | operations may be sent.
     |                  .                   |
     |                                      |
     |<-- CB_OFFLOAD -----------------------| Server reports results
     |\------------------------------------>|
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the destination file
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the source file
     |                                      |
     |                                      |
        ]]></artwork>
      </figure>
    </section>

    <section title="Inter-Server Copy">
      <t>
        A copy may also be performed between two servers. The copy
        protocol is designed to accommodate a variety of network
        topologies. As shown in <xref target="fig:inter-server" />,
        the client and servers may be connected by multiple networks.
        In particular, the servers may be connected by a specialized,
        high speed network (network 192.0.2.0/24 in the diagram)
        that does not include the client. The protocol allows the
        client to setup the copy between the servers (over network
        203.0.113.0/24 in the diagram) and for the servers to
        communicate on the high speed network if they choose to
        do so.
      </t>

      <figure title="An example inter-server network topology." anchor="fig:inter-server">
        <artwork><![CDATA[
                          192.0.2.0/24
              +-------------------------------------+
              |                                     |
              |                                     |
              | 192.0.2.18                          | 192.0.2.56
      +-------+------+                       +------+------+
      |     Source   |                       | Destination |
      +-------+------+                       +------+------+
              | 203.0.113.18                        | 203.0.113.56
              |                                     |
              |                                     |
              |             203.0.113.0/24          |
              +------------------+------------------+
                                 |
                                 |
                                 | 203.0.113.243
                           +-----+-----+
                           |   Client  |
                           +-----------+
        ]]></artwork>
      </figure>

      <t>
        For an inter-server copy, the client notifies the source
        server that a file will be copied by the destination
        server using a COPY_NOTIFY operation. The client then
        initiates the copy by sending the COPY operation to the
        destination server. The destination server may perform the
        copy synchronously or asynchronously.
      </t>

      <t>
        A synchronous inter-server copy is shown in
        <xref target="fig:sync-inter-server" />. In this case, the
        destination server chooses to perform the copy before
        responding to the client's COPY request.
      </t>

      <t>
        An asynchronous copy is shown in
        <xref target="fig:async-inter-server" />. In this case, the
        destination server chooses to respond to the client's COPY
        request immediately and then perform the copy
        asynchronously.
      </t>

      <figure title="A synchronous inter-server copy." anchor="fig:sync-inter-server">
        <artwork><![CDATA[
  Client                Source         Destination
     +                    +                 +
     |                    |                 |
     |--- OPEN        --->|                 | Returns os1
     |<------------------/|                 |
     |                    |                 |
     |--- COPY_NOTIFY --->|                 |
     |<------------------/|                 |
     |                    |                 |
     |--- OPEN ---------------------------->| Returns os2
     |<------------------------------------/|
     |                    |                 |
     |--- COPY ---------------------------->|
     |                    |                 |
     |                    |                 |
     |                    |<----- read -----|
     |                    |\--------------->|
     |                    |                 |
     |                    |        .        | Multiple reads may
     |                    |        .        | be necessary
     |                    |        .        |
     |                    |                 |
     |                    |                 |
     |<------------------------------------/| Destination replies
     |                    |                 | to COPY
     |                    |                 |
     |--- CLOSE --------------------------->| Release open state
     |<------------------------------------/|
     |                    |                 |
     |--- CLOSE       --->|                 | Release open state
     |<------------------/|                 |
        ]]></artwork>
      </figure>

      <figure title="An asynchronous inter-server copy." anchor="fig:async-inter-server">
        <artwork><![CDATA[
  Client                Source         Destination
    +                    +                 +
    |                    |                 |
    |--- OPEN        --->|                 | Returns os1
    |<------------------/|                 |
    |                    |                 |
    |--- LOCK        --->|                 | Optional, could be done
    |<------------------/|                 | with a share lock
    |                    |                 |
    |--- COPY_NOTIFY --->|                 | Need to pass in
    |<------------------/|                 | os1 or lock state
    |                    |                 |
    |                    |                 |
    |                    |                 |
    |--- OPEN ---------------------------->| Returns os2
    |<------------------------------------/|
    |                    |                 |
    |--- LOCK ---------------------------->| Optional ...
    |<------------------------------------/|
    |                    |                 |
    |--- COPY ---------------------------->| Need to pass in
    |<------------------------------------/| os2 or lock state
    |                    |                 |
    |                    |                 |
    |                    |<----- read -----|
    |                    |\--------------->|
    |                    |                 |
    |                    |        .        | Multiple reads may
    |                    |        .        | be necessary
    |                    |        .        |
    |                    |                 |
    |                    |                 |
    |--- OFFLOAD_STATUS ------------------>| Client may poll
    |<------------------------------------/| for status
    |                    |                 |
    |                    |        .        | Multiple OFFLOAD_STATUS
    |                    |        .        | operations may be sent
    |                    |        .        |
    |                    |                 |
    |                    |                 |
    |                    |                 |
    |<-- CB_OFFLOAD -----------------------| Destination reports
    |\------------------------------------>| results
    |                    |                 |
    |--- LOCKU --------------------------->| Only if LOCK was done
    |<------------------------------------/|
    |                    |                 |
    |--- CLOSE --------------------------->| Release open state
    |<------------------------------------/|
    |                    |                 |
    |--- LOCKU       --->|                 | Only if LOCK was done
    |<------------------/|                 |
    |                    |                 |
    |--- CLOSE       --->|                 | Release open state
    |<------------------/|                 |
    |                    |                 |
        ]]></artwork>
      </figure>
    </section>

    <section title="Server-to-Server Copy Protocol" anchor="sec:SSC-proto">
      <t>
        The source server and destination server are not required to
        use a specific protocol to transfer the file data. The choice
        of what protocol to use is ultimately the destination server's
        decision. However, the destination server has to be cognizant
        that it is working on behalf of the client.
      </t>

      <section title="Considerations on Selecting a Copy Protocol">
        <t>
          The client can have requirements over both the size of
          transactions and error recovery semantics. It may want to
          split the copy up such that each chunk is synchronously
          transferred. It may want the copy protocol to copy the bytes
          in consecutive order such that upon an error, the client can
          restart the copy at the last known good offset. If the
          destination server cannot meet these requirements, the client
          may prefer the traditional copy mechanism such that it
          can meet those requirements.
        </t>
      </section>

      <section title="Using NFSv4.x as the Copy Protocol">
        <t>
          The destination server MAY use standard NFSv4.x (where x >= 1)
          operations to read the data from the source server. If NFSv4.x is used
          for the server-to-server copy protocol, the destination server
          can use the source filehandle and ca_src_stateid provided in the
          COPY request with standard NFSv4.x operations to read data
          from the source server.
        </t>
      </section>

      <section title="Using an Alternative Copy Protocol">
        <t>
          In a homogeneous environment, the source and destination servers
          might be able to perform the file copy extremely efficiently using
          specialized protocols. For example the source and destination
          servers might be two nodes sharing a common file system format for
          the source and destination file systems. Thus the source and destination
          are in an ideal position to efficiently render the image of the source
          file to the destination file by replicating the file system formats
          at the block level. Another possibility is that the source and
          destination might be two nodes sharing a common storage area network,
          and thus there is no need to copy any data at all, and instead
          ownership of the file and its contents might simply be re-assigned
          to the destination. To allow for these possibilities, the destination
          server is allowed to use a server-to-server copy protocol of its choice.
        </t>

        <t>
          In a heterogeneous environment, using a protocol other than NFSv4.x
          (e.g., HTTP <xref target="RFC2616" /> or FTP <xref target="RFC959" />)
          presents some challenges. In particular, the destination
          server is presented with the challenge of accessing the source file
          given only an NFSv4.x filehandle.
        </t>

        <t>
          One option for protocols that identify source files with path names
          is to use an ASCII hexadecimal representation of the source filehandle
          as the file name.
        </t>

        <t>
          Another option for the source server is to use URLs to direct the
          destination server to a specialized service. For example, the response
          to COPY_NOTIFY could include the URL ftp://s1.example.com:9999/_FH/0x12345,
          where 0x12345 is the ASCII hexadecimal representation of the source
          filehandle. When the destination server receives the source server's
          URL, it would use "_FH/0x12345" as the file name to pass to the FTP
          server listening on port 9999 of s1.example.com. On port
          9999 there would be a special instance of the FTP service that
          understands how to convert NFS filehandles to an open file descriptor
          (in many operating systems, this would require a new system call, one
          which is the inverse of the makefh() function that the pre-NFSv4 MOUNT
          service needs).
        </t>

        <t>
          Authenticating and identifying the destination server to the source
          server is also a challenge. Recommendations for how to accomplish
          this are given in <xref target="sec:SSC-no-rpc" />.
        </t>
      </section>
    </section>
  </section>

  <section title="Requirements for Operations" anchor="operations">
    <t>
      The implementation of server-side copy is OPTIONAL by the
      client and the server. However, in order to successfully copy
      a file, some operations MUST be supported by the client and/or
      server.
    </t>

    <t>
      If a client desires an intra-server file copy, then it MUST
      support the COPY and CB_OFFLOAD operations. If COPY returns a
      stateid, then the client MAY use the OFFLOAD_ABORT and OFFLOAD_STATUS
      operations.
    </t>

    <t>
      If a client desires an inter-server file copy, then it MUST
      support the COPY, COPY_NOTICE, and CB_OFFLOAD operations, and
      MAY use the OFFLOAD_REVOKE operation. If COPY returns a stateid,
      then the client MAY use the OFFLOAD_ABORT and OFFLOAD_STATUS
      operations.
    </t>

    <t>
      If a server supports intra-server copy, then the server MUST
      support the COPY operation. If a server’s COPY operation
      returns a stateid, then the server MUST also support these operations:
      CB_OFFLOAD, OFFLOAD_ABORT, and OFFLOAD_STATUS.
    </t>

    <t>
      If a source server supports inter-server copy, then the source
      server MUST support all these operations: COPY_NOTIFY and
      OFFLOAD_REVOKE. If a destination server supports inter-server
      copy, then the destination server MUST support the COPY
      operation. If a destination server’s COPY operation returns
      a stateid, then the destination server MUST also support these
      operations: CB_OFFLOAD, OFFLOAD_ABORT, COPY_NOTIFY, OFFLOAD_REVOKE,
      and OFFLOAD_STATUS.
    </t>

    <t>
      Each operation is performed in the context of the user identified
      by the ONC RPC credential of its containing COMPOUND or CB_COMPOUND
      request. For example, a OFFLOAD_ABORT operation issued by a given user
      indicates that a specified COPY operation initiated by the same user
      be canceled. Therefore a OFFLOAD_ABORT MUST NOT interfere with a copy
      of the same file initiated by another user.
    </t>

    <t>
      An NFS server MAY allow an administrative user to monitor or cancel
      copy operations using an implementation specific interface.
    </t>

    <section title="netloc4 - Network Locations">
      <t>
        The server-side copy operations specify network locations using
        the netloc4 data type shown below:
      </t>

      <?rfc include='autogen/type_netloc_type4.xml'?>

      <t>
        If the netloc4 is of type NL4_NAME, the nl_name field MUST be
        specified as a UTF-8 string. The nl_name is expected to be
        resolved to a network address via DNS, LDAP, NIS, /etc/hosts,
        or some other means. If the netloc4 is of type NL4_URL, a
        server URL <xref target="RFC3986" /> appropriate for the
        server-to-server copy operation is specified as a UTF-8 string.
        If the netloc4 is of type NL4_NETADDR, the nl_addr field MUST
        contain a valid netaddr4 as defined in Section 3.3.9 of
        <xref target="RFC5661" />.
      </t>

      <t>
        When netloc4 values are used for an inter-server copy as
        shown in <xref target="fig:inter-server" />, their values
        may be evaluated on the source server, destination server,
        and client. The network environment in which these systems
        operate should be configured so that the netloc4 values
        are interpreted as intended on each system.
      </t>
    </section>

    <section title="Copy Offload Stateids" anchor="ss:copy:stateid">
      <t>
        A server may perform a copy offload operation asynchronously.  An
        asynchronous copy is tracked using a copy offload stateid.  Copy
        offload stateids are included in the COPY, OFFLOAD_ABORT,
        OFFLOAD_STATUS, and CB_OFFLOAD operations.
      </t>

      <t>
        A copy offload stateid will be valid until either (A) the client or
        server restarts or (B) the client returns the resource by issuing a
        OFFLOAD_ABORT operation or the client replies to a CB_OFFLOAD
        operation.
      </t>

      <t>
        A copy offload stateid's seqid MUST NOT be 0.  In the context of a
        copy offload operation, it is ambiguous to indicate the most recent
        copy offload operation using a stateid with seqid of 0.  Therefore a
        copy offload stateid with seqid of 0 MUST be considered invalid.
      </t>
    </section>
  </section>

  <section anchor="ss:copy:security" title="Security Considerations">
    <t>
      The security considerations pertaining to NFSv4 <xref target="I-D.ietf-nfsv4-rfc3530bis" />
      apply to this chapter.
    </t>

    <t>
      The standard security mechanisms provide by NFSv4 <xref target="I-D.ietf-nfsv4-rfc3530bis" />
      may be used to secure the protocol described in this chapter.
    </t>

    <t>
      NFSv4 clients and servers supporting the inter-server copy
      operations described in this chapter are REQUIRED to implement
      the mechanism described in <xref target="sec:SSC-rpc-with-gss" />, 
      and to support rejecting COPY_NOTIFY requests that do not use
      RPCSEC_GSS with privacy.  If the server-to-server copy protocol
      is ONC RPC based, the servers are also REQUIRED to implement <xref
      target="rpcsec_gssv3" /> including the RPCSEC_GSSv3 copy_to_auth,
      copy_from_auth, and copy_confirm_auth structured privileges.
      This requirement to implement is not a requirement to use;
      for example, a server may depending on configuration also allow
      COPY_NOTIFY requests that use only AUTH_SYS.
    </t>

    <section title="Inter-Server Copy Security" anchor="sec:SSC-sec">
      <section title="Requirements for Secure Inter-Server Copy">
        <t>
          Inter-server copy is driven by several requirements:
        </t>

        <t>
          <list style="symbols">
            <t>
              The specification must provide guidance for using NFSv4.x
              as a copy protocol. For those source and destination
              servers willing to use NFSv4.x there are specific security
              considerations that this specification can and does address.
            </t>

            <t>
              The specification must not mandate preconfiguration
              between the source and destination server. Requiring
              that the source and destination first have a "copying
              relationship" increases the administrative burden. However
              the specification MUST NOT preclude implementations that
              require preconfiguration.
            </t>

            <t>
              The specification must not mandate a trust relationship
              between the source and destination server. The NFSv4
              security model requires mutual authentication between
              a principal on an NFS client and a principal on an NFS
              server. This model MUST continue with the introduction
              of COPY.
            </t>
          </list>
        </t>
      </section>

      <section title="Inter-Server Copy via ONC RPC with RPCSEC_GSSv3"  anchor="sec:SSC-rpc-with-gss">
        <t>
          When the client sends a COPY_NOTIFY to the source server to
          expect the destination to attempt to copy data from the source
          server, it is expected that this copy is being done on behalf
          of the principal (called the "user principal") that sent the
          RPC request that encloses the COMPOUND procedure that contains
          the COPY_NOTIFY operation.  The user principal is identified
          by the RPC credentials.  A mechanism that allows the user
          principal to authorize the destination server to perform the
          copy, that lets the source server properly authenticate the
          destination's copy, and does not allow the destination server
          to exceed this authorization, is necessary.
        </t>

        <t>
          An approach that sends delegated credentials of the client's
          user principal to the destination server is not used for
          the following reason.  If the client's user delegated its
          credentials, the destination would authenticate as the user
          principal.  If the destination were using the NFSv4 protocol
          to perform the copy, then the source server would authenticate
          the destination server as the user principal, and the file
          copy would securely proceed.  However, this approach would
          allow the destination server to copy other files.  The user
          principal would have to trust the destination server to not
          do so.  This is counter to the requirements, and therefore is
          not considered.
        </t>

        <t>
          Instead, we employ a combination of two features of the
          RPCSEC_GSSv3 <xref target="rpcsec_gssv3" /> protocol: compound
          authentication and RPC application defined structured privilege
          assertions. The combination of these features allows the
          destination server to authenticate to the source server as
          acting on behalf of the user principal, and to authorize the
          destination server to perform READs of the file to be copied
          from the source on behalf of the user principal. Once the copy
          is complete, the client can destroy the RPCSEC_GSSv3 handles
          to end the source and destination servers authorization to copy.
        </t>

        <t>
          RPCSEC_GSSv3 introduces the notion of RPC application defined
          structured privileges.  We define three structured privileges
          that work in tandem to authorize the copy:
        </t>

        <t>
          <list style="hanging">
            <t hangText="copy_from_auth:">
              A user principal is authorizing a source principal
              ("nfs@&lt;source&gt;") to allow a destination principal
              ("nfs@&lt;destination&gt;") to setup the copy_confirm_auth
              privilege required to copy a file from the source to the
              destination on behalf of the user principal.
              This privilege is established on the source server before
              the user principal sends a COPY_NOTIFY operation to the source
              server, and the resultant RPCSEC_GSSv3 context is used to secure
              the COPY_NOTIFY operation.

              <vspace blankLines="1" />
              <?rfc include='autogen/copy_from_auth.xml'?>
              <vspace blankLines="1" />

              cfp_shared_secret is an automatically generated random number
              secret value.
            </t>

            <t hangText="copy_to_auth:">
              A user principal is authorizing a destination principal
              ("nfs@&lt;destination&gt;") to setup a copy_confirm_auth
              privilege with a source principal ("nfs@&lt;source&gt;") to
              allow it to copy a file from the source to the destination
              on behalf of the user principal.  This privilege is
              established on the destination server before the user
              principal sends a COPY operation to the destination server,
              and the resultant RPCSEC_GSSv3 context is used to secure
              the COPY operation.

              <vspace blankLines="1" />
              <?rfc include='autogen/copy_to_auth.xml'?>
              <vspace blankLines="1" />

              ctap_shared_secret is the automatically generated secret
              value used to establish the copy_from_auth privilege with
              the source principal.  ctap_handle, ctap_handle_vers,
              ctap_nounce, and ctap_nounce_mic are used to construct the
              compound authentication portion of the copy_confirm_auth
              RPCSEC_GSSv3 context between the destination server and
              the source server (See <xref target="sec:SSC-sec-estab" />).
            </t>

            <t hangText="copy_confirm_auth:">
              A destination principal ("nfs@&lt;destination&gt;") is
              confirming with the source principal ("nfs@&lt;source&gt;")
              that it is authorized to copy data from the source. Note
              that besides the rpc_gss3_privs payload (struct
              copy_confirm_auth_priv), the copy_confirm_auth
              RPCSEC_GSS3_CREATE message also contains an
              rpc_gss3_gss_binding payload so that the copy is done on
              behalf of the user principal.  This privilege is established
              on the destination server before the file is copied from
              the source to the destination. The resultant RPCSEC_GSSv3
              context is used to secure the READ operations from the
              source to the destination server.

              <vspace blankLines="1" />
              <?rfc include='autogen/copy_confirm_auth.xml'?>
              <vspace blankLines="1" />
            </t>
          </list>
        </t>

        <section title="Establishing a Security Context" anchor="sec:SSC-sec-estab">
          <t>
            The RPCSEC_GSSv3 compound authentication feature allows a server
            to act on behalf of a user if the server identifies the user
            and trusts the client. In the inter-server server side copy
            case, the server is the source server, and the client is the
            destination server acting as a client when performing the copy.
	  </t>

          <t>
            The user principal is not required (nor expected) to have
            an RPCSEC_GSS secured connection and context between the
            destination server (acting as a client) and the source server.
            The user principal does have an RPCSEC_GSS secured connection
            and context between the client and the source server established
            for the OPEN of the file to be copied.
          </t>

          <t>
            We use the RPCSEC_GSS context established between the user
            principal and the source server to OPEN the file to be copied
            to provide the the necessary user principal identification
            to the source server from the destination server (acting as
            a client). This is accomplished by sending the user principal
            identification information: e.g the rpc_gss3_gss_binding fields,
            in the copy_to_auth privilege established between the client and
            the destination server. This same information is then placed
            in the rpc_gss3_gss_binding fields of the copy_confirm_auth
            RPCSEC_GSS3_CREATE message sent from the destination server
            (acting as a client) to the source server.
          </t>

          <t>
            When the user principal wants to COPY a file between two
            servers, if it has not established copy_from_auth and
            copy_to_auth privileges on the servers, it establishes them:
          </t>

          <t>
            <list style="symbols">
              <t>
                As noted in <xref target="rpcsec_gssv3" /> the client uses
                an existing RPCSEC_GSSv1 (or v2) context termed the "parent"
                handle to establish and protect RPCSEC_GSSv3 exchanges.
                The copy_from_auth privilege will use the context
                established between the user principal and the source
                server used to OPEN the source file as the RPCSEC_GSSv3
                parent handle. The copy_to_auth privilege will use the
                context established between the user principal and the
                destination server used to OPEN the destination file as
                the RPCSEC_GSSv3 parent handle.
              </t>

              <t>
                A random number is generated to use as a secret to be shared
                between the two servers.  This shared secret will be placed
                in the cfap_shared_secret and ctap_shared_secret fields of
                the appropriate privilege data types, copy_from_auth_priv
                and copy_to_auth_priv.  Because of this shared_secret the
                RPCSEC_GSS3_CREATE control messages for copy_from_auth
                and copy_to_auth MUST use a QOP of rpc_gss_svc_privacy.
              </t>

              <t>
                An instance of copy_from_auth_priv is filled in with the
                shared secret, the destination server, and the NFSv4 user id
                of the user principal and is placed in rpc_gss3_create_args
                assertions[0].assertion.privs.privilege. The
                string "copy_from_auth" is placed in
                assertions[0].assertion.privs.name.  The field
                assertions[0].critical is set to TRUE. The source server
                unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE payload
                and verifies that the NFSv4 user id being asserted matches
                the source server's mapping of the user principal.  If it
                does, the privilege is established on the source server as:
                &lt;"copy_from_auth", user id, destination&gt;.  The field
                "handle" in a successful reply is the RPCSEC_GSSv3 "child"
                handle that the client will use on COPY_NOTIFY requests
                to the source server involving the destination server.
                granted_assertions[0].assertion.privs.name will be equal to
                "copy_from_auth".
              </t>

              <t>
                An instance of copy_to_auth_priv is filled in with the
                shared secret, the cnr_source_server list returned
                by COPY_NOTIFY, and the NFSv4 user id of the user
                principal.  The next four fields are passed in the
                copy_to_auth privilege to be used by the copy_confirm_auth
                rpc_gss3_gss_binding fields as explained above.  A nounce
                is created, and GSS_MIC() is invoked on the nounce using
                the RPCSEC_GSSv1 (or v2) context shared between user
                principal and the source server. The nounce, nounce MIC,
                context handle used to create the nounce MIC, and the
                context handle version are added to the copy_to_auth_priv
                instance which is placed in rpc_gss3_create_args
                assertions[0].assertion.privs.privilege. The
                string "copy_to_auth" is placed in
                assertions[0].assertion.privs.name. The field
                assertions[0].critical is set to TRUE. The destination
                server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE
                payload and verifies that the NFSv4 user id being asserted
                matches the destination server's mapping of the user
                principal.  If it does, the privilege is established on
                the destination server as: &lt;"copy_to_auth", user id,
                source list, nounce, nounce MIC, context handle, handle
                version&gt;.  The field "handle" in a successful reply is
                the RPCSEC_GSSv3 "child" handle that the client will use
                on COPY requests to the destination server involving the
                source server.  granted_assertions[0].assertion.privs.name
                will be equal to "copy_to_auth".
              </t>
            </list>
          </t>

          <t>
            As noted in <xref target="rpcsec_gssv3" /> Section 2.3.1 "Create
            Request", both the client and the source server should associate
            the RPCSEC_GSSv3 "child" handle with the parent RPCSEC_GSSv1
            (or v2) handle used to create the RPCSEC_GSSv3 child handle.
          </t>
        </section>

        <section title="Starting a Secure Inter-Server Copy">
          <t>
            When the client sends a COPY_NOTIFY request to the source
            server, it uses the privileged "copy_from_auth" RPCSEC_GSSv3
            handle.  cna_destination_server in COPY_NOTIFY MUST be the
            same as cfap_destination specified in copy_from_auth_priv.
            Otherwise, COPY_NOTIFY will fail with NFS4ERR_ACCESS.  The
            source server verifies that the privilege &lt;"copy_from_auth",
            user id, destination&gt; exists, and annotates it with the
            source filehandle, if the user principal has read access to
            the source file, and if administrative policies give the user
            principal and the NFS client read access to the source file
            (i.e., if the ACCESS operation would grant read access).
            Otherwise, COPY_NOTIFY will fail with NFS4ERR_ACCESS.
          </t>

          <t>
            When the client sends a COPY request to the destination server,
            it uses the privileged "copy_to_auth" RPCSEC_GSSv3 handle.
            ca_source_server list in COPY MUST be the same as ctap_source
            list specified in copy_to_auth_priv.  Otherwise, COPY will fail
            with NFS4ERR_ACCESS.  The destination server verifies that the
            privilege &lt;"copy_to_auth", user id, source list, nounce,
            nounce MIC, context handle, handle version&gt; exists, and
            annotates it with the source and destination filehandles.
            If the COPY returns a wr_callback_id, then this is an
            asynchronous copy and the wr_callback_id must also must be
            annotated to the copy_to_auth privilege.  If the client has
            failed to establish the "copy_to_auth" privilege it will reject
            the request with NFS4ERR_PARTNER_NO_AUTH.
          </t>

          <t>
            If either the COPY_NOTIFY, or the COPY operations fail, the
            associated "copy_from_auth" and "copy_to_auth" RPCSEC_GSSv3
            handles MUST be destroyed.
          </t>
        </section>

        <section title="Securing ONC RPC Server-to-Server Copy Protocols">
          <t>
            After a destination server has a "copy_to_auth" privilege
            established on it, and it receives a COPY request, if it knows
            it will use an ONC RPC protocol to copy data, it will establish
            a "copy_confirm_auth" privilege on the source server prior to
            responding to the COPY operation as follows:
          </t>

          <t>
            <list style="symbols">
              <t>
                Before establishing an RPCSEC_GSSv3 context, a parent
                context needs to exist between nfs@&lt;destination&gt;
                as the initiator principal, and nfs@&lt;source&gt;
                as the target principal.  If NFS is to be used as the
                copy protocol, this means that the destination server
                must mount the source server using RPCSEC_GSS.
              </t>

              <t>
                An instance of copy_confirm_auth_priv is filled in
                with information from the established "copy_to_auth"
                privilege. The value of the field ccap_shared_secret_mic
                is a GSS_GetMIC() of the ctap_shared_secret in the
                copy_to_auth privilege using the parent handle context.
                The field ccap_username is the mapping of the user
                principal to an NFSv4 user name ("user"@"domain" form),
                and MUST be the same as the ctap_username in the
                copy_to_auth privilege.  The copy_confirm_auth_priv
                instance is placed in rpc_gss3_create_args
                assertions[0].assertion.privs.privilege.
                The string "copy_confirm_auth" is placed in
                assertions[0].assertion.privs.name.  The field
                assertions[0].critical is set to TRUE.
              </t>

              <t>
                The copy_confirm_auth RPCSEC_GSS3_CREATE call also
                includes a compound authentication component. The
                rpc_gss3_gss_binding fields are filled in with information
                from the established "copy_to_auth" privilege (see <xref
                target="sec:SSC-sec-estab" />).  The ctap_handle_vers,
                ctap_handle, ctap_nounce, and ctap_nounce_mic are
                assigned to the vers, handle, nounce, and mic fields of
                an rpc_gss3_gss_binding instance respectively.
              </t>

              <t>
                The RPCSEC_GSS3_CREATE copy_from_auth message is sent to the
                source server with a QOP of rpc_gss_svc_privacy. The source
                server unwraps the rpc_gss_svc_privacy RPCSEC_GSS3_CREATE
                payload and verifies the cap_shared_secret_mic by
                calling GSS_VerifyMIC() using the parent context on the
                cfap_shared_secret from the established "copy_from_auth"
                privilege, and verifies the that the ccap_username equals
                the cfap_username.  The source server then locates the
                ctap_handle in it's GSS context cache and verifies that
                the handle belongs to the user principal that maps to
                the ccap_username and that the cached handle version
                equals ctap_handle_vers. The ctap_nounce_mic is verified
                by calling GSS_VerifyMIC() on the ctap_nounce using the
                cached handle context.  If all verification succeeds, the
                "copy_confirm_auth" privilege is established on the source
                server as &lt; "copy_confirm_auth", shared_secret_mic,
                user id, nounce, nounce MIC, context handle, context
                handle version&gt;, and the resultant child handle
                is noted to be acting on behalf of the user principal.
                If the source server fails to verify either the privilege
                or the compound_binding, the COPY operation will be rejected
                with NFS4ERR_PARTNER_NO_AUTH.
              </t>

              <t>
                All subsequent ONC RPC requests sent from the destination
                to copy data from the source to the destination will
                use the RPCSEC_GSSv3 handle returned by the source's
                RPCSEC_GSS3_CREATE response. Note that as per the Compound
                Authentication section of <xref target="rpcsec_gssv3" />
                the resultant RPCSEC_GSSv3 context handle is bound to
                the user principal RPCSEC_GSS context and so it MUST be
                treated by servers as authenticating the user principal.
              </t>
            </list>
          </t>

          <t>
            Note that the use of the "copy_confirm_auth" privilege accomplishes
            the following:

            <list style="symbols">
              <t>
                If a protocol like NFS is being used, with export policies,
                export policies can be overridden in case the destination
                server as-an-NFS-client is not authorized
              </t>

              <t>
                Manual configuration to allow a copy relationship between
                the source and destination is not needed.
              </t>
            </list>
          </t>
        </section>

        <section title="Finishing or Stopping a Secure Inter-Server Copy">
          <t>
            Under normal operation, the client MUST destroy the
            copy_from_auth and the copy_to_auth RPCSEC_GSSv3 handle once
            the COPY operation returns for a synchronous inter-server copy
            or a CB_OFFLOAD reports the result of an asynchronous copy.
          </t>

          <t>
            The copy_confirm_auth privilege and compound authentication
            RPCSEC_GSSv3 handle is constructed from information held
            by the copy_to_auth privilege, and MUST be destroyed by the
            destination server (via an RPCSEC_GSS3_DESTROY call) when the
            copy_to_auth RPCSEC_GSSv3 handle is destroyed.
          </t>

          <t>
            If the client sends a OFFLOAD_REVOKE to the source server to
            rescind the destination server's synchronous copy privilege, it
            uses the privileged "copy_from_auth" RPCSEC_GSSv3 handle and the
            cra_destination_server in OFFLOAD_REVOKE MUST be the same as the
            name of the destination server specified in copy_from_auth_priv.
            The source server will then delete the &lt;"copy_from_auth",
            user id, destination&gt; privilege and fail any subsequent
            copy requests sent under the auspices of this privilege from
            the destination server. The client MUST destroy both the
            "copy_from_auth" and the "copy_to_auth" RPCSEC_GSSv3 handles.
          </t>

          <t>
            If the client sends a OFFLOAD_STATUS to the destination
            server to check on the status of an asynchronous copy, it
            uses the privileged "copy_to_auth" RPCSEC_GSSv3 handle and
            the osa_stateid in OFFLOAD_STATUS MUST be the same as the
            wr_callback_id specified in the "copy_to_auth" privilege stored
            on the destination server.
          </t>

          <t>
            If the client sends a OFFLOAD_ABORT to the destination server
            to cancel an asynchronous copy, it uses the privileged
            "copy_to_auth" RPCSEC_GSSv3 handle and the oaa_stateid
            in OFFLOAD_ABORT MUST be the same as the wr_callback_id
            specified in the "copy_to_auth" privilege stored on the
            destination server. The destination server will then delete the
            &lt;"copy_to_auth", user id, source list, nounce, nounce MIC,
            context handle, handle version&gt; privilege and the associated
            "copy_confirm_auth" RPCSEC_GSSv3 handle.  The client MUST
            destroy both the copy_to_auth and copy_from_auth RPCSEC_GSSv3
            handles.
          </t>
        </section>
      </section>

      <section title="Inter-Server Copy via ONC RPC without RPCSEC_GSS" anchor="sec:SSC-rpc-no-gss">
        <t>
          ONC RPC security flavors other than RPCSEC_GSS MAY be used
          with the server-side copy offload operations described in this
          chapter.  In particular, host-based ONC RPC security flavors
          such as AUTH_NONE and AUTH_SYS MAY be used.  If a host-based
          security flavor is used, a minimal level of protection for
          the server-to-server copy protocol is possible.
        </t>

        <t>
          In the absence of a strong security mechanism designed for the
          purpose, the challenge is how the source server and destination
          server identify themselves to each other, especially in the
          presence of multi-homed source and destination servers. In
          a multi-homed environment, the destination server might
          not contact the source server from the same network address
          specified by the client in the COPY_NOTIFY. This can be overcome
          using the procedure described below.
        </t>

        <t>
          When the client sends the source server the COPY_NOTIFY
          operation, the source server may reply to the client with
          a list of target addresses, names, and/or URLs and assign
          them to the unique quadruple: &lt;random number, source fh,
          user ID, destination address Y&gt;.  If the destination uses
          one of these target netlocs to contact the source server,
          the source server will be able to uniquely identify the
          destination server, even if the destination server does not
          connect from the address specified by the client in COPY_NOTIFY.
          The level of assurance in this identification depends on the
          unpredictability, strength and secrecy of the random number.
        </t>

        <t>
          For example, suppose the network topology is as shown in
          <xref target="fig:inter-server" />.  If the source filehandle
          is 0x12345, the source server may respond to a COPY_NOTIFY
          for destination 203.0.113.56 with the URLs:
        </t>

        <t>
          <list style="empty">
            <t>nfs://203.0.113.18//_COPY/FvhH1OKbu8VrxvV1erdjvR7N/203.0.113.56/_FH/0x12345</t>
            <t>nfs://192.0.2.18//_COPY/FvhH1OKbu8VrxvV1erdjvR7N/203.0.113.56/_FH/0x12345</t>
          </list>
        </t>

        <t>
          The name component after _COPY is 24 characters of base 64, more than enough
          to encode a 128 bit random number.
        </t>

        <t>
          The client will then send these URLs to the destination server
          in the COPY operation. Suppose that the 192.0.2.0/24 network
          is a high speed network and the destination server decides to
          transfer the file over this network. If the destination
          contacts the source server from 192.0.2.56 over this network
          using NFSv4.1, it does the following:
        </t>

        <t>
          <list style="hanging">
            <t hangText="COMPOUND"> { PUTROOTFH, LOOKUP "_COPY" ;
              LOOKUP "FvhH1OKbu8VrxvV1erdjvR7N" ;
              LOOKUP "203.0.113.56";
              LOOKUP "_FH" ; OPEN "0x12345" ; GETFH }
            </t>
          </list>
        </t>

        <t>
          Provided that the random number is unpredictable and has been kept secret
          by the parties involved, the source server will therefore know that these
          NFSv4.x operations are being issued by the destination server identified
          in the COPY_NOTIFY.  This random number technique only provides initial
          authentication of the destination server, and cannot defend against
          man-in-the-middle attacks after authentication or an eavesdropper that
          observes the random number on the wire. Other secure communication
          techniques (e.g., IPsec) are necessary to block these attacks.
        </t>

        <t>
          Servers SHOULD reject COPY_NOTIFY requests that do not use
          RPCSEC_GSS with privacy, thus ensuring the URL in the
          COPY_NOTIFY reply is encrypted.  For the same reason, clients
          SHOULD send COPY requests to the destination using RPCSEC_GSS
          with privacy.
        </t>
      </section>

      <section title="Inter-Server Copy without ONC RPC" anchor="sec:SSC-no-rpc">
        <t>
          The same techniques as <xref target="sec:SSC-rpc-no-gss" />,
          using unique URLs for each destination server, can be used for other
          protocols (e.g., HTTP <xref target="RFC2616" /> and
          FTP <xref target="RFC959" />) as well.
        </t>
      </section>
    </section>
  </section>
</section>
