<section anchor='ss:adb:init' title='Operation 64: INITIALIZE'>
  <t>
    The server has no concept of the structure imposed
    by the application. It is only when the application
    writes to a section of the file does order get imposed.
    In order to detect corruption even before the application
    utilizes the file, the application will want to initialize
    a range of ADBs. It uses the INITIALIZE operation to do so.
  </t>

  <section toc='exclude' title="ARGUMENT">
    <?rfc include='autogen/initialize_args.xml'?>
  </section>

  <section toc='exclude' title="RESULT">
    <?rfc include='autogen/initialize_res.xml'?>
  </section>

  <section toc='exclude' title="DESCRIPTION">
    <t>
      When the client invokes the INITIALIZE operation, it has
      two desired results:
    </t>

    <t>
      <list style='numbers'>
        <t>
          The structure described by the app_data_block4 be imposed
          on the file.
        </t>

        <t>
          The contents described by the app_data_block4 be sparse.
        </t>
      </list>
    </t>

    <t>
      If the server supports the INITIALIZE operation, it still
      might not support sparse files. So if it receives the
      INITIALIZE operation, then it MUST populate the contents
      of the file with the initialized ADBs. In other words,
      if the server supports INITIALIZE, then it supports
      the concept of ADBs.

      <cref anchor='AI1' source='TH'>
        Do we want to support an asynchronous INITIALIZE?
        Do we have to?
      </cref>
    </t>

    <t>
      If the data was already initialized, There are two
      interesting scenarios:
    </t>

    <t>
      <list style='numbers'>
        <t>
          The data blocks are allocated.
        </t>

        <t>
          Initializing in the middle of an existing ADB.
        </t>
      </list>
    </t>

    <t>
      If the data blocks were already allocated, then
      the INITIALIZE is a hole punch operation. If
      INITIALIZE supports sparse files, then the data
      blocks are to be deallocated. If not, then the
      data blocks are to be rewritten in the indicated
      ADB format.

      <cref anchor='AI2' source='TH'>
        Need to document interaction between space
        reservation and hole punching?
      </cref>
    </t>

    <t>
      Since the server has no knowledge of ADBs, it
      should not report misaligned creation of ADBs.
      Even while it can detect them, it cannot disallow
      them, as the application might be in the process of
      changing the size of the ADBs. Thus the server
      must be prepared to handle an INITIALIZE into
      an existing ADB.
    </t>

    <t>
      This document does not mandate the manner in
      which the server stores ADBs sparsely for a
      file. It does assume that if ADBs are stored
      sparsely, then the server can detect when
      an INITIALIZE arrives that will force a new
      ADB to start inside an existing ADB. For
      example, assume that ADBi has a adb_block_size
      of 4k and that an INITIALIZE starts 1k inside
      ADBi. The server should

      <cref anchor='AI3' source='TH'>
        Need to flesh this out.
      </cref>
    </t>
  </section>
</section>
