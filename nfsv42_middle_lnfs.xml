<!-- Copyright (C) The IETF Trust (2011) -->
<!-- Copyright (C) The Internet Society (2011) -->
  
<section anchor="sec:lnfs" title="Labeled NFS">
  <section anchor="ss:lnfs:intro" title="Introduction">
    <t>
      Access control models such as Unix permissions or Access Control
      Lists are commonly referred to as Discretionary Access Control (DAC)
      models.  These systems base their access decisions on user identity
      and resource ownership.  In contrast Mandatory Access Control (MAC)
      models base their access
      control decisions on the label on the subject (usually a process) and
      the object it wishes to access <xref target='ref:lnfs_req' />.  These
      labels may contain user identity information but usually contain additional information.  In
      DAC systems users are free to specify the access rules for resources
      that they own.  MAC models base their security decisions on a system
      wide policy established by an administrator or organization which the
      users do not have the ability to override.  In this section, we add
      a MAC model to NFSv4.
    </t>
  
    <t>
      The first change necessary is to devise a method for transporting
      and storing security label data on NFSv4 file objects.  Security
      labels have several semantics that are met by NFSv4 recommended
      attributes such as the ability to set the label value upon object
      creation.  Access control on these attributes are done through a
      combination of two mechanisms.  As with other recommended attributes
      on file objects the usual DAC checks (ACLs and permission bits) will
      be performed to ensure that proper file ownership is enforced.  In
      addition a MAC system MAY be employed on the client, server, or both to
      enforce additional policy on what subjects may modify security label
      information.
    </t>
  
    <t>
      The second change is to provide a method for the server to
      notify the client that the attribute changed on an open
      file on the server. If the file is closed, then during the
      open attempt, the client will gather the new attribute value.
      The server MUST not communicate the new value of the attribute,
      the client MUST query it. This requirement stems from the
      need for the client to provide sufficient access rights to
      the attribute.
    </t>
  
    <t>
      The final change necessary is a modification to the RPC layer used
      in NFSv4 in the form of a new version of the
      RPCSEC_GSS <xref target='ref:RFC2203' /> framework.
      In order for an NFSv4 server to apply MAC checks it must obtain
      additional information from the client.  Several methods were explored for
      performing this and it was decided that the best approach was to
      incorporate the ability to make security attribute assertions through
      the RPC mechanism.  RPCSECGSSv3 <xref target='ref:rpcsecgssv3' />
      outlines a method to assert additional security information
      such as security labels on gss context creation and have that data
      bound to all RPC requests that make use of that context.
    </t>
  </section>
  
  <section anchor='ss:lnfs:defs' title='Definitions'>
    <t>
      <list style='hanging'>
        <t hangText='Label Format Specifier (LFS):'>
          is an identifier used by the client to establish
          the syntactic format of the security label and the semantic meaning
          of its components.  These specifiers exist in a registry associated
          with documents describing the format and semantics of the label.
        </t>
  
        <t hangText='Label Format Registry:'>
          is the IANA registry containing all registered
          LFS along with references to the documents that
          describe the syntactic format and semantics of the security label.
        </t>
  
        <t hangText='Policy Identifier (PI):'>
          is an optional part of the definition of a Label
          Format Specifier which allows for clients and server to identify
          specific security policies.
        </t>
  
        <t hangText='Object:'>
          is a passive resource within the system that we
          wish to be protected.  Objects can be entities such as files,
          directories, pipes, sockets, and many other system resources relevant
          to the protection of the system state.
        </t>
  
        <t hangText='Subject:'>
          A subject is an active entity usually a process which is
          requesting access to an object.
        </t>
    
        <t hangText='Multi-Level Security (MLS):'>
          is a traditional model where objects are given a sensitivity
          level (Unclassified, Secret, Top Secret,  etc) and a category set
          <xref target='ref:rh_mls' />.
        </t>
      </list>
    </t>
  </section>
  
  <section anchor="ss:lnfs:macsec" title="MAC Security Attribute">
    <t>
      MAC models base access decisions on security attributes bound to
      subjects and objects.  This information can range from a user
      identity for an identity based MAC model, sensitivity levels for
      Multi-level security, or a type for Type Enforcement.  These models
      base their decisions on different criteria but the semantics of the
      security attribute remain the same.  The semantics required by the
      security attributes are listed below:
    </t>
  
    <t>
      <list style='symbols'>
        <t>
          Must provide flexibility with respect to MAC model.
        </t>
  
        <t>
          Must provide the ability to atomically set security information
          upon object creation
        </t>
  
        <t>
          Must provide the ability to enforce access control decisions both
          on the client and the server
        </t>
  
        <t>
          Must not expose an object to either the client or server name
          space before its security information has been bound to it.
        </t>
      </list>
    </t>
  
    <t>
      NFSv4 implements the security attribute as a
      recommended attribute.  These attributes have a fixed format
      and semantics, which
      conflicts with the flexible nature of the security attribute.  To
      resolve this the security attribute consists of two components.  The
      first component is a LFS as defined in <xref target='ref:lfsreg' />
      to allow for interoperability between MAC
      mechanisms.  The second component is an opaque field which is the actual
      security attribute data.  To allow for various MAC models NFSv4
      should be used solely as a transport mechanism for the security
      attribute.  It is the responsibility of the endpoints to consume the
      security attribute and make access decisions based on their
      respective models.  In addition, creation of objects through OPEN and
      CREATE allows for the security attribute to be specified upon
      creation.  By providing an atomic create and set operation for the
      security attribute it is possible to enforce the second and fourth
      requirements.  The recommended attribute FATTR4_SEC_LABEL will
      be used to satisfy this requirement.
    </t>
  
    <section anchor='ss:macss:lnfs:interpret' title='Interpreting FATTR4_SEC_LABEL'>
      <t>
        The XDR <xref target='ref:RFC4506' /> necessary to implement Labeled
        NFSv4 is presented below:
      </t>
  
      <figure anchor='fig:xdr'>
        <artwork>
const FATTR4_SEC_LABEL   = 81;
  
typedef uint32_t  policy4;
        </artwork>
      </figure>

      <?rfc include='autogen/type_label_format.xml'?>
  
      <t>
        The FATTR4_SEC_LABEL contains an array of two components with the first
        component being an LFS.  It serves to provide the receiving end
        with the information necessary to translate the security attribute
        into a form that is usable by the endpoint.  Label Formats assigned
        an LFS may optionally choose to include a Policy Identifier
        field to allow for complex policy deployments.  The LFS
        and Label Format Registry are described in detail in
        <xref target='ref:lfsreg' />.
        The translation used to interpret the security
        attribute is not specified as part of the protocol as it may depend
        on various factors.  The second component is an opaque section which
        contains the data of the attribute.  This component is dependent on
        the MAC model to interpret and enforce.
      </t>
      <t>
        In particular, it is the responsibility of the LFS specification
        to define a maximum size for the opaque section, slai_data&lt;&gt;.
        When creating or modifying a label for an object, the client
        needs to be guaranteed that the server will accept a label
        that is sized correctly. By both client and server being part
        of a specific MAC model, the client will be aware of the size.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:delegs' title='Delegations'>
      <t>
        In the event that a security attribute is changed on the server while
        a client holds a delegation on the file, the client should follow the
        existing protocol with respect to attribute changes.  It should flush
        all changes back to the server and relinquish the delegation.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:perms' title='Permission Checking'>
      <t>
        It is not feasible to enumerate all possible MAC models and even
        levels of protection within a subset of these models.  This means
        that the NFSv4 client and servers cannot be expected to directly
        make access control decisions based on the security attribute.
        Instead NFSv4 should defer permission checking on this attribute to
        the host system.  These checks are performed in addition to existing
        DAC and ACL checks outlined in the NFSv4 protocol.
        <xref target='ss:lnfs:modes' />  gives a
        specific example of how the security attribute is handled under a
        particular MAC model.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:objects' title='Object Creation'>
      <t>
        When creating files in NFSv4 the OPEN and CREATE operations are used.
        One of the parameters to these operations is an fattr4 structure
        containing the attributes the file is to be created with.  This
        allows NFSv4 to atomically set the security attribute of files upon
        creation.  When a client is MAC aware it must always provide the
        initial security attribute upon file creation.  In the event that the
        server is the only MAC aware entity in the system it should ignore
        the security attribute specified by the client and instead make the
        determination itself.  A more in depth explanation can be found in
        <xref target='ss:lnfs:modes' />.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:existing' title='Existing Objects'>
      <t>
        Note that under the MAC model, all objects must have labels.
        Therefore, if an existing server is upgraded to include LNFS support,
        then it is the responsibility of the security system to
        define the behavior for existing objects. For example, if
        the security system is LFS 0, which means the server just
        stores and returns labels, then existing files should
        return labels which are set to an empty value.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:changes' title='Label Changes'>
      <t>
        As per the requirements, when a file's security label is
        modified, the server must notify all clients which have
        the file opened of the change in label. It does so with
        CB_ATTR_CHANGED. There are preconditions to making an
        attribute change imposed by NFSv4 and the security system might
        want to impose others. In the process of meeting these
        preconditions, the server may chose to either serve
        the request in whole or return NFS4ERR_DELAY to the
        SETATTR operation.
      </t>
  
      <t>
        If there are open delegations on the file
        belonging to client other than the one making the label
        change, then the process described in
        <xref target='ss:macss:lnfs:delegs' /> must be followed.
      </t>
  
      <t>
        As the server is always presented with the subject
        label from the client, it does not necessarily need to
        communicate the fact that the label has changed to
        the client. In the cases where the change outright denies
        the client access, the client will be able to quickly
        determine that there is a new label in effect. It is
        in cases where the client may share the same object
        between multiple subjects or a security system which
        is not strictly hierarchical that the CB_ATTR_CHANGED callback is
        very useful. It allows the server to inform the clients
        that the cached security attribute is now stale.
      </t>
  
      <t>
        Consider a system in which the clients enforce MAC checks and
        and the server has a very simple security
        system which just stores the labels. In this system, the
        MAC label check always allows access, regardless of the
        subject label. 
      </t>
  
      <t>
        The way in which MAC labels are enforced is by the
        client. So if client A changes a security label on a file,
        then the server MUST inform all clients that have the file
        opened that the label has changed via CB_ATTR_CHANGED. Then
        the clients MUST retrieve the new label and MUST enforce
        access via the new attribute values.
      </t>
    </section>
  </section>
  
  <section anchor='ss:lnfs:pnfs' title='pNFS Considerations'>
    <t>
      This section examines the issues in deploying LNFS in
      a pNFS community of servers.
    </t>
  
    <section toc='exclude' anchor="ss:pnfs:checks" title="MAC Label Checks">
      <t>
        The new FATTR4_SEC_LABEL attribute is metadata information
        and as such the DS is not aware of the value contained
        on the MDS. Fortunately, the NFSv4.1 protocol <xref target='ref:RFC5661' />
        already has provisions for doing access level checks from
        the DS to the MDS. In order for the DS to validate
        the subject label presented by the client, it SHOULD
        utilize this mechanism.
      </t>
  
      <t>
        If a file's FATTR4_SEC_LABEL is changed, then the MDS
        should utilize CB_ATTR_CHANGED to inform the client
        of that fact. If the MDS is maintaining 
      </t>
    </section> 
  </section>
  
  <section anchor='ss:lnfs:discovery' title='Discovery of Server LNFS Support'>
    <t>
      The server can easily determine that a client supports LNFS
      when it queries for the FATTR4_SEC_LABEL label for an object.
      Note that it cannot assume that the presence of RPCSEC_GSSv3
      indicates LNFS support. The client might need to discover
      which LFS the server supports.
    </t>
  
    <t>
      A server which supports LNFS MUST allow a client with any subject
      label to retrieve the FATTR4_SEC_LABEL attribute for the root
      filehandle, ROOTFH. The following compound must always succeed
      as far as a MAC label check is concerned:
    </t>
  
    <figure>
      <artwork>
     PUTROOTFH, GETATTR {FATTR4_SEC_LABEL}
      </artwork>
    </figure>
  
    <t>
      Note that the server might have imposed a security flavor on
      the root that precludes such access. I.e., if the server
      requires kerberized access and the client presents a compound
      with AUTH_SYS, then the server is allowed to return NFS4ERR_WRONGSEC
      in this case. But if the client presents a correct security
      flavor, then the server MUST return the FATTR4_SEC_LABEL attribute
      with the supported LFS filled in.
    </t>
  </section>
  
  <section anchor='ss:lnfs:modes' title='MAC Security NFS Modes of Operation'>
    <t>
      A system using Labeled NFS may operate in two modes.  The first
      mode provides the most protection and is called "full mode".  In this
      mode both the client and server implement a MAC model allowing each
      end to make an access control decision.  The remaining mode is called
      the "guest mode" and in this mode one end of the connection is not
      implementing a MAC model and thus offers less protection than full mode.
    </t>
  
    <section anchor='ss:modes:full' title='Full Mode'>
      <t>
        Full mode environments consist of MAC aware NFSv4 servers and clients
        and may be composed of mixed MAC models and policies.  The system
        requires that both the client and server have an opportunity to
        perform an access control check based on all relevant information
        within the network.  The file object security attribute is provided
        using the mechanism described in <xref target='ss:lnfs:macsec' />.  The
        security attribute of the subject making the request is transported
        at the RPC layer using the mechanism described in RPCSECGSSv3
        <xref target='ref:rpcsecgssv3' />.
      </t>
  
      <section anchor='ss:modes:fm_ilt' title='Initial Labeling and Translation'>
        <t>
          The ability to create a file is an action that a MAC model may wish
          to mediate.  The client is given the responsibility to determine the
          initial security attribute to be placed on a file.  This allows the
          client to make a decision as to the acceptable security attributes to
          create a file with before sending the request to the server.  Once
          the server receives the creation request from the client it may
          choose to evaluate if the security attribute is acceptable.
        </t>
  
        <t>
          Security attributes on the client and server may vary based on MAC
          model and policy.  To handle this the security attribute field has an
          LFS component.  This component is a mechanism for the host to
          identify the format and meaning of the opaque portion of the security
          attribute.  A full mode environment may contain hosts operating in
          several different LFSs.  In this case a mechanism for
          translating the opaque portion of the security attribute is needed.
          The actual translation function will vary based on MAC model and
          policy and is out of the scope of this document.  If a translation is
          unavailable for a given LFS then the request SHOULD be
          denied.  Another recourse is to allow the host to provide a fallback
          mapping for unknown security attributes.
        </t>
      </section>
  
      <section anchor='ss:modes:fm_pe' title='Policy Enforcement'>
        <t>
          In full mode access control decisions are made by both the clients
          and servers.  When a client makes a request it takes the security
          attribute from the requesting process and makes an access control
          decision based on that attribute and the security attribute of the
          object it is trying to access.  If the client denies that access an
          RPC call to the server is never made.  If however the access is
          allowed the client will make a call to the NFS server.
        </t>
  
        <t>
          When the server receives the request from the client it extracts the
          security attribute conveyed in the RPC request.  The server then uses
          this security attribute and the attribute of the object the client is
          trying to access to make an access control decision.  If the server's
          policy allows this access it will fulfill the client's request,
          otherwise it will return NFS4ERR_ACCESS.
        </t>
  
        <t>
          Implementations MAY validate security attributes supplied over the
          network to ensure that they are within a set of attributes permitted
          from a specific peer, and if not, reject them.  Note that a system
          may permit a different set of attributes to be accepted from each
          peer.
        </t>
      </section>
  
      <section anchor='ss:modes:lfs0' title='Label Aware Only Server'>
        <t>
          If the LFS is 0, then it indicates a server which is label aware,
          but does not enforce policies. Such a server will store and retrieve
          all object labels presented by clients, notify the clients of
          any label changes via CB_ATTR_CHANGED, but will not restrict access
          via the subject label. Instead, it will expect the clients to enforce
          all such access locally.
        </t>
      </section>
    </section>
  
    <section anchor='ss:modes:guest' title='Guest Mode'>
      <t>
        Guest mode implies that either the client or the server does not
        handle labels. If the client is not LNFS aware, then it will not
        offer subject labels to the server. The server is the only entity
        enforcing policy, and may selectively provide standard NFS services
        to clients based on their authentication credentials and/or
        associated network attributes (e.g., IP address, network interface).
        The level of trust and access extended to a client in this mode is
        configuration-specific.  If the server is not LNFS aware,
        then it will not return object labels to the client. Clients in
        this environment are may consist of groups implementing different
        MAC model policies.  The system requires that all clients in the
        environment be responsible for access control checks.
      </t>
    </section>
  </section>
  
  <section anchor="ss:lnfs:security" title="Security Considerations">
    <t>
      This entire document deals with security issues.
    </t>
  
    <t>
      Depending on the level of protection the MAC system offers there may
      be a requirement to tightly bind the security attribute to the data.
    </t>
  
    <t>
      When only one of the client or server enforces labels,
      it is important to realize that the other side is
      not enforcing MAC protections.  Alternate methods might be in use to
      handle the lack of MAC support
      and care should be taken to identify and mitigate threats from
      possible tampering outside of these methods.
    </t>
  
    <t>
      An example of this is that a server that modifies READDIR
      or LOOKUP results based on the client's subject label might want
      to always construct the same subject label for a client which
      does not present one. This will prevent a non-LNFS client from
      mixing entries in the directory cache.
    </t>
  </section>
</section>
