<!-- Copyright (C) The IETF Trust (2011) -->
<!-- Copyright (C) The Internet Society (2011) -->
  
<section anchor="sec:lnfs" title="Labeled NFS">
  <section anchor="ss:lnfs:intro" title="Introduction">
    <t>
      Access control models such as Unix permissions or Access Control
      Lists are commonly referred to as Discretionary Access Control (DAC)
      models.  These systems base their access decisions on user identity
      and resource ownership.  In contrast Mandatory Access Control (MAC)
      models base their access
      control decisions on the label on the subject (usually a process) and
      the object it wishes to access.  These labels may contain user
      identity information but usually contain additional information.  In
      DAC systems users are free to specify the access rules for resources
      that they own.  MAC models base their security decisions on a system
      wide policy established by an administrator or organization which the
      users do not have the ability to override.  In this section, we add
      a MAC model to NFSv4.
    </t>
  
    <t>
      The first change necessary is to devise a method for transporting
      and storing security label data on NFSv4 file objects.  Security
      labels have several semantics that are met by NFSv4 recommended
      attributes such as the ability to set the label value upon object
      creation.  Access control on these attributes are done through a
      combination of two mechanisms.  As with other recommended attributes
      on file objects the usual DAC checks (ACLs and permission bits) will
      be performed to ensure that proper file ownership is enforced.  In
      addition a MAC system MAY be employed on the client, server, or both to
      enforce additional policy on what subjects may modify security label
      information.
    </t>
  
    <t>
      The second change is to provide a method for the server to
      notify the client that the attribute changed on an open
      file on the server. If the file is closed, then during the
      open attempt, the client will gather the new attribute value.
      The server MUST not communicate the new value of the attribute,
      the client MUST query it. This requirement stems from the
      need for the client to provide sufficient access rights to
      the attribute.
    </t>
  
    <t>
      The final change necessary is a modification to the RPC layer used
      in NFSv4 in the form of a new version of the
      RPCSEC_GSS <xref target='ref:RFC2203' /> framework.
      In order for an NFSv4 server to apply MAC checks it must obtain
      additional information from the client.  Several methods were explored for
      performing this and it was decided that the best approach was to
      incorporate the ability to make security attribute assertions through
      the RPC mechanism.  RPCSECGSSv3 <xref target='ref:rpcsecgssv3' />
      outlines a method to assert additional security information
      such as security labels on gss context creation and have that data
      bound to all RPC requests that make use of that context.
    </t>
  </section>
  
  <section anchor='ss:lnfs:defs' title='Definitions'>
    <t>
      <list style='hanging'>
        <t hangText='Label Format Specifier (LFS):'>
          is an identifier used by the client to establish
          the syntactic format of the security label and the semantic meaning
          of its components.  These specifiers exist in a registry associated
          with documents describing the format and semantics of the label.
        </t>
  
        <t hangText='Label Format Registry:'>
          is the IANA registry containing all registered
          LFS along with references to the documents that
          describe the syntactic format and semantics of the security label.
        </t>
  
        <t hangText='Policy Identifier (PI):'>
          is an optional part of the definition of a Label
          Format Specifier which allows for clients and server to identify
          specific security policies.
        </t>
  
        <t hangText='Domain of Interpretation (DOI):'>
          represents
          an administrative security boundary, where all systems within the DOI
          have semantically coherent labeling.  That is, a security attribute
          must always mean exactly the same thing anywhere within the DOI.
        </t>
  
        <t hangText='Object:'>
          is a passive resource within the system that we
          wish to be protected.  Objects can be entities such as files,
          directories, pipes, sockets, and many other system resources relevant
          to the protection of the system state.
        </t>
  
        <t hangText='Subject:'>
          A subject is an active entity usually a process which is
          requesting access to an object.
        </t>
    
        <t hangText='Multi-Level Security (MLS):'>
          is a traditional model where objects are given a sensitivity
          level (Unclassified, Secret, Top Secret,  etc) and a category set
          <xref target='ref:rh_mls' />.
        </t>
      </list>
    </t>
  </section>
  
  <section anchor="ss:lnfs:macsec" title="MAC Security Attribute">
    <t>
      MAC models base access decisions on security attributes bound to
      subjects and objects.  This information can range from a user
      identity for an identity based MAC model, sensitivity levels for
      Multi-level security, or a type for Type Enforcement.  These models
      base their decisions on different criteria but the semantics of the
      security attribute remain the same.  The semantics required by the
      security attributes are listed below:
    </t>
  
    <t>
      <list style='symbols'>
        <t>
          Must provide flexibility with respect to MAC model.
        </t>
  
        <t>
          Must provide the ability to atomically set security information
          upon object creation
        </t>
  
        <t>
          Must provide the ability to enforce access control decisions both
          on the client and the server
        </t>
  
        <t>
          Must not expose an object to either the client or server name
          space before its security information has been bound to it.
        </t>
      </list>
    </t>
  
    <t>
      NFSv4 implements the security attribute as a
      recommended attribute.  These attributes have a fixed format
      and semantics, which
      conflicts with the flexible nature of the security attribute.  To
      resolve this the security attribute consists of two components.  The
      first component is a LFS as defined in <xref target='ref:lfsreg' />
      to allow for interoperability between MAC
      mechanisms.  The second component is an opaque field which is the actual
      security attribute data.  To allow for various MAC models NFSv4
      should be used solely as a transport mechanism for the security
      attribute.  It is the responsibility of the endpoints to consume the
      security attribute and make access decisions based on their
      respective models.  In addition, creation of objects through OPEN and
      CREATE allows for the security attribute to be specified upon
      creation.  By providing an atomic create and set operation for the
      security attribute it is possible to enforce the second and fourth
      requirements.  The recommended attribute FATTR4_SEC_LABEL will
      be used to satisfy this requirement.
    </t>
  
    <section anchor='ss:macss:lnfs:interpret' title='Interpreting FATTR4_SEC_LABEL'>
      <t>
        The XDR <xref target='ref:RFC4506' /> necessary to implement Labeled
        NFSv4 is presented in <xref target='fig:xdr' />:
      </t>
  
      <figure anchor='fig:xdr'>
        <artwork>
      const FATTR4_SEC_LABEL   = 81;
  
      typedef uint32_t  policy4;
      struct labelformat_spec4 {
        policy4   lfs_lfs;
        policy4   lfs_pi;
      };
  
      struct sec_label_attr_info {
        labelformat_spec4   slai_lfs;
        opaque              slai_data&lt;&gt;;
      };
        </artwork>
      </figure>
  
      <t>
        The FATTR4_SEC_LABEL contains an array of two components with the first
        component being an LFS.  It serves to provide the receiving end
        with the information necessary to translate the security attribute
        into a form that is usable by the endpoint.  Label Formats assigned
        an LFS may optionally choose to include a Policy Identifier
        field to allow for complex policy deployments.  The LFS
        and Label Format Registry are described in detail in
        <xref target='ref:lfsreg' />.
        The translation used to interpret the security
        attribute is not specified as part of the protocol as it may depend
        on various factors.  The second component is an opaque section which
        contains the data of the attribute.  This component is dependent on
        the MAC model to interpret and enforce.
      </t>
      <t>
        In particular, it is the responsibility of the LFS specification
        to define a maximum size for the opaque section, slai_data&lt;&gt;.
        When creating or modifying a label for an object, the client
        needs to be guaranteed that the server will accept a label
        that is sized correctly. By both client and server being part
        of a specific MAC model, the client will be aware of the size.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:delegs' title='Delegations'>
      <t>
        In the event that a security attribute is changed on the server while
        a client holds a delegation on the file, the client should follow the
        existing protocol with respect to attribute changes.  It should flush
        all changes back to the server and relinquish the delegation.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:perms' title='Permission Checking'>
      <t>
        It is not feasible to enumerate all possible MAC models and even
        levels of protection within a subset of these models.  This means
        that the NFSv4 client and servers cannot be expected to directly
        make access control decisions based on the security attribute.
        Instead NFSv4 should defer permission checking on this attribute to
        the host system.  These checks are performed in addition to existing
        DAC and ACL checks outlined in the NFSv4 protocol.
        <xref target='ss:lnfs:modes' />  gives a
        specific example of how the security attribute is handled under a
        particular MAC model.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:objects' title='Object Creation'>
      <t>
        When creating files in NFSv4 the OPEN and CREATE operations are used.
        One of the parameters to these operations is an fattr4 structure
        containing the attributes the file is to be created with.  This
        allows NFSv4 to atomically set the security attribute of files upon
        creation.  When a client is MAC aware it must always provide the
        initial security attribute upon file creation.  In the event that the
        server is the only MAC aware entity in the system it should ignore
        the security attribute specified by the client and instead make the
        determination itself.  A more in depth explanation can be found in
        <xref target='ss:lnfs:modes' />.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:existing' title='Existing Objects'>
      <t>
        Note that under the MAC model, all objects must have labels.
        Therefore, if an existing server is upgraded to include LNFS support,
        then it is the responsibility of the security system to
        define the behavior for existing objects. For example, if
        the security system is LFS 0, which means the server just
        stores and returns labels, then existing files should
        return labels which are set to an empty value.
      </t>
    </section>
  
    <section anchor='ss:macss:lnfs:changes' title='Label Changes'>
      <t>
        As per the requirements, when a file's security label is
        modified, the server must notify all clients which have
        the file opened of the change in label. It does so with
        CB_ATTR_CHANGED. There are preconditions to making an
        attribute change imposed by NFSv4 and the security system might
        want to impose others. In the process of meeting these
        preconditions, the server may chose to either serve
        the request in whole or return NFS4ERR_DELAY to the
        SETATTR operation.
      </t>
  
      <t>
        If there are open delegations on the file
        belonging to client other than the one making the label
        change, then the process described in
        <xref target='ss:macss:lnfs:delegs' /> must be followed.
      </t>
  
      <t>
        As the server is always presented with the subject
        label from the client, it does not necessarily need to
        communicate the fact that the label has changed to
        the client. In the cases where the change outright denies
        the client access, the client will be able to quickly
        determine that there is a new label in effect. It is
        in cases where the client may share the same object
        between multiple subjects or a security system which
        is not strictly hierarchical that the CB_ATTR_CHANGED callback is
        very useful. It allows the server to inform the clients
        that the cached security attribute is now stale.
      </t>
  
      <t>
        Consider a system in which the clients enforce MAC checks and
        and the server has a very simple security
        system which just stores the labels. In this system, the
        MAC label check always allows access, regardless of the
        subject label. 
      </t>
  
      <t>
        The way in which MAC labels are enforced is by the smart
        client. So if client A changes a security label on a file,
        then the server MUST inform all clients that have the file
        opened that the label has changed via CB_ATTR_CHANGED. Then
        the clients MUST retrieve the new label and MUST enforce
        access via the new attribute values.
      </t>
  
      <t>
        <cref anchor="LAI1" source="TH">
          Describe a LFS of 0, which will be the means
          to indicate such a deployment. In the current
          LFR, 0 is marked as reserved. If we use it, then
          we define the default LFS to be used by a LNFS aware
          server. I.e., it lets smart clients work together in
          the face of a dumb server.  Note that will supporting
          this system is optional, it will make for a very good
          debugging mode during development. I.e., even if a server
          does not deploy with another security system, this
          mode gets your foot in the door.
        </cref>
      </t>
    </section>
  </section>
  
  <section anchor='ss:cb:lc' title="Procedure 16: CB_ATTR_CHANGED - Notify Client that the File's Attributes Changed">
    <section toc='exclude' anchor="ss:cbac:args" title='ARGUMENTS'>
      <figure>
        <artwork>
     struct CB_ATTR_CHANGED4args {
             nfs_fh4         acca_fh;
             bitmap4         acca_critical;
             bitmap4         acca_info;
     };
        </artwork>
      </figure>
    </section>
  
    <section toc='exclude' anchor="ss:cbac:result" title='RESULTS'>
      <figure>
        <artwork>
     struct CB_ATTR_CHANGED4res {
             nfsstat4        accr_status;
     };
        </artwork>
      </figure>
    </section>
  
    <section toc='exclude' anchor="ss:cbac:desc" title="DESCRIPTION">
      <t>
        The CB_ATTR_CHANGED callback operation is used by the
        server to indicate to the client that the file's attributes
        have been modified on the server. The server does not
        convey how the attributes have changed, just that they
        have been modified.  The server can inform the client
        about both critical and informational attribute changes
        in the bitmask arguments. The client SHOULD query the
        server about all attributes set in acca_critical. For
        all changes reflected in acca_info, the client can decide
        whether or not it wants to poll the server.
      </t>
  
      <t>
        The CB_ATTR_CHANGED callback operation with the FATTR4_SEC_LABEL
        set in acca_critical is the method used by the
        server to indicate that the MAC label for the file
        referenced by acca_fh has changed. In many ways, the
        server does not care about the result returned by the
        client.
      </t>
    </section> 
  </section>
  
  <section anchor='ss:lnfs:pnfs' title='pNFS Considerations'>
    <t>
      This section examines the issues in deploying LNFS in
      a pNFS community of servers.
    </t>
  
    <section toc='exclude' anchor="ss:pnfs:checks" title="MAC Label Checks">
      <t>
        The new FATTR4_SEC_LABEL attribute is metadata information
        and as such the DS is not aware of the value contained
        on the MDS. Fortunately, the NFSv4.1 protocol <xref target='ref:RFC5661' />
        already has provisions for doing access level checks from
        the DS to the MDS. In order for the DS to validate
        the subject label presented by the client, it SHOULD
        utilize this mechanism.
      </t>
  
      <t>
        If a file's FATTR4_SEC_LABEL is changed, then the MDS
        should utilize CB_ATTR_CHANGED to inform the client
        of that fact. If the MDS is maintaining 
      </t>
    </section> 
  </section>
  
  <section anchor='ss:lnfs:discovery' title='Discovery of Server LNFS Support'>
    <t>
      The server can easily determine that a client supports LNFS
      when it queries for the FATTR4_SEC_LABEL label for an object.
      Note that it cannot assume that the presence of RPCSEC_GSSv3
      indicates LNFS support. The client might need to discover
      which LFS the server supports.
    </t>
  
    <t>
      A server which supports LNFS MUST allow a client with any subject
      label to retrieve the FATTR4_SEC_LABEL attribute for the root
      filehandle, ROOTFH. The following compound must always succeed
      as far as a MAC label check is concerned:
    </t>
  
    <figure>
      <artwork>
     PUTROOTFH, GETATTR {FATTR4_SEC_LABEL}
      </artwork>
    </figure>
  
    <t>
      Note that the server might have imposed a security flavor on
      the root that precludes such access. I.e., if the server
      requires kerberized access and the client presents a compound
      with AUTH_SYS, then the server is allowed to return NFS4ERR_WRONGSEC
      in this case. But if the client presents a correct security
      flavor, then the server MUST return the FATTR4_SEC_LABEL attribute
      with the supported LFS filled in.
    </t>
  </section>
  
  <section anchor='ss:lnfs:modes' title='MAC Security NFS Modes of Operation'>
    <t>
      A system using Labeled NFS may operate in three modes.  The first
      mode provides the most protection and is called "full mode".  In this
      mode both the client and server implement a MAC model allowing each
      end to make an access control decision.  The remaining two modes are
      variations on each other and are called "smart client" and "smart
      server" modes.  In these modes one end of the connection is not
      implementing a MAC model and because of this these operating modes
      offer less protection than full mode.
    </t>
  
    <section anchor='ss:modes:full' title='Full Mode'>
      <t>
        Full mode environments consist of MAC aware NFSv4 servers and clients
        and may be composed of mixed MAC models and policies.  The system
        requires that both the client and server have an opportunity to
        perform an access control check based on all relevant information
        within the network.  The file object security attribute is provided
        using the mechanism described in <xref target='ss:lnfs:macsec' />.  The
        security attribute of the subject making the request is transported
        at the RPC layer using the mechanism described in RPCSECGSSv3
        <xref target='ref:rpcsecgssv3' />.
      </t>
  
      <section anchor='ss:modes:fm_ilt' title='Initial Labeling and Translation'>
        <t>
          The ability to create a file is an action that a MAC model may wish
          to mediate.  The client is given the responsibility to determine the
          initial security attribute to be placed on a file.  This allows the
          client to make a decision as to the acceptable security attributes to
          create a file with before sending the request to the server.  Once
          the server receives the creation request from the client it may
          choose to evaluate if the security attribute is acceptable.
        </t>
  
        <t>
          Security attributes on the client and server may vary based on MAC
          model and policy.  To handle this the security attribute field has an
          LFS component.  This component is a mechanism for the host to
          identify the format and meaning of the opaque portion of the security
          attribute.  A full mode environment may contain hosts operating in
          several different LFSs and DOIs.  In this case a mechanism for
          translating the opaque portion of the security attribute is needed.
          The actual translation function will vary based on MAC model and
          policy and is out of the scope of this document.  If a translation is
          unavailable for a given LFS and DOI then the request SHOULD be
          denied.  Another recourse is to allow the host to provide a fallback
          mapping for unknown security attributes.
        </t>
      </section>
  
      <section anchor='ss:modes:fm_pe' title='Policy Enforcement'>
        <t>
          In full mode access control decisions are made by both the clients
          and servers.  When a client makes a request it takes the security
          attribute from the requesting process and makes an access control
          decision based on that attribute and the security attribute of the
          object it is trying to access.  If the client denies that access an
          RPC call to the server is never made.  If however the access is
          allowed the client will make a call to the NFS server.
        </t>
  
        <t>
          When the server receives the request from the client it extracts the
          security attribute conveyed in the RPC request.  The server then uses
          this security attribute and the attribute of the object the client is
          trying to access to make an access control decision.  If the server's
          policy allows this access it will fulfill the client's request,
          otherwise it will return NFS4ERR_ACCESS.
        </t>
  
        <t>
          Implementations MAY validate security attributes supplied over the
          network to ensure that they are within a set of attributes permitted
          from a specific peer, and if not, reject them.  Note that a system
          may permit a different set of attributes to be accepted from each
          peer.
        </t>
      </section>
    </section>
  
    <section anchor='ss:modes:client' title='Smart Client Mode'>
      <t>
        Smart client environments consist of NFSv4 servers that are not MAC
        aware but NFSv4 clients that are.  Clients in this environment are
        may consist of groups implementing different MAC models policies.
        The system requires that all clients in the environment be
        responsible for access control checks.  Due to the amount of trust
        placed in the clients this mode is only to be used in a trusted
        environment.
      </t>
  
      <section anchor='ss:modes:sc_ilt' title='Initial Labeling and Translation'>
        <t>
          Just like in full mode the client is responsible for determining the
          initial label upon object creation.  The server in smart client mode
          does not implement a MAC model, however, it may provide the ability
          to restrict the creation and labeling of object with certain labels
          based on different criteria as described in <xref target='ss:modes:fm_pe' />.
        </t>
  
        <t>
          In a smart client environment a group of clients operate in a single
          DOI.  This removes the need for the clients to maintain a set of DOI
          translations.  Servers should provide a method to allow different
          groups of clients to access the server at the same time.  However it
          should not let two groups of clients operating in different DOIs to
          access the same files.
        </t>
      </section>
  
      <section anchor='ss:modes:sc_pe' title='Policy Enforcement'>
        <t>
          In smart client mode access control decisions are made by the
          clients.  When a client accesses an object it obtains the security
          attribute of the object from the server and combines it with the
          security attribute of the process making the request to make an
          access control decision.  This check is in addition to the DAC checks
          provided by NFSv4 so this may fail based on the DAC criteria even if
          the MAC policy grants access.  As the policy check is located on the
          client an access control denial should take the form that is native
          to the platform.
        </t>
      </section>
    </section>
  
    <section anchor='ss:modes:server' title='Smart Server Mode'>
      <t>
        Smart server environments consist of NFSv4 servers that are MAC aware
        and one or more MAC unaware clients.  The server is the only entity
        enforcing policy, and may selectively provide standard NFS services
        to clients based on their authentication credentials and/or
        associated network attributes (e.g., IP address, network interface).
        The level of trust and access extended to a client in this mode is
        configuration-specific.
      </t>
  
      <section anchor='ss:modes:ss_ilt' title='Initial Labeling and Translation'>
        <t>
          In smart server mode all labeling and access control decisions are
          performed by the NFSv4 server.  In this environment the NFSv4 clients
          are not MAC aware so they cannot provide input into the access
          control decision.  This requires the server to determine the initial
          labeling of objects.  Normally the subject to use in this calculation
          would originate from the client.  Instead the NFSv4 server may choose
          to assign the subject security attribute based on their
          authentication credentials and/or associated network attributes (e.g.,
          IP address, network interface).
        </t>
  
        <t>
          In smart server mode security attributes are contained solely within
          the NFSv4 server.  This means that all security attributes used in
          the system remain within a single LFS and DOI.  Since security
          attributes will not cross DOIs or change format there is no need to
          provide any translation functionality above that which is needed
          internally by the MAC model.
        </t>
      </section>
  
      <section anchor='ss:modes:ss_pe' title='Policy Enforcement'>
        <t>
          All access control decisions in smart server mode are made by the
          server.  The server will assign the subject a security attribute
          based on some criteria (e.g., IP address, network interface).  Using
          the newly calculated security attribute and the security attribute of
          the object being requested the MAC model makes the access control
          check and returns NFS4ERR_ACCESS on a denial and NFS4_OK on success.
          This check is done transparently to the client so if the MAC
          permission check fails the client may be unaware of the reason for
          the permission failure.  When operating in this mode administrators
          attempting to debug permission failures should be aware to check the
          MAC policy running on the server in addition to the DAC settings.
        </t>
      </section>
    </section>
  </section>
  
  <section anchor="ss:lnfs:security" title="Security Considerations">
    <t>
      This entire document deals with security issues.
    </t>
  
    <t>
      Depending on the level of protection the MAC system offers there may
      be a requirement to tightly bind the security attribute to the data.
    </t>
  
    <t>
      When only one of the client or server enforces labels,
      it is important to realize that the other side is
      not enforcing MAC protections.  Alternate methods might be in use to
      handle the lack of MAC support
      and care should be taken to identify and mitigate threats from
      possible tampering outside of these methods.
    </t>
  
    <t>
      An example of this is that a server that modifies READDIR
      or LOOKUP results based on the client's subject label might want
      to always construct the same subject label for a client which
      does not present one. This will prevent a non-LNFS client from
      mixing entries in the directory cache.
    </t>
  </section>
</section>
