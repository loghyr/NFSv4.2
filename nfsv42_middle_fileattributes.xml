<!-- Copyright (C) The IETF Trust (2011-2012) -->
<!-- Copyright (C) The Internet Society (2011-2012) -->

<section anchor="sec:file_attributes" title="New File Attributes">
  <section anchor="ss:file_attributes:REC" title="New RECOMMENDED Attributes - List and Definition References">
    <t>
      The list of new RECOMMENDED attributes appears in
      <xref target="tbl:rec_attr" />.  The meaning of the columns of the table are:
    </t>

    <t>
      <list style='hanging'>
        <t hangText='Name:'>
          The name of the attribute.
        </t>

        <t hangText='Id:'>
          The number assigned to the attribute.  In the event of
          conflicts between the assigned number and <xref target="ref:4.2xdr" />, the latter is
          likely authoritative, but should be resolved with Errata to this
          document and/or <xref target="ref:4.2xdr" />.  See <xref target="IESG08" /> for the Errata process.
        </t>

        <t hangText='Data Type:'>
          The XDR data type of the attribute.
        </t>

        <t hangText='Acc:'>
          Access allowed to the attribute.
          <list style='hanging'>
            <t hangText='R'>
              means read-only (GETATTR may retrieve, SETATTR may not set).
            </t>
            <t hangText='W '>
             means write-only (SETATTR may set, GETATTR may not retrieve).
            </t>
            <t hangText='R W '>
             means read/write (GETATTR may retrieve, SETATTR may set).
            </t>
          </list>
        </t>

        <t hangText='Defined in:'>
          The section of this specification that describes the
          attribute.
        </t>
      </list>
    </t>

    <texttable anchor="tbl:rec_attr">
      <ttcol align="left">Name</ttcol>
      <ttcol align="left">Id</ttcol>
      <ttcol align="left">Data Type</ttcol>
      <ttcol align="left">Acc</ttcol>
      <ttcol align="left">Defined in</ttcol>
      <c>change_attr_type</c> <c>79</c> <c>change_attr_type4</c>  <c>R  </c> <c><xref target="ss:fattr:chattr" /></c>
      <c>sec_label</c>        <c>80</c> <c>sec_label4</c>         <c>R W</c> <c><xref target="ss:fattr:sec" /></c>
      <c>change_sec_label</c> <c>81</c> <c>change_sec_label4</c>  <c>R  </c> <c><xref target="ss:fattr:chsec" /></c>
      <c>space_reserved</c>   <c>77</c> <c>boolean</c>            <c>R W</c> <c><xref target="ss:fattr:sr" /></c>
      <c>space_freed</c>      <c>78</c> <c>length4</c>            <c>R  </c> <c><xref target="ss:fattr:sf" /></c>
    </texttable>
  </section>

  <section anchor="ss:file_attributes:AD" title="Attribute Definitions">
    <section toc='exclude' anchor="ss:fattr:chattr" title="Attribute 79: change_attr_type">

      <?rfc include='autogen/type_chattr_type.xml'?>

      <t>
        change_attr_type is a per file system attribute which
        enables the NFSv4.2 server to
        provide additional information about how it
        expects the change attribute value to evolve after
        the file data, or metadata has changed. While Section
        5.4 of <xref target="ref:RFC5661" /> discusses
        per file system attributes, it is expected that the
        value of change_attr_type not depend on the value
        of "homogeneous" and only changes in the event of
        a migration.
      </t>

      <t>
        <list style="hanging">
          <t hangText="NFS4_CHANGE_TYPE_IS_UNDEFINED:">
            The change attribute does not take
            values that fit into any of these
            categories.
          </t>

          <t hangText="NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR:">
            The change attribute value MUST monotonically
            increase for every atomic change to the
            file attributes, data, or directory contents.
          </t>

          <t hangText="NFS4_CHANGE_TYPE_IS_VERSION_COUNTER:">
            The change attribute value MUST be incremented
            by one unit for every atomic change to the
            file attributes, data, or directory
            contents. This property is preserved
            when writing to pNFS data servers.
          </t>

          <t hangText="NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS:">
            The change attribute value MUST be incremented
            by one unit for every atomic change to the
            file attributes, data, or directory
            contents. In the case where the client
            is writing to pNFS data servers, the
            number of increments is not guaranteed
            to exactly match the number of writes.
          </t>

          <t hangText="NFS4_CHANGE_TYPE_IS_TIME_METADATA:">
            The change attribute is implemented as
            suggested in the NFSv4 spec
            <xref target="ref:RFC3530bis" /> in terms of
            the time_metadata attribute.
          </t>
        </list>
      </t>

      <t>
        If either NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR,
        NFS4_CHANGE_TYPE_IS_VERSION_COUNTER, or
        NFS4_CHANGE_TYPE_IS_TIME_METADATA are set, then
        the client knows at the very least that the
        change attribute is monotonically increasing, which
        is sufficient to resolve the question of which
        value is the most recent.
      </t>

      <t>
        If the client sees the value
        NFS4_CHANGE_TYPE_IS_TIME_METADATA, then by inspecting
        the value of the 'time_delta' attribute it
        additionally has the option of detecting rogue server
        implementations that use time_metadata in violation
        of the spec.
      </t>

      <t>
        If the client sees NFS4_CHANGE_TYPE_IS_VERSION_COUNTER,
        it has the ability to predict what the resulting change
        attribute value should be after a COMPOUND containing
        a SETATTR, WRITE, or CREATE. This again allows it to
        detect changes made in parallel by another client.
        The value NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS
        permits the same, but only if the client is not
        doing pNFS WRITEs.
      </t>

      <t>
        Finally, if the server does not support change_attr_type
        or if NFS4_CHANGE_TYPE_IS_UNDEFINED is set, then the
        server SHOULD make an effort to implement the
        change attribute in terms of the time_metadata attribute.
      </t>
    </section>

    <section toc='exclude' anchor='ss:fattr:sec' title='Attribute 80: sec_label'>
      <figure>
        <artwork>
typedef uint32_t  policy4;
        </artwork>
      </figure>

      <?rfc include='autogen/type_label_format.xml'?>

      <t>
        The FATTR4_SEC_LABEL contains an array of two components with the first
        component being an LFS.  It serves to provide the receiving end
        with the information necessary to translate the security attribute
        into a form that is usable by the endpoint.  Label Formats assigned
        an LFS may optionally choose to include a Policy Identifier
        field to allow for complex policy deployments.  The LFS
        and Label Format Registry are described in detail in
        <xref target='ref:lfsreg' />.
        The translation used to interpret the security
        attribute is not specified as part of the protocol as it may depend
        on various factors.  The second component is an opaque section which
        contains the data of the attribute.  This component is dependent on
        the MAC model to interpret and enforce.
      </t>
      <t>
        In particular, it is the responsibility of the LFS specification
        to define a maximum size for the opaque section, slai_data&lt;&gt;.
        When creating or modifying a label for an object, the client
        needs to be guaranteed that the server will accept a label
        that is sized correctly. By both client and server being part
        of a specific MAC model, the client will be aware of the size.
      </t>
    </section>

    <section toc='exclude' anchor='ss:fattr:chsec' title='Attribute 81: change_sec_label'>
      <?rfc include='autogen/type_change_label.xml'?>

      <t>
        The change_sec_label attribute is a read-only attribute per file.
        When the file is created, the value of change_sec_label is set
        to 0. Each time the sec_label is changed, the server MUST
        increment the value of change_sec_label by one. As the
        sec_label is not bounded by size, this attribute allows for
        VERIFY and NVERIFY to quickly determine if the sec_label
        has been modified.
      </t>
    </section>

    <section toc='exclude' anchor="ss:fattr:sr" title="Attribute 77: space_reserved">
      <t>
        The space_reserve attribute is a read/write attribute of type
        boolean.  It is a per file attribute.  When the space_reserved
        attribute is set via SETATTR, the server must ensure that there is
        disk space to accommodate every byte in the file before it can return
        success.  If the server cannot guarantee this, it must return
        NFS4ERR_NOSPC.
      </t>

      <t>
        If the client tries to grow a file which has the space_reserved
        attribute set, the server must guarantee that there is disk space to
        accommodate every byte in the file with the new size before it can
        return success.  If the server cannot guarantee this, it must return
        NFS4ERR_NOSPC.
      </t>

      <t>
        It is not required that the server allocate the space to the file
        before returning success.  The allocation can be deferred, however,
        it must be guaranteed that it will not fail for lack of space.
      </t>

      <t>
        The value of space_reserved can be obtained at any time through
        GETATTR.
      </t>

      <t>
        In order to avoid ambiguity, the space_reserve bit cannot be set
        along with the size bit in SETATTR.  Increasing the size of a file
        with space_reserve set will fail if space reservation cannot be
        guaranteed for the new size.  If the file size is decreased, space
        reservation is only guaranteed for the new size and the extra blocks
        backing the file can be released.
      </t>
    </section>

    <section toc='exclude' anchor="ss:fattr:sf" title="Attribute 78: space_freed">
      <t>
        space_freed gives the number of bytes freed if the file is deleted.
        This attribute is read only and is of type length4.  It is a per file
        attribute.
      </t>
    </section>
  </section>
</section>
