<!-- Copyright (C) The IETF Trust (2011-2012) -->
<!-- Copyright (C) The Internet Society (2011-2012) -->

<section anchor='sec:adh' title='Application Data Hole Support'>
  <t>
    At the OS level, files are contained on disk
    blocks.  Applications are also free to impose structure on the
    data contained in a file and we can define an Application Data
    Block (ADB) to be such a structure. From the application's
    viewpoint, it only wants to handle ADBs and not raw bytes (see
    <xref target='ref:Oracle:blocks' />). An ADB is typically
    comprised of two sections: a header and data. The header
    describes the characteristics of the block and can provide
    a means to detect corruption in the data payload.
    The data section is typically initialized to all zeros.
  </t>

  <t>
    The format of the header is application specific, but there
    are two main components typically encountered:
  </t>

  <t>
    <list style='numbers'>
      <t>
        A logical block number which allows the application to determine which
        data block is being referenced.  This is useful when the
        client is not storing the blocks in contiguous memory.
      </t>

      <t>
        Fields to describe
        the state of the ADB and a means to detect block corruption.
        For both pieces of data, a useful property is that allowed
        values be unique in that if passed across the network,
        corruption due to translation between big and little endian
        architectures are detectable.  For example, 0xF0DEDEF0 has
        the same bit pattern in both architectures.
      </t>
    </list>
  </t>

  <t>
    Applications already impose structures on files
    <xref target='ref:Oracle:blocks' /> and detect corruption
    in data blocks <xref target='ref:Oracle:corruption' />.
    What they are not able to do is efficiently transfer and
    store ADBs. To initialize a file with ADBs, the client
    must send the full ADB to the server and that must be stored
    on the server.
  </t>

  <t>
    In this section, we are going to define an Application Data
    Hole (ADH), which is a generic framework
    for transfering the  ADB, present one approach to detecting corruption in
    a given ADH implementation, and describe the model for
    how the client and server can support efficient initialization
    of ADHs, reading of ADH holes, punching ADH holes in a file, and space
    reservation. We define the ADHN to be the Application Data Hole
    Number, which is the logical block number discussed earlier.
  </t>

  <section anchor='ss:adh:framework' title='Generic Framework'>
    <t>
      We want the representation of the ADH to be flexible
      enough to support many different applications. The most
      basic approach is no imposition of a block at all, which
      means we are working with the raw bytes. Such an approach
      would be useful for storing holes, punching holes, etc.
      In more complex deployments, a server might be supporting
      multiple applications, each with their own definition of
      the ADH. One might store the ADHN at the start of the block
      and then have a guard pattern to detect corruption
      <xref target='ref:solaris:corruption' />. The next
      might store the ADHN at an offset of 100 bytes within the
      block and have no guard pattern at all, i.e.,
      existing applications might already have well defined
      formats for their data blocks.
    </t>

    <t>
      The guard pattern can be used to represent the state of
      the block, to protect against corruption, or both. Again,
      it needs to be able to be placed anywhere within the
      ADH.
    </t>

    <t>
      We need to be able to represent the starting
      offset of the block and the size of the block. Note that
      nothing prevents the application from defining different
      sized blocks in a file.
    </t>

    <section anchor='ss:adh:dh' title='Data Hole Representation'>
      <?rfc include='autogen/app_data_hole4.xml'?>

      <t>
        The app_data_hole4 structure captures the abstraction presented
        for the ADH. The additional fields present are to allow
        the transmission of adh_block_count ADHs at one time.  We
        also use adh_block_num to convey the ADHN of the first block
        in the sequence.  Each ADH will contain the same adh_pattern
        string.
      </t>

      <t>
        As both adh_block_num and adh_pattern are optional, if
        either adh_reloff_pattern or adh_reloff_blocknum is set
        to NFS4_UINT64_MAX, then the corresponding field is not
        set in any of the ADH.
      </t>
    </section>

    <section anchor='ss:adh:dc' title='Data Content'>
      <?rfc include='autogen/data_content4.xml'?>

      <t>
        New operations might need to differentiate between
        wanting to access data versus an ADH. Also, future
        minor versions might want to introduce new data
        formats. This enumeration allows that to occur.
      </t>
    </section>
  </section>

  <section anchor='ss:adh:corrupt' title='An Example of Detecting Corruption'>
    <t>
      In this section, we define an ADH format in which
      corruption can be detected. Note that this is just
      one possible format and means to detect corruption.
    </t>

    <t>
      Consider a very basic implementation of an operating
      system's disk blocks. A block is either data or it
      is an indirect block which allows for files to be
      larger than one block. It is desired to be able
      to initialize a block. Lastly, to quickly unlink
      a file, a block can be marked invalid. The contents
      remain intact - which would enable this OS application
      to undelete a file.
    </t>

    <t>
      The application defines 4k sized data blocks, with an
      8 byte block counter occurring at offset 0 in the block,
      and with the guard pattern occurring at offset 8 inside
      the block. Furthermore, the guard pattern can take one
      of four states:
    </t>

    <t>
      <list style='hanging'>
        <t hangText='0xfeedface - '>
          This is the FREE state and indicates that the
          ADH format has been applied.
        </t>

        <t hangText='0xcafedead - '>
          This is the DATA state and indicates that real
          data has been written to this block.
        </t>

        <t hangText='0xe4e5c001 - '>
          This is the INDIRECT state and indicates that the block
          contains block counter numbers that are chained off of
          this block.
        </t>

        <t hangText='0xba1ed4a3 - '>
          This is the INVALID state and indicates that the
          block contains data whose contents are garbage.
        </t>
      </list>
    </t>

    <t>
      Finally, it also defines an 8 byte
      checksum <xref target='ref:storage_stack' /> starting at
      byte 16 which applies to the remaining
      contents of the block. If the state is FREE, then
      that checksum is trivially zero. As such, the application
      has no need to transfer the checksum implicitly inside the
      ADH - it need not make the transfer layer aware of the
      fact that there is a checksum (see
      <xref target='ref:Oracle:corruption' /> for an example
      of checksums used to detect corruption in application
      data blocks).
    </t>

    <t>
      Corruption in each ADH can be detected thusly:
    </t>

    <t>
      <list style='symbols'>
        <t>
          If the guard pattern is anything other than one
          of the allowed values, including all zeros.
        </t>

        <t>
          If the guard pattern is FREE and any other
          byte in the remainder of the ADH is anything other
          than zero.
        </t>

        <t>
          If the guard pattern is anything other than FREE,
          then if the stored checksum does not match the
          computed checksum.
        </t>

        <t>
          If the guard pattern is INDIRECT and one of the
          stored indirect block numbers has a value greater
          than the number of ADHs in the file.
        </t>

        <t>
          If the guard pattern is INDIRECT and one of the
          stored indirect block numbers is a duplicate of
          another stored indirect block number.
        </t>
      </list>
    </t>

    <t>
      As can be seen, the application can detect errors based
      on the combination of the guard pattern state and the
      checksum. But also, the application can detect corruption
      based on the state and the contents of the ADH.
      This last point is important in validating the minimum
      amount of data we incorporated into our generic
      framework. I.e., the guard pattern is sufficient
      in allowing applications to design their own
      corruption detection.
    </t>

    <t>
      Finally, it is important to note that none of these
      corruption checks occur in the transport layer. The
      server and client components are totally unaware of
      the file format and might report everything as being
      transferred correctly even in the case the application
      detects corruption.
    </t>
  </section>

  <section anchor='ss:adh:ex_rp' title='Example of READ_PLUS'>
    <t>
      The hypothetical application presented in
      <xref target='ss:adh:corrupt' /> can be used to
      illustrate how READ_PLUS would return an array
      of results. A file is created and initialized
      with 100 4k ADHs in the FREE state:
    </t>

    <figure>
      <artwork>
   WRITE_PLUS {0, 4k, 100, 0, 0, 8, 0xfeedface}
      </artwork>
    </figure>

    <t>
      Further, assume the application writes a single
      ADH at 16k, changing the guard pattern to 0xcafedead,
      we would then have in memory:
    </t>

    <figure>
      <artwork>
   0 -> (16k - 1)   : 4k, 4, 0, 0, 8, 0xfeedface
   16k -> (20k - 1) : 00 00 00 05 ca fe de ad XX XX ... XX XX
   20k -> 400k      : 4k, 95, 0, 6, 0xfeedface
      </artwork>
    </figure>

    <t>
     And when the client did a READ_PLUS of 64k at the start of the file,
     it would get back a result of an ADH, some data, and a final ADH:
    </t>

    <figure>
      <artwork>
   ADH {0, 4, 0, 0, 8, 0xfeedface}
   data 4k
   ADH {20k, 4k, 59, 0, 6, 0xfeedface}
      </artwork>
    </figure>
  </section>
</section>
