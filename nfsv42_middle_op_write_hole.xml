<!-- Copyright (C) The IETF Trust (2011-2014) -->
<!-- Copyright (C) The Internet Society (2011-2014) -->

<section anchor='op:write_hole' title='Operation 64: WRITE_HOLE'>
  <section toc='exclude' title="ARGUMENT">
    <?rfc include='autogen/data_info4.xml'?>
    <?rfc include='autogen/write_hole_args.xml'?>
  </section>

  <section toc='exclude' title="RESULT">
    <?rfc include='autogen/write_response4.xml'?>
    <?rfc include='autogen/write_hole_res.xml'?>
  </section>

  <section toc='exclude' anchor='op:write_hole:desc'  title="DESCRIPTION">
    <t>
      The WRITE_HOLE operation is an extension of the NFSv4.1 WRITE
      operation (see Section 18.2 of <xref target="RFC5661" />) and
      writes holes to the regular file identified by the
      current filehandle.  The server MAY write fewer bytes than
      requested by the client.
    </t>

    <t>
      A successful WRITE_HOLE will construct a reply for wr_count, wr_committed,
      and wr_writeverf as per the NFSv4.1 WRITE operation results.
      If wr_callback_id is set, it indicates an asynchronous reply
      (see <xref target='op:write_hole:async' />).
    </t>

    <t>
      WRITE_HOLE has to support all of the errors which are returned by WRITE
      plus NFS4ERR_NOTSUPP, i.e., it is an OPTIONAL operation.
      If the client supports WRITE_HOLE, it MUST support CB_OFFLOAD. 
    </t>

    <section title="Data">
      <t>
        The d_offset specifies the offset where
        the data should be written.  An d_offset of zero specifies
        that the write should start at the beginning of the file.  The
        d_count, as encoded as part of the opaque data parameter,
        represents the number of bytes of data that are to be written.
        If the d_count is zero, the WRITE_HOLE will succeed and
        return a d_count of zero subject to permissions checking.
      </t>

      <t>
        Note that d_allocated has no meaning for WRITE_HOLE.
      </t>

      <t>
        The data MUST be written synchronously and MUST follow the
        same semantics of COMMIT as does the WRITE operation.
      </t>
    </section>

    <section title="Hole punching">
      <t>
        Whenever a client wishes to zero the blocks backing a
        particular region in the file, it calls the WRITE_HOLE operation with
        the current filehandle set to the filehandle of the file in question,
        and the equivalent of start offset and length in bytes of the region
        set in wpa_hole.di_offset and wpa_hole.di_length respectively.  If the
        wpa_hole.di_allocated is set to TRUE, then the blocks will be zeroed and
        if it is set to FALSE, then they will be deallocated. All
        further reads to this region MUST return zeros until overwritten.
        The filehandle specified must be that of a regular file.
      </t>

      <t>
        Situations may arise where di_offset and/or
        di_offset + di_length will not be aligned to a
        boundary that the server does allocations/deallocations in.  For
        most file systems, this is the block size of
        the file system.  In such a case, the server can deallocate as many
        bytes as it can in the region.  The blocks that cannot be deallocated
        MUST be zeroed.  Except for the block deallocation and maximum hole
        punching capability, a WRITE_HOLE operation is to be treated similar
        to a write of zeroes.
      </t>

      <t>
        The server is not required to complete deallocating the blocks
        specified in the operation before returning.  The server SHOULD
        return an asynchronous result if it can determine the
        operation will be long running
        (see <xref target='op:write_hole:async' />).
      </t>

      <t>
        If used to hole punch, WRITE_HOLE will result in the space_used
        attribute being decreased by the number of bytes that were
        deallocated.  The space_freed attribute
        may or may not decrease, depending on the support and whether the
        blocks backing the specified range were shared or not.  The size
        attribute will remain unchanged.
      </t>

      <t>
        The WRITE_HOLE operation MUST NOT change the space reservation
        guarantee of the file.  While the server can deallocate the blocks
        specified by di_offset and di_length, future writes to this region
        MUST NOT fail with NFSERR_NOSPC.
      </t>
    </section>

    <section anchor='op:write_hole:async' title='Asynchronous Transactions'>
      <t>
        Both hole punching and ADH initialization may 
        lead to server determining to service the
        operation asynchronously. If it decides to
        do so, it sets the stateid in wr_callback_id
        to be that of the wp_stateid. If it does
        not set the wr_callback_id, then the result
        is synchronous.
      </t>

      <t>
        When the client determines that the reply
        will be given asynchronously, it should not
        assume anything about the contents of what
        it wrote until it is informed by the server
        that the operation is complete. It can
        use OFFLOAD_STATUS (<xref target="op:offload_status" />)
        to monitor the operation and
        OFFLOAD_ABORT (<xref target="op:offload_abort" />)
        to cancel the operation. An example of
        a asynchronous WRITE_HOLE is shown in
        <xref target='fig:async-write_hole' />. Note that
        as with the COPY operation, WRITE_HOLE must
        provide a stateid for tracking the asynchronous
        operation.
      </t>

      <figure title="An asynchronous WRITE_HOLE." anchor="fig:async-write_hole">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the file
     |                                      |
     |--- WRITE_HOLE ---------------------->| Client punches
     |<------------------------------------/| a hole
     |                                      |
     |                                      |
     |--- OFFLOAD_STATUS ------------------>| Client may poll
     |<------------------------------------/| for status
     |                                      |
     |                  .                   | Multiple OFFLOAD_STATUS
     |                  .                   | operations may be sent.
     |                  .                   |
     |                                      |
     |<-- CB_OFFLOAD -----------------------| Server reports results
     |\------------------------------------>|
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the file
     |                                      |
     |                                      |
        ]]></artwork>
      </figure>

      <t>
        When CB_OFFLOAD informs the client of
        the successful WRITE_HOLE, the write_response4
        embedded in the operation will provide
        the necessary information that a synchronous
        WRITE_HOLE would have provided.
      </t>

      <t>
        Regardless of whether the operation is asynchronous or
        synchronous, it MUST still support the COMMIT operation semantics
        as outlined in Section 18.3 of <xref target="RFC5661" />.
        I.e., COMMIT works on one or more WRITE operations and the
        WRITE_HOLE operation can appear as several WRITE operations
        to the server.  The client can use locking operations to control the behavior
        on the server with respect to long running asynchronous
        write operations.
      </t>
    </section>
  </section>
</section>
