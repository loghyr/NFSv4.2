<!-- Copyright (C) The IETF Trust (2011-2014) -->
<!-- Copyright (C) The Internet Society (2011-2014) -->

<section anchor='op:write_hole' title='Operation 64: WRITE_HOLE'>
  <section toc='exclude' title="ARGUMENT">
    <?rfc include='autogen/stable_how4.xml'?>
    <?rfc include='autogen/data_info4.xml'?>
    <?rfc include='autogen/write_hole_args.xml'?>
  </section>

  <section toc='exclude' title="RESULT">
    <?rfc include='autogen/write_response4.xml'?>
    <?rfc include='autogen/write_hole_res.xml'?>
  </section>

  <section toc='exclude' anchor='op:write_hole:desc'  title="DESCRIPTION">
    <t>
      Whenever a client wishes to reinitialize the blocks backing
      a particular region in the file, it calls the WRITE_HOLE
      operation with the current filehandle set to the filehandle
      of the file in question, and the equivalent of start offset
      and length in bytes of the region set in wh_hole.di_offset
      and wh_hole.di_length respectively.  If the wh_hole.di_allocated
      is set to TRUE, then the blocks will be zeroed and if it is
      set to FALSE, then they will be deallocated. All further reads
      to this region MUST return zeros until overwritten.  The
      filehandle specified must be that of a regular file.
    </t>

    <t>
      The client specifies with the ws_stable parameter the method of how the
      data is to be processed by the server.  It is treated like the stable
      parameter in the NFSv4.1 WRITE operation (see Section 18.2 of
      <xref target="RFC5661" />).
    </t>

    <t>
      Situations may arise where di_offset and/or di_offset +
      di_length will not be aligned to a boundary for which the
      server does allocations or deallocations.  For most file
      systems, this is the block size of the file system.  In such
      a case, the server can deallocate as many bytes as it can in
      the region.  The blocks that cannot be deallocated MUST be
      zeroed.  Except for the block deallocation and maximum hole
      punching capability, a WRITE_HOLE operation is to be treated
      similar to a write of zeroes.
    </t>

    <t>
      The server is not required to complete deallocating the blocks
      specified in the operation before returning.  The server
      SHOULD return an asynchronous result if it can determine the
      operation will be long running (see
      <xref target='op:write_hole:async' />).
    </t>

    <t>
      A successful WRITE_HOLE will construct a reply for wr_count,
      wr_committed, and wr_writeverf as per the NFSv4.1 WRITE
      operation results.  If wr_callback_id is set, it indicates
      an asynchronous reply (see <xref target='op:write_hole:async' />).
    </t>

    <t>
      WRITE_HOLE has to support all of the errors which are returned by WRITE
      plus NFS4ERR_NOTSUPP, i.e., it is an OPTIONAL operation.
      If the client supports WRITE_HOLE, it MUST support CB_OFFLOAD.
    </t>

    <t>
      If used to hole punch, WRITE_HOLE will result in the space_used
      attribute being decreased by the number of bytes that were
      deallocated.  The space_freed attribute
      may or may not decrease, depending on the support and whether the
      blocks backing the specified range were shared or not.  The size
      attribute will remain unchanged.
    </t>

    <t>
      The WRITE_HOLE operation MUST NOT change the space reservation
      guarantee of the file.  While the server can deallocate the blocks
      specified by di_offset and di_length, future writes to this region
      MUST NOT fail with NFSERR_NOSPC.
    </t>

    <section anchor='op:write_hole:async' title='Asynchronous Transactions'>
      <t>
        Hole punching may lead to server determining to service the
        operation asynchronously. If it decides to do so, it sets the
        stateid in wr_callback_id to be that of the wh_stateid. If it
        does not set the wr_callback_id, then the result is synchronous.
      </t>

      <t>
        When the client determines that the reply will be given
        asynchronously, it should not assume anything about the
        contents of what it wrote until it is informed by the server
        that the operation is complete. It can use OFFLOAD_STATUS
        (<xref target="op:offload_status" />) to monitor the operation
        and OFFLOAD_ABORT (<xref target="op:offload_abort" />) to cancel
        the operation. An example of a asynchronous WRITE_HOLE is shown
        in <xref target='fig:async-write_hole' />. Note that as with the
        COPY operation, WRITE_HOLE must provide a stateid for tracking
        the asynchronous operation.
      </t>

      <figure title="An asynchronous WRITE_HOLE." anchor="fig:async-write_hole">
        <artwork><![CDATA[
  Client                                  Server
     +                                      +
     |                                      |
     |--- OPEN ---------------------------->| Client opens
     |<------------------------------------/| the file
     |                                      |
     |--- WRITE_HOLE ---------------------->| Client punches
     |<------------------------------------/| a hole
     |                                      |
     |                                      |
     |--- OFFLOAD_STATUS ------------------>| Client may poll
     |<------------------------------------/| for status
     |                                      |
     |                  .                   | Multiple OFFLOAD_STATUS
     |                  .                   | operations may be sent.
     |                  .                   |
     |                                      |
     |<-- CB_OFFLOAD -----------------------| Server reports results
     |\------------------------------------>|
     |                                      |
     |--- CLOSE --------------------------->| Client closes
     |<------------------------------------/| the file
     |                                      |
     |                                      |
        ]]></artwork>
      </figure>

      <t>
        When CB_OFFLOAD informs the client of
        the successful WRITE_HOLE, the write_response4
        embedded in the operation will provide
        the necessary information that a synchronous
        WRITE_HOLE would have provided.
      </t>

      <t>
        Regardless of whether the operation is asynchronous or
        synchronous, it MUST still support the COMMIT operation semantics
        as outlined in Section 18.3 of <xref target="RFC5661" />.
        I.e., COMMIT works on one or more WRITE operations and the
        WRITE_HOLE operation can appear as several WRITE operations
        to the server.  The client can use locking operations to control the behavior
        on the server with respect to long running asynchronous
        write operations.
      </t>
    </section>
  </section>
</section>
