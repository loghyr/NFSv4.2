<!-- Copyright (C) The IETF Trust (2011) -->
<!-- Copyright (C) The Internet Society (2011) -->

<section anchor="sec:space" title="Space Reservation">
  <section anchor="ss:space:intro" title="Introduction">
    <t>
      This section describes a set of operations that allow applications
      such as hypervisors to reserve space for a file, report the amount of
      actual disk space a file occupies and freeup the backing space of a
      file when it is not required.  In virtualized environments, virtual
      disk files are often stored on NFS mounted volumes.  Since virtual
      disk files represent the hard disks of virtual machines, hypervisors
      often have to guarantee certain properties for the file.
    </t>

    <t>
      One such example is space reservation.  When a hypervisor creates a
      virtual disk file, it often tries to preallocate the space for the
      file so that there are no future allocation related errors during the
      operation of the virtual machine.  Such errors prevent a virtual
      machine from continuing execution and result in downtime.
    </t>

    <t>
      Currently, in order to achieve such a guarantee, applications zero
      the entire file.  The initial zeroing allocates the backing blocks
      and all subsequent writes are overwrites of already allocated blocks.
      This approach is not only inefficient in terms of the amount of I/O
      done, it is also not guaranteed to work on filesystems that are log
      structured or deduplicated.  An efficient way of guaranteeing space
      reservation would be beneficial to such applications.
    </t>

    <t>
      If the space_reserved attribute is set on a file, it is guaranteed
      that writes that do not grow the file will not fail with NFSERR_NOSPC.
    </t>

    <t>
      Another useful feature would be the ability to report the number of
      blocks that would be freed when a file is deleted.  Currently, NFS
      reports two size attributes:
    </t>

    <t>
      <list style="hanging">
        <t hangText="size">
          The logical file size of the file.
        </t>

        <t hangText="space_used">
          The size in bytes that the file occupies on disk
        </t>
      </list>
    </t>

    <t>
      While these attributes are sufficient for space accounting in
      traditional filesystems, they prove to be inadequate in modern
      filesystems that support block sharing.  In such filesystems,
      multiple inodes can point to a single block with a block reference
      count to guard against premature freeing.  Having a way to tell the
      number of blocks that would be freed if the file was deleted would be
      useful to applications that wish to migrate files when a volume is
      low on space.
    </t>

    <t>
      Since virtual disks represent a hard drive in a virtual machine, a
      virtual disk can be viewed as a filesystem within a file.  Since not
      all blocks within a filesystem are in use, there is an opportunity to
      reclaim blocks that are no longer in use.  A call to deallocate
      blocks could result in better space efficiency.  Lesser space MAY be
      consumed for backups after block deallocation.
    </t>

    <t>
      The following operations and attributes can be used to resolve
      this issues:
    </t>

    <t>
      <list style="hanging">
        <t hangText="space_reserved">
          This attribute specifies whether the blocks backing
          the file have been preallocated.
        </t>

        <t hangText="space_freed">
          This attribute specifies the space freed when a file is
          deleted, taking block sharing into consideration.
        </t>

        <t hangText="max_hole_punch">
          This attribute specifies the maximum sized hole that
          can be punched on the filesystem.
        </t>

        <t hangText="INITIALIZED">
          This operation zeroes and/or deallocates the blocks
          backing a region of the file.
        </t>
      </list>
    </t>

    <t>
      If space_used of a file is interpreted to mean the size in bytes of
      all disk blocks pointed to by the inode of the file, then shared
      blocks get double counted, over-reporting the space utilization.
      This also has the adverse effect that the deletion of a file with
      shared blocks frees up less than space_used bytes.
    </t>

    <t>
      On the other hand, if space_used is interpreted to mean the size in
      bytes of those disk blocks unique to the inode of the file, then
      shared blocks are not counted in any file, resulting in
      under-reporting of the space utilization.
    </t>

    <t>
      For example, two files A and B have 10 blocks each.  Let 6 of these
      blocks be shared between them.  Thus, the combined space utilized by
      the two files is 14 * BLOCK_SIZE bytes.  In the former case, the
      combined space utilization of the two files would be reported as 20 *
      BLOCK_SIZE.  However, deleting either would only result in 4 *
      BLOCK_SIZE being freed.  Conversely, the latter interpretation would
      report that the space utilization is only 8 * BLOCK_SIZE.
    </t>

    <t>
      Adding another size attribute, space_freed, is helpful in solving
      this problem. space_freed is the number of blocks that are allocated
      to the given file that would be freed on its deletion.  In the
      example, both A and B would report space_freed as 4 * BLOCK_SIZE and
      space_used as 10 * BLOCK_SIZE.  If A is deleted, B will report
      space_freed as 10 * BLOCK_SIZE as the deletion of B would result in
      the deallocation of all 10 blocks.
    </t>

    <t>
      The addition of this problem doesn't solve the problem of space being
      over-reported.  However, over-reporting is better than under-reporting.
    </t>
  </section>

  <section anchor="ss:space:ops" title="Operations and attributes">
    <t>
      In the sections that follow, one operation and three attributes are
      defined that together provide the space management facilities
      outlined earlier in the document.  The operation is intended to be
      OPTIONAL and the attributes RECOMMENDED as defined in section 17 of
      <xref target="ref:RFC5661" />.
    </t>
  </section>

  <section anchor="ss:space:ops:sr" title="Attribute 77: space_reserved">
    <t>
      The space_reserve attribute is a read/write attribute of type
      boolean.  It is a per file attribute.  When the space_reserved
      attribute is set via SETATTR, the server must ensure that there is
      disk space to accommodate every byte in the file before it can return
      success.  If the server cannot guarantee this, it must return
      NFS4ERR_NOSPC.
    </t>

    <t>
      If the client tries to grow a file which has the space_reserved
      attribute set, the server must guarantee that there is disk space to
      accommodate every byte in the file with the new size before it can
      return success.  If the server cannot guarantee this, it must return
      NFS4ERR_NOSPC.
    </t>

    <t>
      It is not required that the server allocate the space to the file
      before returning success.  The allocation can be deferred, however,
      it must be guaranteed that it will not fail for lack of space.
    </t>

    <t>
      The value of space_reserved can be obtained at any time through
      GETATTR.
    </t>

    <t>
      In order to avoid ambiguity, the space_reserve bit cannot be set
      along with the size bit in SETATTR.  Increasing the size of a file
      with space_reserve set will fail if space reservation cannot be
      guaranteed for the new size.  If the file size is decreased, space
      reservation is only guaranteed for the new size and the extra blocks
      backing the file can be released.
    </t>
  </section>

  <section anchor="ss:space:ops:sf" title="Attribute 78: space_freed">
    <t>
      space_freed gives the number of bytes freed if the file is deleted.
      This attribute is read only and is of type length4.  It is a per file
      attribute.
    </t>
  </section>

  <section anchor="ss:space:ops:mhp" title="Attribute 79: max_hole_punch">
    <t>
      max_hole_punch specifies the maximum size of a hole that the
      INITIALIZE operation can handle.  This attribute is read only and of
      type length4.  It is a per filesystem attribute.  This attribute MUST
      be implemented if INITIALIZE is implemented.
      <cref anchor='AIX1' source='TH'>
        max_hole_punch when doing ADB initialization?
      </cref>
    </t>
  </section>
</section>
